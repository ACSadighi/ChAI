StaticTensor

Usage:
   use StaticTensor;

or

   import StaticTensor;

   Record: tensor : serializable
      param rank: int
      type eltType = real(64)
      var resource: shared(BaseTensorResource(eltType, rank))
      proc  meta 
      proc  _dom 
      proc  init(param rank: int, type eltType = real(64)) 
      proc  init(in resource: shared(BaseTensorResource(?eltType, ?rank))) 
      proc  init(in resource: owned(BaseTensorResource(?eltType, ?rank))) 
      proc  init( array: ndarray(?rank, ?eltType)) 
      proc  init( dom: domain(?), type eltType = real) 
      proc  init( arr: [] ?eltType) 
      proc  init( it: _iteratorRecord) 
      proc  this(args ...) 
      proc  reshapeDomain( dom: this._dom.type) 
      proc  _setArrayData( value) 
      proc  detach( copy: bool = true,  keepGrad: bool = false) : tensor(rank, eltType)
   operator :(in t: tensor(?rank, ?eltType), type toType) : tensor(rank, toType)
   proc tensorFromCtx(param rank: int, type eltType,  ctx) : tensor(rank, eltType)
   operator +( a: tensor(?rank, ?eltType),  b: tensor(rank, eltType)) 
   operator -( a: tensor(?rank, ?eltType),  b: tensor(rank, eltType)) 
   operator *( a: tensor(?rank, ?eltType),  b: tensor(rank, eltType)) 
   operator /( a: tensor(?rank, ?eltType),  b: tensor(rank, eltType)) 
   proc  tensor.reshape( dom: domain(?)) 
   proc  tensor.reshape(newShape: int ...?newRank) 
   proc  tensor.relu() 
   proc  tensor.permute(axes: int ...rank) 
   proc  tensor.expand(axes: int ...rank) 
   proc  tensor.pad(args: 2*int ...rank,  value: eltType = 0.0) 
   proc  tensor.shrink(args: 2*int ...rank) 
   proc  tensor.slice( dom: domain(?))  where dom.rank == rank
   proc  tensor.slice(rngs: range ...rank) 
   proc  tensor.sum(axes: int ...?r) 
   proc  tensor.unsqueeze( dim: int) : tensor(rank+1, eltType)
   proc  tensor.max() : tensor(1, eltType)
   proc  tensor.exp() : tensor(rank, eltType)
   proc  tensor.softmax() : tensor(rank, eltType)
   proc matvec( mat: tensor(2, ?eltType),  vec: tensor(1, eltType)) : tensor(1, eltType)
   proc matvec( mat: tensor(2, ?eltType),  vec: tensor(2, eltType)) : tensor(2, eltType)
   proc type tensor.matvecmul( m,  v) 
   proc type tensor.convolve( features: tensor(3, ?eltType),  kernel: tensor(4, eltType),  stride: int) : tensor(3, eltType)
   proc type tensor.convolve( features: tensor(3, ?eltType),  kernel: tensor(4, eltType),  bias: tensor(1, eltType),  stride: int) : tensor(3, eltType)
   proc type tensor.matvecmulFast( mat: tensor(2, ?eltType),  vec: tensor(1, eltType)) : tensor(1, eltType)
   proc  tensor.dilate( dil: int) : tensor(3, eltType) where this.rank == 3
   proc  tensor.maxPool( poolSize: int) : tensor(3, eltType) where this.rank == 3
   proc type tensor.arange( to: int, type eltType = real,  shape: ?rank*int) : tensor(rank, eltType)
   proc type tensor.arange(shape: int ...?rank) : tensor(rank, real)
   proc type tensor.fromShape(type eltType = real, shape: int ...?rank,  value: eltType = 0: eltType) : tensor(rank, eltType)
   proc type tensor.zeros(shape: int ...?rank) : tensor(rank, real)
   proc type tensor.zeros(type eltType, shape: int ...?rank) : tensor(rank, eltType)
   proc type tensor.ones(shape: int ...?rank) : tensor(rank, real)
   proc type tensor.ones(type eltType, shape: int ...?rank) : tensor(rank, eltType)
   config const n = 100
   config const diag = false
   config const size = 3
   proc main() 
   proc  tensor.serialize( writer: IO.fileWriter(locking = false, IO.defaultSerializer), ref serializer: IO.defaultSerializer) 
   proc  tensor.serialize( writer: IO.fileWriter(?), ref serializer: ?srt2)  where srt2 != IO.defaultSerializer
   proc  tensor.serialize( writer: IO.fileWriter(locking = false, IO.defaultSerializer), ref serializer: IO.defaultSerializer, param capitalT: bool)  where capitalT == true
   proc ref tensor.read( fr: IO.fileReader(?))  throws
