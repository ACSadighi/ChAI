DynamicTensor

Usage:
   use DynamicTensor;

or

   import DynamicTensor;

   config param maxRank = 6
   param defaultDetachedMode = true
   Record: Tensor : serializable
      type eltType = real
      var meta: shared(TensorEssence(eltType))
      var runtimeRank: int = -1
      proc  init(type eltType) 
      proc  init(type eltType, in meta: shared(TensorEssence(eltType))) 
      proc  init(in meta: shared(TensorEssence(?eltType))) 
      proc  init( t: tensor(?rank, ?eltType),  detached: bool = Tensor.detachMode()) 
      proc  init( a: ndarray(?rank, ?eltType)) 
      proc  init( arr: [] ?eltType) 
      proc  this(args ...) 
      proc  tensorize(param rank: int) : tensor(rank, eltType)
      proc  resource(param rank: int) : shared(BaseTensorResource(eltType, rank))
      proc  forceRank(param rank: int) : tensor(rank, eltType)
      proc  forceRankMeta(param rank: int) : shared(BaseTensorResource(eltType, rank))
      proc  hardCheckRank(param rank: int) : bool
      proc  checkRank(param rank: int) : bool
      proc  to( device: locale) 
      proc  device : locale
      proc  array(param rank: int) ref: ndarray(rank, eltType)
      proc  grad(param rank: int) ref: ndarray(rank, eltType)
      proc  data(param rank: int) ref: [] eltType
      proc  toNDArray(param rank: int) : ndarray(rank, eltType)
      proc  toArray(param rank: int) : [] eltType
      proc  detach() : Tensor(eltType)
   operator :(in t: Tensor(?eltType), type toType) : Tensor(toType)
   proc type Tensor.detachMode() param: bool
   proc type Tensor.detachMode( detachMode: bool) 
   proc  ndarray.toTensor() : Tensor(eltType)
   proc  tensor.eraseRank( detach: bool = Tensor.detachMode()) : Tensor(eltType)
   operator :( t: tensor(?rank, ?eltType), type T: Tensor(eltType)) : Tensor(eltType)
   proc zipBinOp(param opName: string,  a: Tensor(?eltType),  b: Tensor(eltType)) : Tensor(eltType)
   proc type Tensor.loadFromNumpy( path: string) : Tensor(real)
   operator +( a: Tensor(?eltType),  b: Tensor(eltType)) : Tensor(eltType)
   operator -( a: Tensor(?eltType),  b: Tensor(eltType)) : Tensor(eltType)
   operator *( a: Tensor(?eltType),  b: Tensor(eltType)) : Tensor(eltType)
   proc  Tensor.sum(axes: int ...?r) : Tensor(eltType)
   proc  Tensor.relu() : Tensor(eltType)
   proc  Tensor.max() : Tensor(eltType)
   proc  Tensor.exp() : Tensor(eltType)
   proc  Tensor.softmax() : Tensor(eltType)
   proc  Tensor.maxPool( poolSize: int) : Tensor(eltType)
   proc  Tensor.reshape(args ...) : Tensor(eltType)
   proc  Tensor.slice(rngs: range ...?rank) : Tensor(eltType)
   proc  Tensor.slice( dom: domain(?)) : Tensor(eltType)
   proc  Tensor.flatten() : Tensor(eltType)
   proc type Tensor.matvecmul( m: Tensor(?eltType),  v: Tensor(eltType)) : Tensor(eltType)
   proc type Tensor.matvecmulFast( m: Tensor(?eltType),  v: Tensor(eltType)) : Tensor(eltType)
   proc  Tensor.argmax() : int
   proc type Tensor.convolve( features: Tensor(?eltType),  kernel: Tensor(eltType),  stride: int) : Tensor(eltType)
   proc type Tensor.convolve( features: Tensor(?eltType),  kernel: Tensor(eltType),  bias: Tensor(eltType),  stride: int) : Tensor(eltType)
   proc type Tensor.arange(args ...) 
   proc type Tensor.ones(args ...) 
   proc type Tensor.zeros(args ...) 
   proc main() 
   proc  Tensor.serialize( writer: IO.fileWriter(locking = false, IO.defaultSerializer), ref serializer: IO.defaultSerializer) 
   proc  Tensor.serialize( writer: IO.fileWriter(?), ref serializer: ?srt2)  where srt2 != IO.defaultSerializer
   proc  Tensor.write( fw: IO.fileWriter(?))  throws
   proc  Tensor.save( path: string) 
   proc type Tensor.multiReader( path: string) 
   proc type Tensor.load( path: string, param precision = 64) : Tensor(real)
   proc type Tensor.readInPlace( fr: IO.fileReader(?), param precision = 64) : Tensor(real)
