Network

Usage:
   use Network;

or

   import Network;

   proc helpFindModuleByName( arg,  x: string) : borrowed(Module(?))
   proc helpFindParamDataByName( arg,  x: string) ref: Tensor(?)
   Record: moduleChildren
      type eltType = real
      var childDict: map(string, borrowed(Module(eltType)))
      var order: list(string)
      proc  init(type eltType = real) 
      iter ref these() : borrowed(Module(eltType))
      iter ref items() : (string, borrowed(Module(eltType)))
      proc ref add( name: string,  m: borrowed(Module(eltType))) 
      proc ref ith( i: int) : borrowed(Module(eltType))
   proc  class.this( fieldName: string) : borrowed(Module(?)) where isSubtype(this.type, Module(?))
   proc  class.this( fieldName: string) ref: Tensor(?) where isSubtype(this.type, Parameter(?))
   iter  class.moduleFieldNames() : string where isSubtype(this.type, Module(?))
   iter  class.moduleFields() : (string, borrowed(Module(?))) where isSubtype(this.type, Module(?))
   proc  class.registerModules()  where isSubtype(this.type, Module(?))
   proc  class.postinit()  where isSubtype(this.type, Module(?))
   Record: moduleAttributes : serializable
      var layerType: string
      var moduleName: string
      var attributes: dict(string, string)
      proc  init( layerType: string,  moduleName: string, in attrs: map(string, string, ?)) 
      proc  init( layerType: string,  moduleName: string, in attrs: dict(string, ?)) 
      proc  init( layerType: string,  moduleName: string, in attrs: map(string, ?valType, ?))  where valType != string
      proc  init( layerType: string,  moduleName: string, in attrs: map(string, ?valType, ?),  order: list(string)) 
      proc  init( layerType: string,  moduleName: string, attrs ...?n)  where attrs(0)(0).type == string
      proc  init( layerType: string,  moduleName: string) 
      proc  getInt( name: string) : int
      proc  prettyPrint() : string
      proc  prettyPrintSpec() : string
      operator  :( ma: moduleAttributes, type T: string) 
   Class: ModuleSpecification : serializable
      var layerType: string
      var attributes: map(string, string)
      var subModules: map(string, owned(ModuleSpecification?))
      var subModuleOrder: list(string)
   proc moduleFromSpec( ms_: borrowed(ModuleSpecification?), type dtype = real(32)) : owned(Module(dtype))
   proc modelFromSpecFile( path: string, type dtype = real(32)) : owned(Module(dtype))
   proc loadModel( specFile: string,  weightsFolder: string, type dtype = real(32)) : owned(Module(dtype))
   var moduleInstances = 0
   Class: Module
      type eltType
      var subModules: moduleChildren(eltType)
      var moduleId: int
      var moduleName: string
      var ownedModules: list(shared(Module(eltType)))
      proc  init(type eltType = real) 
      proc  init(type eltType = real,  ma: moduleAttributes) 
      proc  setup() 
      proc  this( input: Tensor(eltType)) : Tensor(eltType)
      proc  getSubModuleName( name: string) : string
      proc  addModule( name: string,  m: borrowed(Module(eltType))) 
      proc  addModule( name: string,  m: shared(Module(eltType))) 
      proc  addModule( name: string, in m: owned(Module(eltType))) 
      proc  addParameter( name: string,  data: Tensor(eltType)) 
      proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      proc  par( paramName: string) ref: Tensor(eltType)
      proc  mod( modName: string) : borrowed(Module(eltType))
      iter  parameters() : borrowed(Parameter(eltType))
      iter  moduleNames() : string
      iter  parameterNames() : string
      iter  modules() : borrowed(Module(eltType))
      iter  namedModules() : (string, borrowed(Module(eltType)))
      proc  loadPyTorchDump( modelPath: string, param debug = false) 
      proc  attributes() : moduleAttributes
      proc  signature : string
   Class: Parameter : Module(?)
      var data: Tensor(eltType)
      proc  init( data: Tensor(?eltType)) 
      override proc  attributes() : moduleAttributes
   Class: Sequential : Module(?)
      var mds: list(shared(Module(eltType)))
      proc  init(type eltType = real,  ms: dict(string, shared(Module(eltType))), param overrideName = false,  moduleName: string = "") 
      proc  init(type eltType = real, in ms) 
      proc  init(type eltType = real,  order: list(string), in ms: map(string, owned(Module(eltType)?))) 
      proc  init(in ms: owned Module(real)? ...?rank) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: Linear : Module(?)
      var m: int

   var n: m.type

      var weight: owned(Parameter(eltType))
      var bias: owned(Parameter(eltType))
      proc  init(type eltType,  m: int,  n: int) 
      override proc  setup() 
      proc  init( m: int,  n: int) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: Conv2D : Module(?)
      var kernelShape: 4*(int)
      var stride: int
      var kernel: owned(Parameter(eltType))
      var bias: owned(Parameter(eltType))
      proc  init(type eltType = real,  channels: int,  features: int,  kernel: int,  stride: int = 1) 
      proc  init(type eltType = real,  ma: moduleAttributes) 
      override proc  setup() 
      proc  init( channels: int,  features: int,  kernel: int,  stride: int = 1) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: MaxPool : Module(?)
      var poolSize: int
      proc  init(type eltType = real,  poolSize: int) 
      proc  init( poolSize: int) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: Flatten : Module(?)
      proc  init(type eltType = real) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: ReLU : Module(?)
      proc  init(type eltType = real) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: Softmax : Module(?)
      proc  init(type eltType = real) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   Class: Dropout : Module(?)
      proc  init(type eltType = real,  freq: real = 0.5) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
      override proc  attributes() : moduleAttributes
   proc chain( m: borrowed(Module(?)), modNames: string ...?n,  input: Tensor(?eltType)) 
   Class: Net : Module(?)
      proc  init(type eltType = real) 
      override proc  forward( input: Tensor(eltType)) : Tensor(eltType)
   proc main() 
