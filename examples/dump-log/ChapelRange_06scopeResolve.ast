AST dump for ChapelRange after pass scopeResolve.
Module use list: ChapelBase HaltWrappers AutoMath DSIUtil Reflection ChapelDebugPrint 

{
  unknown debugChapelRange[107087] "config" "param" 0
  (107090 'end of statement')
  unknown useOptimizedRangeIterators[107092] "config" "param" 1
  (107095 'end of statement')
  unknown newSliceRule[107097] "config" "deprecated" "param" 1
  (107100 'end of statement')
  unknown newRangeLiteralType[107102] "config" "param" 0
  (107105 'end of statement')
  unknown unalignedMark[107107] "param" "private"(107108 call - 1)
  (107112 'end of statement')
  type boundKind[107122] def both[107114]:boundKind[107122] def low[107116]:boundKind[107122] def high[107118]:boundKind[107122] def neither[107120]:boundKind[107122]
  {
  }
  type strideKind[107137] def one[107127]:strideKind[107137] def negOne[107129]:strideKind[107137] def positive[107131]:strideKind[107137] def negative[107133]:strideKind[107137] def any[107135]:strideKind[107137]
  {
  }
  type range[240](?) unknown idxType[107143] "type variable" int(64)[10] unknown bounds[107147] "param" both[107114] boundKind[107122] unknown strides[107156] "param" one[107127] strideKind[107137] unknown _low[107165](107167 call chpl__idxTypeToIntIdxType idxType[107143]) unknown _high[107172](107174 call chpl__idxTypeToIntIdxType idxType[107143]) unknown _stride[107179](107191 IfExpr (107186 call(107183 call . strides[107156] c"isPosNegOne")) then
  { scopeless
    nothing[7]
  } else
  { scopeless
    (107189 call chpl__rangeStrideType idxType[107143])
  } ) unknown _alignment[107197](107207 IfExpr (107202 call(107199 call . strides[107156] c"isPosNegOne")) then
  { scopeless
    nothing[7]
  } else
  { scopeless
    (107205 call chpl__rangeStrideType idxType[107143])
  } )
  function range[240](?).strType[107214](arg _mt[107220]:_MT[201], arg this[107217]:range[240](?) :
  range[240](?)) type : _unknown[42] "method" "no parens" "@unstable"
  {
    (107223 return(107225 call chpl__rangeStrideType(425795 call . this[107217] c"idxType")))
  }
  function range[240](?).chpl__promotionType[107229](arg _mt[107235]:_MT[201], arg this[107232]:range[240](?) :
  range[240](?)) type : _unknown[42] "method"
  {
    (107238 return(425800 call . this[107232] c"idxType"))
  }
  function range[240](?).chpl_integralIdxType[107242](arg _mt[107248]:_MT[201], arg this[107245]:range[240](?) :
  range[240](?)) type : _unknown[42] "method" "no parens"
  {
    (107251 return(107253 call chpl__idxTypeToIntIdxType(425805 call . this[107245] c"idxType")))
  }
  function isFiniteIdxType[107257](arg t[107259]:_any[141](?)) param : _unknown[42] "private"
  {
    (107262 return(107263 call ||(107266 call isBoolType t[107259])(107269 call isEnumType t[107259])))
  }
  function finiteIdxTypeLow[107273](arg t[107275]:_any[141](?)) param : _unknown[42] "private"
  {
    if(107284 call _cond_test(107282 call isFiniteIdxType t[107275]))
    {
      (107278 return 0)
    }
    (107290 call compilerError(107291 call +(107293 call + "finiteIdxTypeLow() undefined for type '"(107298 call : t[107275] string[244])) "'"))
  }
  function finiteIdxTypeHigh[107305](arg t[107307]:_any[141](?)) param : _unknown[42] "private"
  {
    if(107316 call _cond_test(107314 call isBoolType t[107307]))
    {
      (107310 return 1)
    }
    if(107333 call _cond_test(107331 call isEnumType t[107307]))
    {
      (107321 return(107322 call -(107325 call . t[107307] c"size") 1))
    }
    (107339 call compilerError(107340 call +(107342 call + "finiteIdxTypeHigh() undefined for type '"(107347 call : t[107307] string[244])) "'"))
  }
  function lowBoundForIter[107354](arg r[107356]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(107384 call _cond_test(107383 call(107380 call . r[107356] c"hasLowBound")))
    {
      (107359 return(107361 call . r[107356] c"lowBound"))
    }
    {
      (107365 return(107367 call chpl__intToIdx(107369 call . r[107356] c"idxType")(107373 call finiteIdxTypeLow(107375 call . r[107356] c"idxType"))))
    }
  }
  function highBoundForIter[107392](arg r[107394]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(107422 call _cond_test(107421 call(107418 call . r[107394] c"hasHighBound")))
    {
      (107397 return(107399 call . r[107394] c"highBound"))
    }
    {
      (107403 return(107405 call chpl__intToIdx(107407 call . r[107394] c"idxType")(107411 call finiteIdxTypeHigh(107413 call . r[107394] c"idxType"))))
    }
  }
  function hasLowBoundForIter[107430](arg r[107432]:_any[141](?)) param : _unknown[42] "private"
  {
    (107435 return(107436 call ||(107442 call(107439 call . r[107432] c"hasLowBound"))(107444 call isFiniteIdxType(107446 call . r[107432] c"idxType"))))
  }
  function hasHighBoundForIter[107451](arg r[107453]:_any[141](?)) param : _unknown[42] "private"
  {
    (107456 return(107457 call ||(107463 call(107460 call . r[107453] c"hasHighBound"))(107465 call isFiniteIdxType(107467 call . r[107453] c"idxType"))))
  }
  function range[240](?).init[107472](arg _mt[107488]:_MT[201], arg this[107475]:range[240](?) :
  range[240](?), arg idxType[107478]:_any[141](?), arg low[107481] :
  idxType[107478], arg high[107485] :
  idxType[107478]) : _unknown[42] "method" "no return value for void"
  {
    (107491 call =(107494 call . this[107475] c"idxType") idxType[107478])
    (107498 call =(107501 call . this[107475] c"bounds") both[107114])
    (107508 call =(107513 call . this[107475] c"_low")(107517 call chpl__idxToInt low[107481]))
    (107519 call =(107524 call . this[107475] c"_high")(107528 call chpl__idxToInt high[107485]))
  }
  function range[240](?).init[107532](arg _mt[107543]:_MT[201], arg this[107535]:range[240](?) :
  range[240](?), arg low[107540] :
  unknown t[107538]) : _unknown[42] "method" "no return value for void"
  {
    (107546 call =(107549 call . this[107535] c"idxType") t[107538])
    (107553 call =(107556 call . this[107535] c"bounds") low[107116])
    (107563 call =(107566 call . this[107535] c"_low")(107570 call chpl__idxToInt low[107540]))
    (107576 call(107573 call . this[107535] c"chpl__initThisType"))
    if(107590 call _cond_test(107588 call isFiniteIdxType(425829 call . this[107535] c"idxType")))
    {
      (107578 call =(107581 call . this[107535] c"_high")(107585 call finiteIdxTypeHigh(425824 call . this[107535] c"idxType")))
    }
  }
  function range[240](?).init[107596](arg _mt[107607]:_MT[201], arg this[107599]:range[240](?) :
  range[240](?), arg high[107604] :
  unknown t[107602]) : _unknown[42] "method" "no return value for void"
  {
    (107610 call =(107613 call . this[107599] c"idxType") t[107602])
    (107617 call =(107620 call . this[107599] c"bounds") high[107118])
    (107627 call =(107630 call . this[107599] c"_high")(107634 call chpl__idxToInt high[107604]))
    (107640 call(107637 call . this[107599] c"chpl__initThisType"))
    if(107654 call _cond_test(107652 call isFiniteIdxType(425841 call . this[107599] c"idxType")))
    {
      (107642 call =(107645 call . this[107599] c"_low")(107649 call finiteIdxTypeLow(425836 call . this[107599] c"idxType")))
    }
  }
  function range[240](?).init[107660](arg _mt[107666]:_MT[201], arg this[107663]:range[240](?) :
  range[240](?)) : _unknown[42] "method" "no return value for void"
  {
    (107669 call =(107672 call . this[107663] c"idxType") int(64)[10])
    (107676 call =(107679 call . this[107663] c"bounds") neither[107120])
    (107690 call(107687 call . this[107663] c"chpl__initThisType"))
    if(107713 call _cond_test(107711 call isFiniteIdxType(425856 call . this[107663] c"idxType")))
    {
      (107692 call =(107695 call . this[107663] c"_low")(107699 call finiteIdxTypeLow(425846 call . this[107663] c"idxType")))
      (107701 call =(107704 call . this[107663] c"_high")(107708 call finiteIdxTypeHigh(425851 call . this[107663] c"idxType")))
    }
  }
  function range[240](?).init[107719](arg _mt[107735]:_MT[201], arg this[107722]:range[240](?) :
  range[240](?), arg idxType[107725]:_any[141](?), param arg bounds[107728] :
  boundKind[107122], param arg strides[107732] :
  strideKind[107137]) : _unknown[42] "method" "no return value for void"
  {
    if(107763 call _cond_test(107744 call && 0(107747 call ||(107749 call == bounds[107728] low[107116])(107756 call == bounds[107728] high[107118]))))
    {
      (107739 call warning "Default initialization of a range with 'boundKind.low' or 'boundKind.high' is unstable")
    }
    (107772 call(107769 call . this[107722] c"init") idxType[107725] bounds[107728] strides[107732](_low =(107777 call chpl__defaultLowBound idxType[107725] bounds[107728]))(_high =(107782 call chpl__defaultHighBound idxType[107725] bounds[107728]))(_stride =(107786 call :(107794 call(107791 call . strides[107732] c"defaultStride"))(107796 call chpl__rangeStrideType idxType[107725])))(alignmentValue =(107799 call : 0(107803 call chpl__rangeStrideType idxType[107725]))))
  }
  function range[240](?).init[107808](arg _mt[107828]:_MT[201], arg this[107811]:range[240](?) :
  range[240](?), arg idxType[107814]:_any[141](?), param arg bounds[107817] :
  boundKind[107122], param arg strides[107821] :
  strideKind[107137], param arg internal[107825] :
  bool[19]) : _unknown[42] "method" "no return value for void"
  {
    (107835 call(107832 call . this[107811] c"init") idxType[107814] bounds[107817] strides[107821](_low =(107840 call chpl__defaultLowBound idxType[107814] bounds[107817]))(_high =(107845 call chpl__defaultHighBound idxType[107814] bounds[107817]))(_stride =(107849 call :(107855 call(107852 call . strides[107821] c"defaultStride"))(107857 call chpl__rangeStrideType idxType[107814])))(alignmentValue =(107860 call : 0(107864 call chpl__rangeStrideType idxType[107814]))))
  }
  function range[240](?).init[107869](arg _mt[107899]:_MT[201], arg this[107872]:range[240](?) :
  range[240](?), arg idxType[107875]:_any[141](?), param arg bounds[107878] :
  boundKind[107122], param arg strides[107882] :
  strideKind[107137], arg _low[107885]:_any[141](?), arg _high[107887]:_any[141](?), arg _stride[107889]:_any[141](?), arg _alignment[107891]:_any[141](?), arg _aligned[107893]:_any[141](?), param arg normalizeAlignment[107896] =
  1) : _unknown[42] "method" "no return value for void"
  {
    unknown almtType[107903] "type variable"(107905 call chpl__rangeStrideType idxType[107875])
    const alignmentValue[107909] "const"(107938 IfExpr (107914 call(107911 call . strides[107882] c"isPosNegOne")) then
    { scopeless
      none[48]
    } else
    { scopeless(107935 IfExpr (107916 call ! _aligned[107893]) then
      { scopeless
        (107919 call : unalignedMark[107107] almtType[107903])
      } else
      { scopeless(107932 IfExpr  normalizeAlignment[107896] then
        { scopeless
          (107924 call :(107927 call chpl__mod _alignment[107891] _stride[107889]) almtType[107903])
        } else
        { scopeless
          _alignment[107891]
        } )
      } )
    } )
    (107942 'end of statement')
    (107947 call(107944 call . this[107872] c"init") idxType[107875] bounds[107878] strides[107882] _low[107885] _high[107887] _stride[107889] alignmentValue[107909])
  }
  function range[240](?).init[107957](arg _mt[107981]:_MT[201], arg this[107960]:range[240](?) :
  range[240](?), arg idxType[107963]:_any[141](?), param arg bounds[107966] :
  boundKind[107122], param arg strides[107970] :
  strideKind[107137], arg _low[107973]:_any[141](?), arg _high[107975]:_any[141](?), arg _stride[107977]:_any[141](?), arg alignmentValue[107979]:_any[141](?)) : _unknown[42] "method" "no return value for void"
  {
    (107984 call =(107987 call . this[107960] c"idxType") idxType[107963])
    (107991 call =(107994 call . this[107960] c"bounds") bounds[107966])
    (107998 call =(108001 call . this[107960] c"strides") strides[107970])
    (108005 call =(108008 call . this[107960] c"_low")(108011 call : _low[107973](108015 call chpl__idxTypeToIntIdxType idxType[107963])))
    (108017 call =(108020 call . this[107960] c"_high")(108023 call : _high[107975](108027 call chpl__idxTypeToIntIdxType idxType[107963])))
    if(108063 call _cond_test(108059 call !(108062 call(425919 call . this[107960] c"hasParamStrideAltvalAld"))))
    {
      (108030 call =(108035 call . this[107960] c"_stride") _stride[107977])
      (108039 call =(108044 call . this[107960] c"_alignment") alignmentValue[107979])
      if(108054 call _cond_test 1)
      {
        (108049 call verifyAppropriateStride strides[107970] _stride[107977])
      }
    }
  }
  function range[240](?).init=[108069](arg _mt[108086]:_MT[201], arg this[108072]:range[240](?) :
  range[240](?), arg other[108083] :
  (108076 call range[240](?) unknown i[108077] unknown b[108079] unknown s[108081])) : _unknown[42] "method" "no return value for void"
  {
    unknown idxType[108090] "type variable"(108105 IfExpr (108091 call ==(108095 call .(108094 'typeof' this[108072]) c"idxType") ?[227]) then
    { scopeless
      i[108077]
    } else
    { scopeless
      (108102 call .(108101 'typeof' this[108072]) c"idxType")
    } )
    unknown bounds[108110] "param"(108125 IfExpr (108111 call ==(108115 call .(108114 'typeof' this[108072]) c"bounds") ?[227]) then
    { scopeless
      b[108079]
    } else
    { scopeless
      (108122 call .(108121 'typeof' this[108072]) c"bounds")
    } )
    (108129 'end of statement')
    unknown strides[108131] "param"(108146 IfExpr (108132 call ==(108136 call .(108135 'typeof' this[108072]) c"strides") ?[227]) then
    { scopeless
      s[108081]
    } else
    { scopeless
      (108143 call .(108142 'typeof' this[108072]) c"strides")
    } )
    (108150 'end of statement')
    if(108174 call _cond_test(108168 call !(108171 call assignmentIsLegal idxType[108090] i[108077])))
    {
      (108152 call compilerError "initializing a range with idxType "(108156 call : idxType[108090] string[244]) " from a range with idxType "(108163 call : i[108077] string[244]))
    }
    if(108200 call _cond_test(108196 call != bounds[108110] b[108079]))
    {
      (108180 call compilerError "initializing a range with boundKind."(108184 call : bounds[108110] string[244]) " from a range with boundKind."(108191 call : b[108079] string[244]))
    }
    if(108228 call _cond_test(108222 call !(108225 call chpl_assignStrideIsSafe strides[108131] s[108081])))
    {
      (108206 call compilerError "initializing a range with strideKind."(108210 call : strides[108131] string[244]) " from a range with strideKind."(108217 call : s[108081] string[244]))
    }
    unknown isEnumBool[108234] "param"(108236 call isFiniteIdxType idxType[108090])
    (108239 'end of statement')
    unknown bt[108241] "type variable"(108245 call . other[108083] c"chpl_integralIdxType")
    const low[108250] "const"(108271 IfExpr (108251 call && isEnumBool[108234](108254 call !(108260 call(108257 call . other[108083] c"hasLowBound")))) then
    { scopeless
      (108261 call :(108264 call finiteIdxTypeLow idxType[108090]) bt[108241])
    } else
    { scopeless
      (108268 call . other[108083] c"_low")
    } )
    (108275 'end of statement')
    const high[108277] "const"(108298 IfExpr (108278 call && isEnumBool[108234](108281 call !(108287 call(108284 call . other[108083] c"hasHighBound")))) then
    { scopeless
      (108288 call :(108291 call finiteIdxTypeHigh idxType[108090]) bt[108241])
    } else
    { scopeless
      (108295 call . other[108083] c"_high")
    } )
    (108302 'end of statement')
    const str[108304] "const"(108305 call :(108308 call . other[108083] c"stride")(108312 call chpl__rangeStrideType idxType[108090]))
    (108315 'end of statement')
    unknown alignment[108317](108318 call :(108332 IfExpr (108326 call(108323 call . other[108083] c"hasParamAlignmentField")) then
    { scopeless
      0
    } else
    { scopeless
      (108329 call . other[108083] c"_alignment")
    } )(108336 'typeof' str[108304]))
    (108338 'end of statement')
    if(108375 call _cond_test(108363 call && isEnumBool[108234](108366 call !(108374 call(108371 call . other[108083] c"isAligned")))))
    {
      if(108359 call _cond_test(108356 call isPositiveStride strides[108131] str[108304]))
      {
        (108341 call = alignment[108317](108345 call finiteIdxTypeLow idxType[108090]))
        {
        }
      }
      {
        (108349 call = alignment[108317](108353 call finiteIdxTypeHigh idxType[108090]))
      }
    }
    (108383 call(108380 call . this[108072] c"init") idxType[108090] bounds[108110] strides[108131] low[108250] high[108277] str[108304] alignment[108317])
  }
  function range[240](?).displayRepresentation[108393](arg _mt[108405]:_MT[201], arg this[108396]:range[240](?) :
  range[240](?), arg msg[108401] :
  string[244] =
  "") : _unknown[42] "method"
  {
    function :[108409](arg arg[108412] :
    nothing[7], arg t[108416] :
    string[244]) param : _unknown[42] "operator"
    {
      (108420 return "none")
    }
    (108425 call chpl_debug_writeln msg[108401] "range("(108430 call :(425971 call . this[108396] c"_low") string[244]) ".."(108437 call :(425976 call . this[108396] c"_high") string[244]) " by "(108442 call :(425981 call . this[108396] c"_stride") string[244]) " align "(108449 call :(425986 call . this[108396] c"_alignment") string[244]) " : "(108456 call :(425991 call . this[108396] c"idxType") string[244]) ","(108461 call :(425996 call . this[108396] c"bounds") string[244]) ","(108466 call :(426001 call . this[108396] c"strides") string[244]) ")")
  }
  { scopeless type
    void[4]
  }
  function computeParamRangeIndexType_Old[108474](param arg low[108476]:_any[141](?), param arg high[108478]:_any[141](?)) type : _unknown[42] "private"
  {
    if(108546 call _cond_test(108523 call &&(108525 call &&(108527 call ==(108530 'typeof' low[108476]) int(64)[10])(108532 call <=(108535 call min(108537 'typeof' high[108478])) low[108476]))(108539 call <= low[108476](108543 call max(108545 'typeof' high[108478])))))
    {
      (108482 return(108484 'typeof' high[108478]))
    }
    {
      if(108519 call _cond_test(108496 call &&(108498 call &&(108500 call ==(108503 'typeof' high[108478]) int(64)[10])(108505 call <=(108508 call min(108510 'typeof' low[108476])) high[108478]))(108512 call <= high[108478](108516 call max(108518 'typeof' low[108476])))))
      {
        (108486 return(108488 'typeof' low[108476]))
      }
      {
        (108490 return(108495 'typeof'(108491 call + low[108476] high[108478])))
      }
    }
  }
  function computeParamRangeIndexType[108553](param arg low[108555]:_any[141](?), param arg high[108557]:_any[141](?)) type : _unknown[42] "private"
  {
    if(108568 call _cond_test newRangeLiteralType[107102])
    {
      (108561 return(108566 'typeof'(108562 call + low[108555] high[108557])))
    }
    unknown newRule[108573] "type variable"(108578 'typeof'(108574 call + low[108555] high[108557]))
    unknown oldRule[108581] "type variable"(108583 call computeParamRangeIndexType_Old low[108555] high[108557])
    if(108594 call _cond_test(108590 call == newRule[108573] oldRule[108581]))
    {
      (108587 return newRule[108573])
    }
    (108600 call compilerWarning "the idxType of this range literal "(108604 call : low[108555] string[244]) ".."(108609 call : high[108557] string[244]) " with the low bound of the type "(108616 call :(108619 'typeof' low[108555]) string[244]) " and the high bound of the type "(108624 call :(108627 'typeof' high[108557]) string[244]) " is currently "(108632 call : oldRule[108581] string[244]) ". In a future release it will be switched to "(108639 call : newRule[108573] string[244]) ". To switch to this new typing and turn off this warning," " compile with -snewRangeLiteralType.")
    (108649 return oldRule[108581])
  }
  function chpl_isValidRangeIdxType[108653](arg t[108655]:_any[141](?)) param : _unknown[42]
  {
    (108658 return(108659 call ||(108661 call ||(108664 call isIntegralType t[108655])(108667 call isEnumType t[108655]))(108670 call isBoolType t[108655])))
  }
  function chpl_build_bounded_range[108674](param arg low[108677] :
  integral[159](?), param arg high[108681] :
  integral[159](?)) : _unknown[42]
  {
    unknown idxType[108686] "type variable"(108688 call computeParamRangeIndexType low[108677] high[108681])
    (108692 return(108693 'new'(108695 call range[240](?) idxType[108686](low = low[108677])(high = high[108681]))))
  }
  function chpl_build_bounded_range[108703](arg low[108708] :
  (108706 call int(64)[10] 8), arg high[108714] :
  (108712 call int(64)[10] 8)) : _unknown[42]
  {
    (108718 return(108719 'new'(108721 call range[240](?)(108723 call int(64)[10] 8)(low = low[108708])(high = high[108714]))))
  }
  function chpl_build_bounded_range[108731](arg low[108736] :
  (108734 call int(64)[10] 16), arg high[108742] :
  (108740 call int(64)[10] 16)) : _unknown[42]
  {
    (108746 return(108747 'new'(108749 call range[240](?)(108751 call int(64)[10] 16)(low = low[108736])(high = high[108742]))))
  }
  function chpl_build_bounded_range[108759](arg low[108764] :
  (108762 call int(64)[10] 32), arg high[108770] :
  (108768 call int(64)[10] 32)) : _unknown[42]
  {
    (108774 return(108775 'new'(108777 call range[240](?)(108779 call int(64)[10] 32)(low = low[108764])(high = high[108770]))))
  }
  function chpl_build_bounded_range[108787](arg low[108792] :
  (108790 call int(64)[10] 64), arg high[108798] :
  (108796 call int(64)[10] 64)) : _unknown[42]
  {
    (108802 return(108803 'new'(108805 call range[240](?)(108807 call int(64)[10] 64)(low = low[108792])(high = high[108798]))))
  }
  function chpl_build_bounded_range[108815](arg low[108820] :
  (108818 call uint(64)[86] 8), arg high[108826] :
  (108824 call uint(64)[86] 8)) : _unknown[42]
  {
    (108830 return(108831 'new'(108833 call range[240](?)(108835 call uint(64)[86] 8)(low = low[108820])(high = high[108826]))))
  }
  function chpl_build_bounded_range[108843](arg low[108848] :
  (108846 call uint(64)[86] 16), arg high[108854] :
  (108852 call uint(64)[86] 16)) : _unknown[42]
  {
    (108858 return(108859 'new'(108861 call range[240](?)(108863 call uint(64)[86] 16)(low = low[108848])(high = high[108854]))))
  }
  function chpl_build_bounded_range[108871](arg low[108876] :
  (108874 call uint(64)[86] 32), arg high[108882] :
  (108880 call uint(64)[86] 32)) : _unknown[42]
  {
    (108886 return(108887 'new'(108889 call range[240](?)(108891 call uint(64)[86] 32)(low = low[108876])(high = high[108882]))))
  }
  function chpl_build_bounded_range[108899](arg low[108904] :
  (108902 call uint(64)[86] 64), arg high[108910] :
  (108908 call uint(64)[86] 64)) : _unknown[42]
  {
    (108914 return(108915 'new'(108917 call range[240](?)(108919 call uint(64)[86] 64)(low = low[108904])(high = high[108910]))))
  }
  function chpl_build_bounded_range[108927](arg low[108930] :
  enum[147](?), arg high[108934] :
  enum[147](?)) : _unknown[42]
  {
    if(108950 call _cond_test(108944 call !=(108947 'typeof' low[108930])(108949 'typeof' high[108934])))
    {
      (108939 call compilerError "ranges of enums must use a single enum type")
    }
    (108955 return(108956 'new'(108958 call range[240](?)(108960 'typeof' low[108930])(low = low[108930])(high = high[108934]))))
  }
  function chpl_build_bounded_range[108967](arg low[108970] :
  bool[19], arg high[108974] :
  bool[19]) : _unknown[42]
  {
    (108978 return(108979 'new'(108981 call range[240](?) bool[19](low = low[108970])(high = high[108974]))))
  }
  function chpl_build_bounded_range[108989](arg low[108991]:_any[141](?), arg high[108993]:_any[141](?)) : _unknown[42] "no return value for void"
  {
    if(109056 call _cond_test(109050 call ==(109053 'typeof' low[108991])(109055 'typeof' high[108993])))
    {
      (109009 call compilerError(109010 call +(109012 call + "Ranges defined using bounds of type '"(109017 call :(109020 'typeof' low[108991]) string[244])) "' are not currently supported"))
    }
    {
      (109027 call compilerError(109028 call +(109030 call +(109032 call +(109034 call + "Ranges defined using bounds of type '"(109037 call :(109040 'typeof' low[108991]) string[244])) "..")(109043 call :(109046 'typeof' high[108993]) string[244])) "' are not currently supported"))
    }
  }
  where {
    (108995 call !(108997 call &&(109000 call chpl_isValidRangeIdxType(109002 'typeof' low[108991]))(109004 call chpl_isValidRangeIdxType(109006 'typeof' high[108993]))))
  }
  function chpl__nudgeLowBound[109065](arg low[109067]:_any[141](?)) : _unknown[42]
  {
    (109070 return(109072 call chpl__intToIdx(109074 'typeof' low[109067])(109075 call +(109078 call chpl__idxToInt low[109067]) 1)))
  }
  function chpl__nudgeLowBound[109083](param arg low[109085]:_any[141](?)) param : _unknown[42]
  {
    (109088 return(109090 call chpl__intToIdx(109092 'typeof' low[109085])(109093 call +(109096 call chpl__idxToInt low[109085]) 1)))
  }
  function chpl__nudgeHighBound[109101](arg high[109103]:_any[141](?)) : _unknown[42]
  {
    (109106 return(109108 call chpl__intToIdx(109110 'typeof' high[109103])(109111 call -(109114 call chpl__idxToInt high[109103]) 1)))
  }
  function chpl__nudgeHighBound[109119](param arg high[109121]:_any[141](?)) param : _unknown[42]
  {
    (109124 return(109126 call chpl__intToIdx(109128 'typeof' high[109121])(109129 call -(109132 call chpl__idxToInt high[109121]) 1)))
  }
  function chpl_build_low_bounded_range[109137](arg low[109140] :
  integral[159](?)) : _unknown[42]
  {
    (109144 return(109145 'new'(109147 call range[240](?)(low = low[109140]))))
  }
  function chpl_build_low_bounded_range[109152](arg low[109155] :
  enum[147](?)) : _unknown[42]
  {
    (109159 return(109160 'new'(109162 call range[240](?)(low = low[109155]))))
  }
  function chpl_build_low_bounded_range[109167](arg low[109170] :
  bool[19]) : _unknown[42]
  {
    (109174 return(109175 'new'(109177 call range[240](?)(low = low[109170]))))
  }
  function chpl_build_low_bounded_range[109182](arg low[109184]:_any[141](?)) : _unknown[42] "no return value for void"
  {
    (109194 call compilerError(109195 call +(109197 call + "Ranges defined using bounds of type '"(109200 call :(109203 'typeof' low[109184]) string[244])) "' are not currently supported"))
  }
  where {
    (109186 call !(109189 call chpl_isValidRangeIdxType(109191 'typeof' low[109184])))
  }
  function chpl_build_high_bounded_range[109209](arg high[109212] :
  integral[159](?)) : _unknown[42]
  {
    (109216 return(109217 'new'(109219 call range[240](?)(high = high[109212]))))
  }
  function chpl_build_high_bounded_range[109224](arg high[109227] :
  enum[147](?)) : _unknown[42]
  {
    (109231 return(109232 'new'(109234 call range[240](?)(high = high[109227]))))
  }
  function chpl_build_high_bounded_range[109239](arg high[109242] :
  bool[19]) : _unknown[42]
  {
    (109246 return(109247 'new'(109249 call range[240](?)(high = high[109242]))))
  }
  function chpl_build_high_bounded_range[109254](arg high[109256]:_any[141](?)) : _unknown[42] "no return value for void"
  {
    (109266 call compilerError(109267 call +(109269 call + "Ranges defined using bounds of type '"(109272 call :(109275 'typeof' high[109256]) string[244])) "' are not currently supported"))
  }
  where {
    (109258 call !(109261 call chpl_isValidRangeIdxType(109263 'typeof' high[109256])))
  }
  function chpl_build_unbounded_range[109281]() : _unknown[42]
  {
    (109284 return(109285 'new'(109287 call range[240](?))))
  }
  function range[240](?).createWithSingleElement[109290](arg _mt[109300]:_MT[201], arg this[109293]:range[240](?) :
  range[240](?), arg elm[109297] :
  (426124 call . this[109293] c"idxType")) : _unknown[42] "method"
  {
    (109303 return(109304 call chpl_by(109308 call chpl_build_bounded_range elm[109297] elm[109297])(109314 call(109311 call .(401280 call . this[109293] c"strides") c"defaultStride"))))
  }
  function chpl_compute_low_param_loop_bound[109317](param arg low[109320] :
  integral[159](?), param arg high[109324] :
  integral[159](?)) param : _unknown[42]
  {
    unknown t[109329] "type variable"(109331 call computeParamRangeIndexType low[109320] high[109324])
    (109335 return(109336 call : low[109320] t[109329]))
  }
  function chpl_compute_high_param_loop_bound[109342](param arg low[109345] :
  integral[159](?), param arg high[109349] :
  integral[159](?)) param : _unknown[42]
  {
    unknown t[109354] "type variable"(109356 call computeParamRangeIndexType low[109345] high[109349])
    (109360 return(109361 call : high[109349] t[109354]))
  }
  function chpl_compute_low_param_loop_bound[109367](param arg low[109370] :
  enum[147](?), param arg high[109375] :
  (109374 'typeof' low[109370])) param : _unknown[42]
  {
    (109379 return low[109370])
  }
  function chpl_compute_high_param_loop_bound[109383](param arg low[109386] :
  enum[147](?), param arg high[109391] :
  (109390 'typeof' low[109386])) param : _unknown[42]
  {
    (109395 return high[109391])
  }
  function chpl_compute_low_param_loop_bound[109399](param arg low[109402] :
  bool[19], param arg high[109406] :
  bool[19]) param : _unknown[42]
  {
    (109410 return low[109402])
  }
  function chpl_compute_high_param_loop_bound[109414](param arg low[109417] :
  bool[19], param arg high[109421] :
  bool[19]) param : _unknown[42]
  {
    (109425 return high[109421])
  }
  function chpl_compute_low_param_loop_bound[109429](param arg low[109431]:_any[141](?), param arg high[109433]:_any[141](?)) param : _unknown[42] "no return value for void"
  {
    if(109494 call _cond_test(109488 call ==(109491 'typeof' low[109431])(109493 'typeof' high[109433])))
    {
      (109449 call compilerError(109450 call +(109452 call + "param for-loops defined using bounds of type '"(109457 call :(109460 'typeof' low[109431]) string[244])) "' are not currently supported"))
    }
    {
      (109465 call compilerError(109466 call +(109468 call +(109470 call +(109472 call + "param for-loops defined using bounds of type '"(109475 call :(109478 'typeof' low[109431]) string[244])) "..")(109481 call :(109484 'typeof' high[109433]) string[244])) "' are not currently supported"))
    }
  }
  where {
    (109435 call !(109437 call &&(109440 call chpl_isValidRangeIdxType(109442 'typeof' low[109431]))(109444 call chpl_isValidRangeIdxType(109446 'typeof' high[109433]))))
  }
  function chpl_compute_low_param_loop_bound[109503](arg low[109505]:_any[141](?), arg high[109507]:_any[141](?)) : _unknown[42] "no return value for void"
  {
    (109511 call compilerError "param for-loops must be defined over a bounded param range")
  }
  function chpl_compute_count_param_loop[109517](param arg count[109520] :
  integral[159](?)) param : _unknown[42]
  {
    (109524 return count[109520])
  }
  function chpl_compute_count_param_loop[109528](arg count[109530]:_any[141](?)) : _unknown[42] "no return value for void"
  {
    (109534 call compilerError "in a param for-loop, the count operator requires a param integral value")
  }
  function chpl_low_bound_count_for_param_loop[109540](param arg high[109543] :
  integral[159](?), param arg count[109547] :
  integral[159](?)) param : _unknown[42]
  {
    if(109584 call _cond_test(109580 call > count[109547] 0))
    {
      (109553 call compilerError "count operators with positive count require the range to have a low bound")
    }
    {
      if(109576 call _cond_test(109572 call == count[109547] 0))
      {
        (109558 return(109559 call + high[109543] 1))
      }
      {
        (109564 return(109565 call +(109567 call + high[109543] count[109547]) 1))
      }
    }
  }
  function chpl_low_bound_count_for_param_loop[109591](arg high[109593]:_any[141](?), arg count[109595]:_any[141](?)) : _unknown[42] "last resort" "no return value for void"
  {
    (109599 call chpl_build_high_bounded_range high[109593])
    (109602 call compilerError "can't apply '#' to a range with idxType "(109606 call :(109609 'typeof' high[109593]) string[244]) " using a count of type "(109614 call :(109617 'typeof' count[109595]) string[244]))
  }
  function chpl_high_bound_count_for_param_loop[109621](param arg low[109624] :
  integral[159](?), param arg count[109628] :
  integral[159](?)) param : _unknown[42]
  {
    if(109665 call _cond_test(109661 call < count[109628] 0))
    {
      (109634 call compilerError "count operators with negative count require the range to have a high bound")
    }
    {
      if(109657 call _cond_test(109653 call == count[109628] 0))
      {
        (109639 return(109640 call - low[109624] 1))
      }
      {
        (109645 return(109646 call -(109648 call + low[109624] count[109628]) 1))
      }
    }
  }
  function chpl_high_bound_count_for_param_loop[109672](arg low[109674]:_any[141](?), arg count[109676]:_any[141](?)) : _unknown[42] "last resort" "no return value for void"
  {
    (109680 call chpl_build_low_bounded_range low[109674])
    (109683 call compilerError "can't apply '#' to a range with idxType "(109685 call :(109688 'typeof' low[109674]) string[244]) " using a count of type "(109691 call :(109694 'typeof' count[109676]) string[244]))
  }
  function chpl_bounded_count_for_param_loop_low[109698](param arg low[109701] :
  integral[159](?), param arg high[109705] :
  integral[159](?), param arg count[109709] :
  integral[159](?)) param : _unknown[42]
  {
    unknown abs_count[109714] "param"(109723 IfExpr (109715 call < count[109709] 0) then
    { scopeless
      (109719 call - count[109709])
    } else
    { scopeless
      count[109709]
    } )
    (109727 'end of statement')
    unknown size[109729] "param"(109730 call +(109732 call - high[109705] low[109701]) 1)
    (109738 'end of statement')
    if(109795 call _cond_test(109791 call < size[109729] abs_count[109714]))
    {
      (109741 call compilerError "Count of "(109745 call : abs_count[109714] string[244]) " is too small for range of size "(109752 call : size[109729] string[244]))
    }
    {
      if(109786 call _cond_test(109782 call == count[109709] 0))
      {
        (109757 return(109758 call + high[109705] 1))
      }
      {
        if(109778 call _cond_test(109774 call < count[109709] 0))
        {
          (109763 return(109764 call +(109766 call + high[109705] count[109709]) 1))
        }
        {
          (109772 return low[109701])
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_low[109802](arg low[109804]:_any[141](?), arg high[109806]:_any[141](?), arg count[109808]:_any[141](?)) : _unknown[42] "last resort" "no return value for void"
  {
    const r[109812] "const"(109814 call chpl_build_bounded_range low[109804] high[109806])
    (109818 'end of statement')
    (109820 call compilerError "can't apply '#' to a range with idxType "(109822 call :(109825 call . r[109812] c"idxType") string[244]) " using a count of type "(109830 call :(109833 'typeof' count[109808]) string[244]))
  }
  function chpl_bounded_count_for_param_loop_high[109837](param arg low[109840] :
  integral[159](?), param arg high[109844] :
  integral[159](?), param arg count[109848] :
  integral[159](?)) param : _unknown[42]
  {
    if(109882 call _cond_test(109878 call == count[109848] 0))
    {
      (109853 return(109854 call - low[109840] 1))
    }
    {
      if(109874 call _cond_test(109870 call < count[109848] 0))
      {
        (109859 return high[109844])
      }
      {
        (109862 return(109863 call -(109865 call + low[109840] count[109848]) 1))
      }
    }
  }
  function chpl_bounded_count_for_param_loop_high[109889](arg low[109891]:_any[141](?), arg high[109893]:_any[141](?), arg count[109895]:_any[141](?)) : _unknown[42] "last resort" "no return value for void"
  {
    const r[109899] "const"(109901 call chpl_build_bounded_range low[109891] high[109893])
    (109905 'end of statement')
    (109907 call compilerError "can't apply '#' to a range with idxType "(109909 call :(109912 call . r[109899] c"idxType") string[244]) " using a count of type "(109917 call :(109920 'typeof' count[109895]) string[244]))
  }
  function range[240](?).stride[109924](arg _mt[109930]:_MT[201], arg this[109927]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no where doc" "no parens"
  {
    (109937 return(426221 call . this[109927] c"_stride"))
  }
  where {
    (109932 call !(109935 call(426216 call . this[109927] c"hasParamStride")))
  }
  function range[240](?).stride[109942](arg _mt[109948]:_MT[201], arg this[109945]:range[240](?) :
  range[240](?)) param : _unknown[42] "method" "no parens"
  {
    (109953 return(109954 call :(109967 IfExpr (109956 call ==(426230 call . this[109945] c"strides") one[107127]) then
    { scopeless
      1
    } else
    { scopeless
      (109964 call - 1)
    } )(426234 call . this[109945] c"strType")))
  }
  where {
    (109951 call(426225 call . this[109945] c"hasParamStride"))
  }
  function range[240](?).alignment[109974](arg _mt[109980]:_MT[201], arg this[109977]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no where doc" "no parens"
  {
    (109987 return(109989 call(426246 call . this[109977] c"chpl_intToIdx")(109994 IfExpr (109991 call(426250 call . this[109977] c"hasParamAlignmentField")) then
    { scopeless
      0
    } else
    { scopeless
      (426255 call . this[109977] c"_alignment")
    } )))
  }
  where {
    (109982 call !(109985 call(426240 call . this[109977] c"hasParamAlignment")))
  }
  function range[240](?).alignment[110000](arg _mt[110006]:_MT[201], arg this[110003]:range[240](?) :
  range[240](?)) param : _unknown[42] "method" "no parens"
  {
    (110011 return(110023 IfExpr (110013 call isEnum(426264 call . this[110003] c"idxType")) then
    { scopeless
      (110016 call chpl__orderToEnum 0(426269 call . this[110003] c"idxType"))
    } else
    { scopeless
      (110019 call : 0(426274 call . this[110003] c"idxType"))
    } ))
  }
  where {
    (110009 call(426259 call . this[110003] c"hasParamAlignment"))
  }
  function range[240](?).isAligned[110029](arg _mt[110035]:_MT[201], arg this[110032]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no where doc"
  {
    (110042 return(110043 call !=(426285 call . this[110032] c"_alignment") unalignedMark[107107]))
  }
  where {
    (110037 call !(110040 call(426280 call . this[110032] c"hasParamAligned")))
  }
  function range[240](?).isAligned[110050](arg _mt[110056]:_MT[201], arg this[110053]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110061 return 1)
  }
  where {
    (110059 call(426290 call . this[110053] c"hasParamAligned"))
  }
  function range[240](?).hasParamStride[110066](arg _mt[110072]:_MT[201], arg this[110069]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110075 return(110077 call(426294 call . this[110069] c"hasPosNegUnitStride")))
  }
  function range[240](?).hasParamAlignmentField[110080](arg _mt[110086]:_MT[201], arg this[110083]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110089 return(110091 call(426298 call . this[110083] c"hasPosNegUnitStride")))
  }
  function range[240](?).hasParamAlignment[110094](arg _mt[110100]:_MT[201], arg this[110097]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110103 return(110104 call &&(110107 call(426302 call . this[110097] c"hasParamAlignmentField"))(110108 call ||(110110 call ||(110113 call isIntegral(426307 call . this[110097] c"idxType"))(110116 call isEnum(426312 call . this[110097] c"idxType")))(110119 call isBool(426317 call . this[110097] c"idxType")))))
  }
  function range[240](?).hasParamAligned[110123](arg _mt[110129]:_MT[201], arg this[110126]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110132 return(110134 call(426321 call . this[110126] c"hasPosNegUnitStride")))
  }
  function range[240](?).hasParamStrideAltvalAld[110137](arg _mt[110143]:_MT[201], arg this[110140]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110146 return(110148 call(426325 call . this[110140] c"hasPosNegUnitStride")))
  }
  function range[240](?).hasParamStrideAltvalAld[110151](arg _mt[110157]:_MT[201], arg this[110154]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    unknown r[110161] this[110154]
    (110164 'end of statement')
    (110165 return(110172 call(110169 call . r[110161] c"hasParamStrideAltvalAld")))
  }
  function range[240](?).hasLowBound[110175](arg _mt[110181]:_MT[201], arg this[110178]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110184 return(110185 call ||(110187 call ==(426331 call . this[110178] c"bounds") both[107114])(110194 call ==(426336 call . this[110178] c"bounds") low[107116])))
  }
  function range[240](?).lowBound[110203](arg _mt[110209]:_MT[201], arg this[110206]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(110223 call _cond_test(110219 call !(110222 call(426345 call . this[110206] c"hasLowBound"))))
    {
      (110215 call compilerError "can't query the low bound of a range without one")
    }
    (110227 return(110229 call(426349 call . this[110206] c"chpl_intToIdx")(426354 call . this[110206] c"_low")))
  }
  { scopeless type
    (426341 call . this[110206] c"idxType")
  }
  function range[240](?).hasUnitStride[110234](arg _mt[110240]:_MT[201], arg this[110237]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110243 return(110250 call(110247 call .(401291 call . this[110237] c"strides") c"isOne")))
  }
  function range[240](?).hasPosNegUnitStride[110253](arg _mt[110259]:_MT[201], arg this[110256]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110262 return(110267 call(110264 call .(401296 call . this[110256] c"strides") c"isPosNegOne")))
  }
  function range[240](?).hasPositiveStride[110270](arg _mt[110276]:_MT[201], arg this[110273]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110286 return(110291 call(110288 call .(401306 call . this[110273] c"strides") c"isPositive")))
  }
  where {
    (110284 call(110281 call .(401301 call . this[110273] c"strides") c"hasSign"))
  }
  function range[240](?).hasPositiveStride[110295](arg _mt[110301]:_MT[201], arg this[110298]:range[240](?) :
  range[240](?)) : _unknown[42] "method"
  {
    (110311 return(110312 call >(426359 call . this[110298] c"_stride") 0))
  }
  where {
    (110309 call(110306 call .(401311 call . this[110298] c"strides") c"isAny"))
  }
  function range[240](?).hasNegativeStride[110319](arg _mt[110325]:_MT[201], arg this[110322]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (110333 return(110340 call(110337 call .(401321 call . this[110322] c"strides") c"isNegative")))
  }
  where {
    (110331 call(110328 call .(401316 call . this[110322] c"strides") c"hasSign"))
  }
  function range[240](?).hasNegativeStride[110344](arg _mt[110350]:_MT[201], arg this[110347]:range[240](?) :
  range[240](?)) : _unknown[42] "method"
  {
    (110358 return(110359 call <(426364 call . this[110347] c"_stride") 0))
  }
  where {
    (110356 call(110353 call .(401326 call . this[110347] c"strides") c"isAny"))
  }
  function strideKind[107137].isOne[110366](arg _mt[110372]:_MT[201], param arg this[110369]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110375 return(110376 call == this[110369] one[107127]))
  }
  function strideKind[107137].isNegOne[110385](arg _mt[110391]:_MT[201], param arg this[110388]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110394 return(110395 call == this[110388] negOne[107129]))
  }
  function strideKind[107137].isPosNegOne[110406](arg _mt[110412]:_MT[201], param arg this[110409]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110415 return(110416 call ||(110418 call == this[110409] one[107127])(110425 call == this[110409] negOne[107129])))
  }
  function strideKind[107137].isPositive[110434](arg _mt[110440]:_MT[201], param arg this[110437]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110443 return(110444 call ||(110446 call == this[110437] one[107127])(110453 call == this[110437] positive[107131])))
  }
  function strideKind[107137].isNegative[110464](arg _mt[110470]:_MT[201], param arg this[110467]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110473 return(110474 call ||(110476 call == this[110467] negOne[107129])(110483 call == this[110467] negative[107133])))
  }
  function strideKind[107137].hasSign[110494](arg _mt[110500]:_MT[201], param arg this[110497]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110503 return(110504 call != this[110497] any[107135]))
  }
  function strideKind[107137].isAny[110515](arg _mt[110521]:_MT[201], param arg this[110518]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110524 return(110525 call == this[110518] any[107135]))
  }
  function strideKind[107137].defaultStride[110534](arg _mt[110540]:_MT[201], param arg this[110537]:strideKind[107137] :
  strideKind[107137]) param : _unknown[42] "method"
  {
    (110543 return(110550 IfExpr (110545 call(426378 call . this[110537] c"isNegative")) then
    { scopeless
      (110546 call - 1)
    } else
    { scopeless
      1
    } ))
  }
  function isPositiveStride[110555](param arg strides[110558] :
  strideKind[107137], arg stride[110561]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (110569 return(110570 call > stride[110561] 0))
  }
  where {
    (110567 call(110564 call . strides[110558] c"isAny"))
  }
  function isPositiveStride[110577](param arg strides[110580] :
  strideKind[107137], param arg stride[110583]:_any[141](?)) param : _unknown[42] "private"
  {
    (110591 return(110592 call > stride[110583] 0))
  }
  where {
    (110589 call(110586 call . strides[110580] c"isAny"))
  }
  function isPositiveStride[110599](param arg strides[110602] :
  strideKind[107137], arg stride[110605]:_any[141](?)) param : _unknown[42] "private"
  {
    (110613 return(110618 call(110615 call . strides[110602] c"isPositive")))
  }
  where {
    (110611 call(110608 call . strides[110602] c"hasSign"))
  }
  function isNegativeStride[110622](param arg strides[110625] :
  strideKind[107137], arg stride[110628]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (110636 return(110637 call < stride[110628] 0))
  }
  where {
    (110634 call(110631 call . strides[110625] c"isAny"))
  }
  function isNegativeStride[110644](param arg strides[110647] :
  strideKind[107137], param arg stride[110650]:_any[141](?)) param : _unknown[42] "private"
  {
    (110658 return(110659 call < stride[110650] 0))
  }
  where {
    (110656 call(110653 call . strides[110647] c"isAny"))
  }
  function isNegativeStride[110666](param arg strides[110669] :
  strideKind[107137], arg stride[110672]:_any[141](?)) param : _unknown[42] "private"
  {
    (110680 return(110685 call(110682 call . strides[110669] c"isNegative")))
  }
  where {
    (110678 call(110675 call . strides[110669] c"hasSign"))
  }
  function chpl_strideProduct[110689](param arg s1[110692] :
  strideKind[107137], param arg s2[110696] :
  strideKind[107137]) param : _unknown[42]
  {
    {
      unknown tmp[110977] "expr temp" "maybe param" "maybe type" "temp"
      (110979 'move' tmp[110977] s1[110692])
      if(110984 call _cond_test(110981 call == tmp[110977] one[107127]))
      {
        (110708 return s2[110696])
      }
      {
        if(110990 call _cond_test(110987 call == tmp[110977] positive[107131]))
        {
          unknown tmp[110759] "expr temp" "maybe param" "maybe type" "temp"
          (110761 'move' tmp[110759] s2[110696])
          if(110766 call _cond_test(110763 call == tmp[110759] one[107127]))
          {
            (110721 return positive[107131])
          }
          {
            if(110772 call _cond_test(110769 call == tmp[110759] positive[107131]))
            {
              (110729 return positive[107131])
            }
            {
              if(110779 call _cond_test(110776 call == tmp[110759] negOne[107129]))
              {
                (110737 return negative[107133])
              }
              {
                if(110786 call _cond_test(110783 call == tmp[110759] negative[107133]))
                {
                  (110745 return negative[107133])
                }
                {
                  if(110793 call _cond_test(110790 call == tmp[110759] any[107135]))
                  {
                    (110753 return any[107135])
                  }
                }
              }
            }
          }
        }
        {
          if(110997 call _cond_test(110994 call == tmp[110977] negOne[107129]))
          {
            unknown tmp[110844] "expr temp" "maybe param" "maybe type" "temp"
            (110846 'move' tmp[110844] s2[110696])
            if(110851 call _cond_test(110848 call == tmp[110844] one[107127]))
            {
              (110806 return negOne[107129])
            }
            {
              if(110857 call _cond_test(110854 call == tmp[110844] positive[107131]))
              {
                (110814 return negative[107133])
              }
              {
                if(110864 call _cond_test(110861 call == tmp[110844] negOne[107129]))
                {
                  (110822 return one[107127])
                }
                {
                  if(110871 call _cond_test(110868 call == tmp[110844] negative[107133]))
                  {
                    (110830 return positive[107131])
                  }
                  {
                    if(110878 call _cond_test(110875 call == tmp[110844] any[107135]))
                    {
                      (110838 return any[107135])
                    }
                  }
                }
              }
            }
          }
          {
            if(111004 call _cond_test(111001 call == tmp[110977] negative[107133]))
            {
              unknown tmp[110929] "expr temp" "maybe param" "maybe type" "temp"
              (110931 'move' tmp[110929] s2[110696])
              if(110936 call _cond_test(110933 call == tmp[110929] one[107127]))
              {
                (110891 return negative[107133])
              }
              {
                if(110942 call _cond_test(110939 call == tmp[110929] positive[107131]))
                {
                  (110899 return negative[107133])
                }
                {
                  if(110949 call _cond_test(110946 call == tmp[110929] negOne[107129]))
                  {
                    (110907 return positive[107131])
                  }
                  {
                    if(110956 call _cond_test(110953 call == tmp[110929] negative[107133]))
                    {
                      (110915 return positive[107131])
                    }
                    {
                      if(110963 call _cond_test(110960 call == tmp[110929] any[107135]))
                      {
                        (110923 return any[107135])
                      }
                    }
                  }
                }
              }
            }
            {
              if(111011 call _cond_test(111008 call == tmp[110977] any[107135]))
              {
                (110971 return any[107135])
              }
            }
          }
        }
      }
    }
    (396125 'used modules list'(110701 'use' strideKind[107137]))
  }
  function chpl_strideProduct[111017](arg r1[111022] :
  (111020 call range[240](?) ?[227]), arg r2[111028] :
  (111026 call range[240](?) ?[227])) param : _unknown[42]
  {
    (111032 return(111034 call chpl_strideProduct(111036 call . r1[111022] c"strides")(111040 call . r2[111028] c"strides")))
  }
  function chpl_strideProduct[111045](arg r1[111050] :
  (111048 call range[240](?) ?[227]), param arg stride2[111054] :
  integral[159](?)) param : _unknown[42]
  {
    unknown s2[111062] "param"(111087 IfExpr (111063 call == stride2[111054] 1) then
    { scopeless
      one[107127]
    } else
    { scopeless(111084 IfExpr (111068 call == stride2[111054](111071 call - 1)) then
      { scopeless
        negOne[107129]
      } else
      { scopeless(111081 IfExpr (111075 call > stride2[111054] 0) then
        { scopeless
          positive[107131]
        } else
        { scopeless
          negative[107133]
        } )
      } )
    } )
    (111091 'end of statement')
    (111092 return(111094 call chpl_strideProduct(111096 call . r1[111050] c"strides") s2[111062]))
    (396127 'used modules list'(111059 'use' strideKind[107137]))
  }
  function chpl_strideUnion[111102](param arg s1[111105] :
  strideKind[107137], param arg s2[111109] :
  strideKind[107137]) param : _unknown[42]
  {
    {
      unknown tmp[111467] "expr temp" "maybe param" "maybe type" "temp"
      (111469 'move' tmp[111467] s1[111105])
      if(111474 call _cond_test(111471 call == tmp[111467] one[107127]))
      {
        unknown tmp[111164] "expr temp" "maybe param" "maybe type" "temp"
        (111166 'move' tmp[111164] s2[111109])
        if(111171 call _cond_test(111168 call == tmp[111164] one[107127]))
        {
          (111126 return one[107127])
        }
        {
          if(111177 call _cond_test(111174 call == tmp[111164] positive[107131]))
          {
            (111134 return positive[107131])
          }
          {
            if(111184 call _cond_test(111181 call == tmp[111164] negOne[107129]))
            {
              (111142 return any[107135])
            }
            {
              if(111191 call _cond_test(111188 call == tmp[111164] negative[107133]))
              {
                (111150 return any[107135])
              }
              {
                if(111198 call _cond_test(111195 call == tmp[111164] any[107135]))
                {
                  (111158 return any[107135])
                }
              }
            }
          }
        }
      }
      {
        if(111480 call _cond_test(111477 call == tmp[111467] negOne[107129]))
        {
          unknown tmp[111249] "expr temp" "maybe param" "maybe type" "temp"
          (111251 'move' tmp[111249] s2[111109])
          if(111256 call _cond_test(111253 call == tmp[111249] one[107127]))
          {
            (111211 return any[107135])
          }
          {
            if(111262 call _cond_test(111259 call == tmp[111249] positive[107131]))
            {
              (111219 return any[107135])
            }
            {
              if(111269 call _cond_test(111266 call == tmp[111249] negOne[107129]))
              {
                (111227 return negOne[107129])
              }
              {
                if(111276 call _cond_test(111273 call == tmp[111249] negative[107133]))
                {
                  (111235 return negative[107133])
                }
                {
                  if(111283 call _cond_test(111280 call == tmp[111249] any[107135]))
                  {
                    (111243 return any[107135])
                  }
                }
              }
            }
          }
        }
        {
          if(111487 call _cond_test(111484 call == tmp[111467] positive[107131]))
          {
            unknown tmp[111334] "expr temp" "maybe param" "maybe type" "temp"
            (111336 'move' tmp[111334] s2[111109])
            if(111341 call _cond_test(111338 call == tmp[111334] one[107127]))
            {
              (111296 return positive[107131])
            }
            {
              if(111347 call _cond_test(111344 call == tmp[111334] positive[107131]))
              {
                (111304 return positive[107131])
              }
              {
                if(111354 call _cond_test(111351 call == tmp[111334] negOne[107129]))
                {
                  (111312 return any[107135])
                }
                {
                  if(111361 call _cond_test(111358 call == tmp[111334] negative[107133]))
                  {
                    (111320 return any[107135])
                  }
                  {
                    if(111368 call _cond_test(111365 call == tmp[111334] any[107135]))
                    {
                      (111328 return any[107135])
                    }
                  }
                }
              }
            }
          }
          {
            if(111494 call _cond_test(111491 call == tmp[111467] negative[107133]))
            {
              unknown tmp[111419] "expr temp" "maybe param" "maybe type" "temp"
              (111421 'move' tmp[111419] s2[111109])
              if(111426 call _cond_test(111423 call == tmp[111419] one[107127]))
              {
                (111381 return any[107135])
              }
              {
                if(111432 call _cond_test(111429 call == tmp[111419] positive[107131]))
                {
                  (111389 return any[107135])
                }
                {
                  if(111439 call _cond_test(111436 call == tmp[111419] negOne[107129]))
                  {
                    (111397 return negative[107133])
                  }
                  {
                    if(111446 call _cond_test(111443 call == tmp[111419] negative[107133]))
                    {
                      (111405 return negative[107133])
                    }
                    {
                      if(111453 call _cond_test(111450 call == tmp[111419] any[107135]))
                      {
                        (111413 return any[107135])
                      }
                    }
                  }
                }
              }
            }
            {
              if(111501 call _cond_test(111498 call == tmp[111467] any[107135]))
              {
                (111461 return any[107135])
              }
            }
          }
        }
      }
    }
    (396129 'used modules list'(111114 'use' strideKind[107137]))
  }
  function chpl_strideUnion[111507](arg args[111510] :
  _tuple[246](?)) param : _unknown[42]
  {
    (111514 return(111516 call chpl_strideUnion(111518 'expand_tuple' args[111510])))
  }
  function chpl_strideUnion[111521](arg arg[111523]:_any[141](?), arg args[111526]:_any[141](?) ...) param : _unknown[42]
  {
    (111530 return(111532 call chpl_strideUnion(111534 call chpl_strideUnion arg[111523])(111537 call chpl_strideUnion(111539 'expand_tuple' args[111526]))))
  }
  function chpl_strideUnion[111542](arg arg[111544]:_any[141](?)) param : _unknown[42]
  {
    (111548 return(111550 call . arg[111544] c"strides"))
  }
  { scopeless type
    strideKind[107137]
  }
  function chpl_strideUnionRC[111556](arg args[111559] :
  _tuple[246](?)) param : _unknown[42]
  {
    (111563 return(111565 call chpl_strideUnionRC(111567 'expand_tuple' args[111559])))
  }
  function chpl_strideUnionRC[111570](arg arg[111572]:_any[141](?), arg args[111575]:_any[141](?) ...) param : _unknown[42]
  {
    (111579 return(111581 call chpl_strideUnion(111583 call chpl_strideUnionRC arg[111572])(111586 call chpl_strideUnionRC(111588 'expand_tuple' args[111575]))))
  }
  function chpl_strideUnionRC[111591](arg arg[111593]:_any[141](?)) param : _unknown[42]
  {
    (111596 return(111608 IfExpr (111598 call isRange arg[111593]) then
    { scopeless
      (111601 call . arg[111593] c"strides")
    } else
    { scopeless
      one[107127]
    } ))
  }
  function chpl_assignStrideIsSafe[111613](param arg lhs[111616] :
  strideKind[107137], param arg rhs[111620] :
  strideKind[107137]) param : _unknown[42]
  {
    {
      unknown tmp[111700] "expr temp" "maybe param" "maybe type" "temp"
      (111702 'move' tmp[111700] lhs[111616])
      if(111707 call _cond_test(111704 call == tmp[111700] one[107127]))
      {
        (111632 return(111637 call(111634 call . rhs[111620] c"isOne")))
      }
      {
        if(111713 call _cond_test(111710 call == tmp[111700] positive[107131]))
        {
          (111647 return(111652 call(111649 call . rhs[111620] c"isPositive")))
        }
        {
          if(111720 call _cond_test(111717 call == tmp[111700] negOne[107129]))
          {
            (111662 return(111669 call(111666 call . rhs[111620] c"isNegOne")))
          }
          {
            if(111727 call _cond_test(111724 call == tmp[111700] negative[107133]))
            {
              (111679 return(111684 call(111681 call . rhs[111620] c"isNegative")))
            }
            {
              if(111734 call _cond_test(111731 call == tmp[111700] any[107135]))
              {
                (111694 return 1)
              }
            }
          }
        }
      }
    }
  }
  function chpl_assignStrideIsSafe[111740](arg lhs[111745] :
  (111743 call range[240](?) ?[227]), arg rhs[111751] :
  (111749 call range[240](?) ?[227])) param : _unknown[42]
  {
    (111755 return(111757 call chpl_assignStrideIsSafe(111759 call . lhs[111745] c"strides")(111763 call . rhs[111751] c"strides")))
  }
  function chpl_assignStrideIsSafe[111768](param arg lhs[111771] :
  strideKind[107137], param arg rhs[111775] :
  strideKind[107137], arg rhsStride[111778]:_any[141](?)) param : _unknown[42]
  {
    (111799 return 1)
  }
  where {
    (111780 call ||(111783 call chpl_assignStrideIsSafe lhs[111771] rhs[111775])(111786 call &&(111788 call == lhs[111771] positive[107131])(111796 call isUint rhsStride[111778])))
  }
  function chpl_assignStrideIsSafe[111804](param arg lhs[111807] :
  strideKind[107137], param arg rhs[111811] :
  strideKind[107137], arg rhsStride[111814]:_any[141](?)) : _unknown[42]
  {
    {
      unknown tmp[111892] "expr temp" "maybe param" "maybe type" "temp"
      (111894 'move' tmp[111892] lhs[111807])
      if(111899 call _cond_test(111896 call == tmp[111892] one[107127]))
      {
        (111825 return(111826 call == rhsStride[111814] 1))
      }
      {
        if(111905 call _cond_test(111902 call == tmp[111892] positive[107131]))
        {
          (111839 return(111840 call > rhsStride[111814] 0))
        }
        {
          if(111912 call _cond_test(111909 call == tmp[111892] negOne[107129]))
          {
            (111853 return(111854 call == rhsStride[111814](111857 call - 1)))
          }
          {
            if(111919 call _cond_test(111916 call == tmp[111892] negative[107133]))
            {
              (111869 return(111870 call < rhsStride[111814] 0))
            }
            {
              if(111926 call _cond_test(111923 call == tmp[111892] any[107135]))
              {
                (111884 call compilerError "internal error")
              }
            }
          }
        }
      }
    }
  }
  function chpl_assignStrideIsUnsafe[111932](param arg lhs[111935] :
  strideKind[107137], param arg rhs[111939] :
  strideKind[107137]) param : _unknown[42]
  {
    (111943 return(111944 call ||(111946 call &&(111952 call(111949 call . lhs[111935] c"isPositive"))(111957 call(111954 call . rhs[111939] c"isNegative")))(111958 call &&(111964 call(111961 call . lhs[111935] c"isNegative"))(111969 call(111966 call . rhs[111939] c"isPositive")))))
  }
  function assignmentIsLegal[111972](arg to[111974]:_any[141](?), arg from[111976]:_any[141](?)) param : _unknown[42] "private"
  {
    if(111986 call _cond_test(111982 call == to[111974] from[111976]))
    {
      (111979 return 1)
    }
    unknown toVar[111997] to[111974]
    unknown fromVar[111993] from[111976]
    (112000 'end of statement')
    (112001 return(112003 call canResolve "=" toVar[111997] fromVar[111993]))
  }
  function verifyAppropriateStride[112011](param arg strides[112013]:_any[141](?), arg stride[112015]:_any[141](?)) : _unknown[42] "private" "no return value for void"
  {
    if(112030 call _cond_test(112029 call(112026 call . strides[112013] c"isPositive")))
    {
      (112019 call assert(112020 call > stride[112015] 0))
    }
    if(112047 call _cond_test(112046 call(112043 call . strides[112013] c"isNegative")))
    {
      (112036 call assert(112037 call < stride[112015] 0))
    }
  }
  function range[240](?).chpl_setFields[112054](arg _mt[112066]:_MT[201], ref arg this[112057]:range[240](?) :
  range[240](?), arg low[112060]:_any[141](?), arg high[112062]:_any[141](?), arg stride[112064]:_any[141](?)) : _unknown[42] "inline" "method" "no return value for void"
  {
    (112069 call =(112072 call . this[112057] c"_low")(112075 call :(112078 call chpl__idxToInt low[112060])(112081 call . this[112057] c"chpl_integralIdxType")))
    (112084 call =(112087 call . this[112057] c"_high")(112090 call :(112093 call chpl__idxToInt high[112062])(112096 call . this[112057] c"chpl_integralIdxType")))
    if(112183 call _cond_test(112182 call(112179 call . this[112057] c"hasParamStrideAltvalAld")))
    {
      if(112109 call _cond_test 1)
      {
        (112101 call verifyAppropriateStride(112103 call . this[112057] c"strides") stride[112064])
      }
    }
    {
      (112115 call =(112118 call . this[112057] c"_stride")(112121 call : stride[112064](112127 call . this[112057] c"strType")))
      const first[112131] "const"(112141 IfExpr (112138 call(112135 call . this[112057] c"hasPositiveStride")) then
      { scopeless
        low[112060]
      } else
      { scopeless
        high[112062]
      } )
      (112145 'end of statement')
      (112146 call =(112149 call . this[112057] c"_alignment")(112152 call :(112155 call chpl__mod(112157 call chpl__idxToInt first[112131]) stride[112064])(112161 call . this[112057] c"strType")))
      if(112173 call _cond_test 1)
      {
        (112165 call assert(112170 call(112167 call . this[112057] c"isAligned")))
      }
    }
  }
  function range[240](?).chpl_setFields[112189](arg _mt[112199]:_MT[201], ref arg this[112192]:range[240](?) :
  range[240](?), arg low[112195]:_any[141](?), arg high[112197]:_any[141](?)) : _unknown[42] "inline" "method" "no return value for void"
  {
    (112203 call compilerAssert(112210 call(112207 call . this[112192] c"hasParamStride")))
    (112211 call =(112214 call . this[112192] c"_low")(112217 call :(112220 call chpl__idxToInt low[112195])(112223 call . this[112192] c"chpl_integralIdxType")))
    (112226 call =(112229 call . this[112192] c"_high")(112232 call :(112235 call chpl__idxToInt high[112197])(112238 call . this[112192] c"chpl_integralIdxType")))
  }
  function range[240](?).low[112243](arg _mt[112249]:_MT[201], arg this[112246]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112261 call _cond_test(112257 call !(112260 call(426555 call . this[112246] c"hasLowBound"))))
    {
      (112255 call compilerError "can't query the low bound of a range without one")
    }
    (112265 return(112267 call(426559 call . this[112246] c"chpl_intToIdx")(112271 call . this[112246] c"alignedLowAsInt")))
  }
  { scopeless type
    (426551 call . this[112246] c"idxType")
  }
  function range[240](?).alignedLowAsInt[112277](arg _mt[112283]:_MT[201], arg this[112280]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112296 call _cond_test(112292 call !(112295 call(426563 call . this[112280] c"isAligned"))))
    {
      (112287 call halt "Can't query the aligned bounds of an ambiguously aligned range")
    }
    if(112318 call _cond_test(112317 call(112314 call . this[112280] c"hasPosNegUnitStride")))
    {
      (112301 return(426568 call . this[112280] c"_low"))
    }
    {
      (112304 return(112306 call helpAlignLow(426573 call . this[112280] c"_low")(426578 call . this[112280] c"_alignment")(426582 call . this[112280] c"stride")))
    }
  }
  function range[240](?).chpl_alignedLowAsIntForIter[112326](arg _mt[112332]:_MT[201], arg this[112329]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112364 call _cond_test(112349 call &&(112351 call &&(112353 call !(112356 call(426600 call . this[112329] c"hasUnitStride")))(112357 call !(112360 call(426604 call . this[112329] c"hasLowBound"))))(112362 call isFiniteIdxType(426609 call . this[112329] c"idxType"))))
    {
      (112336 return(112338 call helpAlignLow(112340 call chpl__idxToInt(112342 call lowBoundForIter this[112329]))(426588 call . this[112329] c"_alignment")(426592 call . this[112329] c"stride")))
    }
    {
      (112347 return(426596 call . this[112329] c"alignedLowAsInt"))
    }
  }
  function helpAlignLow[112370](arg l[112372]:_any[141](?), arg a[112374]:_any[141](?), arg s[112376]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112379 return(112380 call + l[112372](112384 call chpl__diffMod(112385 call : a[112374](112389 'typeof' l[112372])) l[112372] s[112376])))
  }
  function range[240](?).hasHighBound[112394](arg _mt[112400]:_MT[201], arg this[112397]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (112403 return(112404 call ||(112406 call ==(426619 call . this[112397] c"bounds") both[107114])(112413 call ==(426624 call . this[112397] c"bounds") high[107118])))
  }
  function range[240](?).highBound[112422](arg _mt[112428]:_MT[201], arg this[112425]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112442 call _cond_test(112438 call !(112441 call(426633 call . this[112425] c"hasHighBound"))))
    {
      (112434 call compilerError "can't query the high bound of a range without one")
    }
    if(112468 call _cond_test(112466 call chpl__singleValIdxType(426657 call . this[112425] c"idxType")))
    {
      if(112461 call _cond_test(112457 call >(426647 call . this[112425] c"_low")(426652 call . this[112425] c"_high")))
      {
        (112449 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112453 return(112455 call(426637 call . this[112425] c"chpl_intToIdx")(426642 call . this[112425] c"_low")))
      }
    }
    (112472 return(112474 call(426661 call . this[112425] c"chpl_intToIdx")(426666 call . this[112425] c"_high")))
  }
  { scopeless type
    (426629 call . this[112425] c"idxType")
  }
  function range[240](?).high[112479](arg _mt[112485]:_MT[201], arg this[112482]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112497 call _cond_test(112493 call !(112496 call(426675 call . this[112482] c"hasHighBound"))))
    {
      (112491 call compilerError "can't query the high bound of a range without one")
    }
    if(112522 call _cond_test(112520 call chpl__singleValIdxType(426690 call . this[112482] c"idxType")))
    {
      if(112515 call _cond_test(112511 call >(426680 call . this[112482] c"_low")(426685 call . this[112482] c"_high")))
      {
        (112504 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112506 return(112508 call . this[112482] c"low"))
      }
    }
    if(112546 call _cond_test(112544 call chpl__singleValIdxType(426708 call . this[112482] c"idxType")))
    {
      if(112539 call _cond_test(112535 call ==(426703 call . this[112482] c"size") 0))
      {
        (112529 call warning "This range is empty and has a single-value idxType, so its high bound isn't trustworthy")
        (112531 return(112533 call(426694 call . this[112482] c"chpl_intToIdx")(426699 call . this[112482] c"_low")))
      }
    }
    (112550 return(112552 call(426712 call . this[112482] c"chpl_intToIdx")(112556 call . this[112482] c"alignedHighAsInt")))
  }
  { scopeless type
    (426671 call . this[112482] c"idxType")
  }
  function range[240](?).alignedHighAsInt[112562](arg _mt[112568]:_MT[201], arg this[112565]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112579 call _cond_test(112575 call !(112578 call(426716 call . this[112565] c"isAligned"))))
    {
      (112572 call halt "Can't query the aligned bounds of an ambiguously aligned range")
    }
    if(112599 call _cond_test(112598 call(112595 call . this[112565] c"hasPosNegUnitStride")))
    {
      (112584 return(426721 call . this[112565] c"_high"))
    }
    {
      (112587 return(112589 call helpAlignHigh(426726 call . this[112565] c"_high")(426731 call . this[112565] c"_alignment")(426735 call . this[112565] c"stride")))
    }
  }
  function range[240](?).chpl_alignedHighAsIntForIter[112607](arg _mt[112613]:_MT[201], arg this[112610]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(112645 call _cond_test(112630 call &&(112632 call &&(112634 call !(112637 call(426753 call . this[112610] c"hasUnitStride")))(112638 call !(112641 call(426757 call . this[112610] c"hasHighBound"))))(112643 call isFiniteIdxType(426762 call . this[112610] c"idxType"))))
    {
      (112617 return(112619 call helpAlignHigh(112621 call chpl__idxToInt(112623 call highBoundForIter this[112610]))(426741 call . this[112610] c"_alignment")(426745 call . this[112610] c"stride")))
    }
    {
      (112628 return(426749 call . this[112610] c"alignedHighAsInt"))
    }
  }
  function helpAlignHigh[112651](arg h[112653]:_any[141](?), arg a[112655]:_any[141](?), arg s[112657]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112660 return(112661 call - h[112653](112665 call chpl__diffMod h[112653](112667 call : a[112655](112671 'typeof' h[112653])) s[112657])))
  }
  function range[240](?).chpl_isNaturallyAligned[112675](arg _mt[112681]:_MT[201], arg this[112678]:range[240](?) :
  range[240](?)) : _unknown[42] "method" "no where doc"
  {
    if(112788 call _cond_test(112781 call ==(426827 call . this[112678] c"bounds") both[107114]))
    {
      if(112709 call _cond_test(112708 call(426785 call . this[112678] c"hasPositiveStride")))
      {
        (112698 return(112699 call ==(112702 call . this[112678] c"alignedLowAsInt")(426781 call . this[112678] c"_low")))
      }
      if(112725 call _cond_test(112724 call(426794 call . this[112678] c"hasNegativeStride")))
      {
        (112714 return(112715 call ==(112718 call . this[112678] c"alignedHighAsInt")(426790 call . this[112678] c"_high")))
      }
      (112730 return 0)
    }
    {
      if(112776 call _cond_test(112769 call ==(426822 call . this[112678] c"bounds") low[107116]))
      {
        (112733 return(112734 call &&(112737 call(426798 call . this[112678] c"hasPositiveStride"))(112738 call ==(112741 call . this[112678] c"alignedLowAsInt")(426803 call . this[112678] c"_low"))))
      }
      {
        if(112765 call _cond_test(112758 call ==(426817 call . this[112678] c"bounds") high[107118]))
        {
          (112746 return(112747 call &&(112750 call(426807 call . this[112678] c"hasNegativeStride"))(112751 call ==(112754 call . this[112678] c"alignedHighAsInt")(426812 call . this[112678] c"_high"))))
        }
      }
    }
  }
  where {
    (112683 call &&(112685 call !(112688 call(426771 call . this[112678] c"hasPosNegUnitStride")))(112689 call !=(426776 call . this[112678] c"bounds") neither[107120]))
  }
  function range[240](?).chpl_isNaturallyAligned[112796](arg _mt[112802]:_MT[201], arg this[112799]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (112816 return(112818 call(426840 call . this[112799] c"hasPosNegUnitStride")))
  }
  where {
    (112804 call ||(112807 call(426831 call . this[112799] c"hasPosNegUnitStride"))(112808 call ==(426836 call . this[112799] c"bounds") neither[107120]))
  }
  function hasAmbiguousAlignmentForIter[112822](arg r[112824]:_any[141](?)) param : _unknown[42] "inline" "private"
  {
    (112840 return 0)
  }
  where {
    (112826 call ||(112832 call(112829 call . r[112824] c"hasPosNegUnitStride"))(112834 call isFiniteIdxType(112836 call . r[112824] c"idxType")))
  }
  function hasAmbiguousAlignmentForIter[112845](arg r[112847]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    (112850 return(112851 call !(112857 call(112854 call . r[112847] c"isAligned"))))
  }
  function range[240](?).isEmpty[112860](arg _mt[112866]:_MT[201], arg this[112863]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method"
  {
    (112869 return(112871 call isEmptyHelp this[112863]))
  }
  function range[240](?).isEmpty[112875](arg _mt[112881]:_MT[201], arg this[112878]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "@unstable"
  {
    (112899 return(112901 call isEmptyHelp this[112878]))
  }
  where {
    (112883 call &&(112886 call isFiniteIdxType(426846 call . this[112878] c"idxType"))(112888 call !=(112891 call . this[112878] c"bounds") both[107114]))
  }
  function isEmptyHelp[112906](arg r[112908]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    if(112936 call _cond_test(112931 call chpl__singleValIdxType(112933 call . r[112908] c"idxType")))
    {
      if(112925 call _cond_test(112915 call >(112918 call . r[112908] c"_low")(112922 call . r[112908] c"_high")))
      {
        (112912 return 1)
      }
    }
    if(112991 call _cond_test(112981 call && 1(112984 call !(112990 call(112987 call . r[112908] c"isAligned")))))
    {
      (112944 call boundsCheckHalt module=[222] HaltWrappers[518] "isEmpty() is invoked on an ambiguously-aligned range")
      (401418 'referenced modules list' HaltWrappers[518])
    }
    {
      (112949 return(112950 call &&(112952 call ||(112954 call ==(112957 call . r[112908] c"bounds") both[107114])(112965 call isFiniteIdxType(112967 call . r[112908] c"idxType")))(112970 call >(112973 call . r[112908] c"alignedLowAsInt")(112977 call . r[112908] c"alignedHighAsInt"))))
    }
  }
  function range[240](?).size[112999](arg _mt[113005]:_MT[201], arg this[113002]:range[240](?) :
  range[240](?)) : _unknown[42] "method" "no parens"
  {
    (113009 return(113014 call(113011 call . this[113002] c"sizeAs") int(64)[10]))
  }
  { scopeless type
    int(64)[10]
  }
  function range[240](?).sizeAs[113019](arg _mt[113029]:_MT[201], arg this[113022]:range[240](?) :
  range[240](?), arg t[113026] :
  integral[159](?)) : _unknown[42] "method"
  {
    if(113049 call _cond_test(113039 call !=(113042 call . this[113022] c"bounds") both[107114]))
    {
      (113034 call compilerError "'size' is not defined on unbounded ranges")
    }
    if(113070 call _cond_test(113068 call chpl__singleValIdxType(426865 call . this[113022] c"idxType")))
    {
      if(113062 call _cond_test(113058 call >(426855 call . this[113022] c"_low")(426860 call . this[113022] c"_high")))
      {
        (113055 return 0)
      }
    }
    (113074 return(113076 call(426871 call . this[113022] c"sizeAsHelp") t[113026]))
  }
  { scopeless type
    t[113026]
  }
  function range[240](?).sizeAsHelp[113081](arg _mt[113105]:_MT[201], arg this[113084]:range[240](?) :
  range[240](?), arg t[113088] :
  integral[159](?), arg al[113095] =
  (113092 call . this[113084] c"alignedLowAsInt"), arg ah[113102] =
  (113099 call . this[113084] c"alignedHighAsInt")) : _unknown[42] "method"
  {
    const ah[113118] "const"(113120 call . this[113084] c"alignedHighAsInt")
    const al[113111] "const"(113113 call . this[113084] c"alignedLowAsInt")
    (113124 'end of statement')
    if(113132 call _cond_test(113128 call > al[113111] ah[113118]))
    {
      (113125 return 0)
    }
    const s[113138] "const"(113139 call :(113142 call abs(113144 call . this[113084] c"stride")) uint(64)[86])
    (113149 'end of statement')
    unknown width[113151] "param"(113153 call numBits(113155 'typeof' al[113111]))
    (113157 'end of statement')
    const lenAsUint[113159] "const"(113160 call +(113162 call /(113164 call :(113166 call -(113168 call : ah[113118](113172 call uint(64)[86] width[113151]))(113174 call : al[113111](113178 call uint(64)[86] width[113151]))) uint(64)[86]) s[113138]) 1)
    (113184 'end of statement')
    if(113229 call _cond_test(113214 call && 1(113217 call ||(113219 call == lenAsUint[113159] 0)(113223 call > lenAsUint[113159](113227 call max t[113088])))))
    {
      (113190 call boundsCheckHalt module=[222] HaltWrappers[518](113191 call +(113193 call +(113195 call +(113197 call + "range.size exceeds max("(113202 call : t[113088] string[244])) ") for: '")(113209 call : this[113084] string[244])) "'"))
      (401438 'referenced modules list' HaltWrappers[518])
    }
    (113233 return(113234 call : lenAsUint[113159] t[113088]))
  }
  { scopeless type
    t[113088]
  }
  function range[240](?).chpl_sizeAsForIter[113241](arg _mt[113251]:_MT[201], arg this[113244]:range[240](?) :
  range[240](?), arg t[113248] :
  integral[159](?)) : _unknown[42] "method"
  {
    if(113271 call _cond_test(113269 call chpl__singleValIdxType(426907 call . this[113244] c"idxType")))
    {
      if(113263 call _cond_test(113259 call >(426897 call . this[113244] c"_low")(426902 call . this[113244] c"_high")))
      {
        (113256 return 0)
      }
    }
    if(113312 call _cond_test(113297 call &&(113299 call !=(113302 call . this[113244] c"bounds") both[107114])(113310 call isFiniteIdxType(426922 call . this[113244] c"idxType"))))
    {
      (113276 return(113278 call(426911 call . this[113244] c"sizeAsHelp") t[113248](113283 call . this[113244] c"chpl_alignedLowAsIntForIter")(113289 call . this[113244] c"chpl_alignedHighAsIntForIter")))
    }
    {
      (113293 return(113295 call(426916 call . this[113244] c"sizeAs") t[113248]))
    }
  }
  { scopeless type
    t[113248]
  }
  function hasFirstLastAreParam[113319](arg r[113321]:_any[141](?)) param : _unknown[42] "private"
  {
    {
      unknown tmp[113396] "expr temp" "maybe param" "maybe type" "temp"
      (113398 'move' tmp[113396](113325 call . r[113321] c"bounds"))
      if(113403 call _cond_test(113400 call == tmp[113396] both[107114]))
      {
        (113335 return 0)
      }
      {
        if(113409 call _cond_test(113406 call == tmp[113396] low[107116]))
        {
          (113346 return(113351 call(113348 call . r[113321] c"hasPosNegUnitStride")))
        }
        {
          if(113416 call _cond_test(113413 call == tmp[113396] high[107118]))
          {
            (113361 return(113366 call(113363 call . r[113321] c"hasPosNegUnitStride")))
          }
          {
            if(113423 call _cond_test(113420 call == tmp[113396] neither[107120]))
            {
              (113376 return(113389 IfExpr (113378 call isFiniteIdxType(113380 call . r[113321] c"idxType")) then
              { scopeless
                (113387 call(113384 call . r[113321] c"hasPosNegUnitStride"))
              } else
              { scopeless
                1
              } ))
            }
          }
        }
      }
    }
  }
  function range[240](?).hasFirst[113429](arg _mt[113435]:_MT[201], arg this[113432]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method"
  {
    (113439 call warnUnstableFirst this[113432](fromHasFirst = 1))
    (113443 return(113445 call(426927 call . this[113432] c"hasFirstForIter")))
  }
  function range[240](?).hasFirstForIter[113448](arg _mt[113454]:_MT[201], arg this[113451]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method"
  {
    (113457 return(113483 IfExpr (113458 call ||(113460 call !(113463 call(426931 call . this[113451] c"isAligned")))(113465 call(426935 call . this[113451] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(113480 IfExpr (113468 call isFiniteIdxType(426940 call . this[113451] c"idxType")) then
      { scopeless
        1
      } else
      { scopeless(113477 IfExpr (113472 call(426944 call . this[113451] c"hasPositiveStride")) then
        { scopeless
          (113474 call(426948 call . this[113451] c"hasLowBound"))
        } else
        { scopeless
          (113476 call(426952 call . this[113451] c"hasHighBound"))
        } )
      } )
    } ))
  }
  function range[240](?).hasFirst[113488](arg _mt[113494]:_MT[201], arg this[113491]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (113501 call warnUnstableFirst this[113491](fromHasFirst = 1))
    (113505 return(113507 call(426958 call . this[113491] c"hasFirstForIter")))
  }
  where {
    (113497 call hasFirstLastAreParam this[113491])
  }
  function range[240](?).hasFirstForIter[113511](arg _mt[113517]:_MT[201], arg this[113514]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    if(113529 call _cond_test(113527 call isFiniteIdxType(426964 call . this[113514] c"idxType")))
    {
      (113523 return 1)
    }
    {
      unknown tmp[113578] "expr temp" "maybe param" "maybe type" "temp"
      (113580 'move' tmp[113578](426969 call . this[113514] c"bounds"))
      if(113585 call _cond_test(113582 call == tmp[113578] low[107116]))
      {
        (113542 return(113547 call(113544 call .(401459 call . this[113514] c"strides") c"isPositive")))
      }
      {
        if(113591 call _cond_test(113588 call == tmp[113578] high[107118]))
        {
          (113557 return(113562 call(113559 call .(401465 call . this[113514] c"strides") c"isNegative")))
        }
        {
          if(113598 call _cond_test(113595 call == tmp[113578] neither[107120]))
          {
            (113572 return 0)
          }
        }
      }
    }
  }
  where {
    (113520 call hasFirstLastAreParam this[113514])
  }
  function range[240](?).first[113605](arg _mt[113611]:_MT[201], arg this[113608]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    (113615 call warnUnstableFirst this[113608](fromHasFirst = 0))
    (113619 return(113621 call(426974 call . this[113608] c"chpl_intToIdx")(113625 call . this[113608] c"firstAsInt")))
  }
  function warnUnstableFirst[113630](arg r[113632]:_any[141](?), param arg fromHasFirst[113634]:_any[141](?)) : _unknown[42] "inline" "private" "no return value for void"
  {
    if(113652 call _cond_test(113639 call ||(113641 call ! 0)(113644 call !(113647 call isFiniteIdxType(113649 call . r[113632] c"idxType")))))
    {
      (113637 return _void[46])
    }
    if(113723 call _cond_test(113716 call !(113722 call(113719 call . r[113632] c"hasLowBound"))))
    {
      if(113711 call _cond_test(113710 call(113707 call .(113704 call . r[113632] c"strides") c"isPositive")))
      {
        if(113672 call _cond_test fromHasFirst[113634])
        {
          (113660 call compilerWarning "range.hasFirst() is unstable for a range over an enum or bool if it has a positive stride and no low bound")
        }
        {
          (113666 call compilerWarning "range.first is unstable for a range over an enum or bool if it has a positive stride and no low bound")
        }
      }
      {
        if(113699 call _cond_test(113698 call(113695 call . r[113632] c"hasPositiveStride")))
        {
          if(113688 call _cond_test fromHasFirst[113634])
          {
            (113680 call warning "range.hasFirst() is unstable for a range over an enum or bool if it has a positive stride and no low bound")
          }
          {
            (113684 call warning "range.first is unstable for a range over an enum or bool if it has a positive stride and no low bound")
          }
        }
      }
    }
    if(113793 call _cond_test(113786 call !(113792 call(113789 call . r[113632] c"hasHighBound"))))
    {
      if(113781 call _cond_test(113780 call(113777 call .(113774 call . r[113632] c"strides") c"isNegative")))
      {
        if(113742 call _cond_test fromHasFirst[113634])
        {
          (113730 call compilerWarning "range.hasFirst() is unstable for a range over an enum or bool if it has a negative stride and no high bound")
        }
        {
          (113736 call compilerWarning "range.first is unstable for a range over an enum or bool if it has a negative stride and no high bound")
        }
      }
      {
        if(113769 call _cond_test(113768 call(113765 call . r[113632] c"hasNegativeStride")))
        {
          if(113758 call _cond_test fromHasFirst[113634])
          {
            (113750 call warning "range.hasFirst() is unstable for a range over an enum or bool if it has a negative stride and no high bound")
          }
          {
            (113754 call warning "range.first is unstable for a range over an enum or bool if it has a negative stride and no high bound")
          }
        }
      }
    }
  }
  function range[240](?).firstAsInt[113799](arg _mt[113805]:_MT[201], arg this[113802]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    (113808 return(113819 IfExpr (113810 call(426983 call . this[113802] c"hasPositiveStride")) then
    { scopeless
      (113812 call . this[113802] c"alignedLowAsInt")
    } else
    { scopeless
      (113816 call . this[113802] c"alignedHighAsInt")
    } ))
  }
  function range[240](?).chpl_firstAsIntForIter[113824](arg _mt[113830]:_MT[201], arg this[113827]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(113940 call _cond_test(113930 call ==(113933 call . this[113827] c"bounds") both[107114]))
    {
      (113834 return(113836 call . this[113827] c"firstAsInt"))
    }
    {
      if(113925 call _cond_test(113924 call(113921 call .(401487 call . this[113827] c"strides") c"isOne")))
      {
        (113841 return(113843 call chpl__idxToInt(113845 call lowBoundForIter this[113827])))
      }
      {
        if(113916 call _cond_test(113915 call(113912 call .(401482 call . this[113827] c"strides") c"isNegOne")))
        {
          (113848 return(113850 call chpl__idxToInt(113852 call highBoundForIter this[113827])))
        }
        {
          if(113907 call _cond_test(113906 call(427021 call . this[113827] c"hasPositiveStride")))
          {
            if(113876 call _cond_test(113875 call(427001 call . this[113827] c"hasLowBound")))
            {
              (113857 return(113859 call helpAlignLow(113861 call chpl__idxToInt(113863 call lowBoundForIter this[113827]))(426991 call . this[113827] c"_alignment")(426996 call . this[113827] c"_stride")))
            }
            {
              (113868 return(113870 call chpl__idxToInt(113872 call lowBoundForIter this[113827])))
            }
          }
          {
            if(113901 call _cond_test(113900 call(427017 call . this[113827] c"hasHighBound")))
            {
              (113882 return(113884 call helpAlignHigh(113886 call chpl__idxToInt(113888 call highBoundForIter this[113827]))(427007 call . this[113827] c"_alignment")(427012 call . this[113827] c"_stride")))
            }
            {
              (113893 return(113895 call chpl__idxToInt(113897 call highBoundForIter this[113827])))
            }
          }
        }
      }
    }
  }
  function range[240](?).hasLast[113946](arg _mt[113952]:_MT[201], arg this[113949]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method"
  {
    (113956 call warnUnstableLast this[113949](fromHasLast = 1))
    (113960 return(113962 call(427026 call . this[113949] c"hasLastForIter")))
  }
  function range[240](?).hasLastForIter[113965](arg _mt[113971]:_MT[201], arg this[113968]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method"
  {
    (113974 return(114000 IfExpr (113975 call ||(113977 call !(113980 call(427030 call . this[113968] c"isAligned")))(113982 call(427034 call . this[113968] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(113997 IfExpr (113985 call isFiniteIdxType(427039 call . this[113968] c"idxType")) then
      { scopeless
        1
      } else
      { scopeless(113994 IfExpr (113989 call(427043 call . this[113968] c"hasPositiveStride")) then
        { scopeless
          (113991 call(427047 call . this[113968] c"hasHighBound"))
        } else
        { scopeless
          (113993 call(427051 call . this[113968] c"hasLowBound"))
        } )
      } )
    } ))
  }
  function range[240](?).hasLast[114005](arg _mt[114011]:_MT[201], arg this[114008]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    (114018 call warnUnstableLast this[114008](fromHasLast = 1))
    (114022 return(114024 call(427057 call . this[114008] c"hasLastForIter")))
  }
  where {
    (114014 call hasFirstLastAreParam this[114008])
  }
  function range[240](?).hasLastForIter[114028](arg _mt[114034]:_MT[201], arg this[114031]:range[240](?) :
  range[240](?)) param : _unknown[42] "method"
  {
    if(114046 call _cond_test(114044 call isFiniteIdxType(427063 call . this[114031] c"idxType")))
    {
      (114040 return 1)
    }
    {
      unknown tmp[114095] "expr temp" "maybe param" "maybe type" "temp"
      (114097 'move' tmp[114095](427068 call . this[114031] c"bounds"))
      if(114102 call _cond_test(114099 call == tmp[114095] low[107116]))
      {
        (114059 return(114064 call(114061 call .(401495 call . this[114031] c"strides") c"isNegative")))
      }
      {
        if(114108 call _cond_test(114105 call == tmp[114095] high[107118]))
        {
          (114074 return(114079 call(114076 call .(401501 call . this[114031] c"strides") c"isPositive")))
        }
        {
          if(114115 call _cond_test(114112 call == tmp[114095] neither[107120]))
          {
            (114089 return 0)
          }
        }
      }
    }
  }
  where {
    (114037 call hasFirstLastAreParam this[114031])
  }
  function range[240](?).last[114122](arg _mt[114128]:_MT[201], arg this[114125]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    (114132 call warnUnstableLast this[114125](fromHasLast = 0))
    (114136 return(114138 call(427073 call . this[114125] c"chpl_intToIdx")(114142 call . this[114125] c"lastAsInt")))
  }
  function warnUnstableLast[114147](arg r[114149]:_any[141](?), param arg fromHasLast[114151]:_any[141](?)) : _unknown[42] "inline" "private" "no return value for void"
  {
    if(114169 call _cond_test(114156 call ||(114158 call ! 0)(114161 call !(114164 call isFiniteIdxType(114166 call . r[114149] c"idxType")))))
    {
      (114154 return _void[46])
    }
    if(114240 call _cond_test(114233 call !(114239 call(114236 call . r[114149] c"hasLowBound"))))
    {
      if(114227 call _cond_test(114226 call(114223 call .(114220 call . r[114149] c"strides") c"isNegative")))
      {
        if(114188 call _cond_test fromHasLast[114151])
        {
          (114176 call compilerWarning "range.hasLast() is unstable for a range over an enum or bool if it has a negative stride and no low bound")
        }
        {
          (114182 call compilerWarning "range.last is unstable for a range over an enum or bool if it has a negative stride and no low bound")
        }
      }
      {
        if(114214 call _cond_test(114213 call(114210 call . r[114149] c"hasNegativeStride")))
        {
          if(114203 call _cond_test fromHasLast[114151])
          {
            (114195 call warning "range.hasLast() is unstable for a range over an enum or bool if it has a negative stride and no low bound")
          }
          {
            (114199 call warning "range.last is unstable for a range over an enum or bool if it has a negative stride and no low bound")
          }
        }
      }
    }
    if(114310 call _cond_test(114303 call !(114309 call(114306 call . r[114149] c"hasHighBound"))))
    {
      if(114297 call _cond_test(114296 call(114293 call .(114290 call . r[114149] c"strides") c"isPositive")))
      {
        if(114258 call _cond_test fromHasLast[114151])
        {
          (114246 call compilerWarning "range.hasLast() is unstable for a range over an enum or bool if it has a positive stride and no high bound")
        }
        {
          (114252 call compilerWarning "range.last is unstable for a range over an enum or bool if it has a positive stride and no high bound")
        }
      }
      {
        if(114284 call _cond_test(114283 call(114280 call . r[114149] c"hasPositiveStride")))
        {
          if(114273 call _cond_test fromHasLast[114151])
          {
            (114265 call warning "range.hasLast() is unstable for a range over an enum or bool if it has a positive stride and no high bound")
          }
          {
            (114269 call warning "range.last is unstable for a range over an enum or bool if it has a positive stride and no high bound")
          }
        }
      }
    }
  }
  function range[240](?).lastAsInt[114316](arg _mt[114322]:_MT[201], arg this[114319]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    (114325 return(114336 IfExpr (114327 call(427082 call . this[114319] c"hasPositiveStride")) then
    { scopeless
      (114329 call . this[114319] c"alignedHighAsInt")
    } else
    { scopeless
      (114333 call . this[114319] c"alignedLowAsInt")
    } ))
  }
  function range[240](?).chpl_lastAsIntForIter[114341](arg _mt[114347]:_MT[201], arg this[114344]:range[240](?) :
  range[240](?)) : _unknown[42] "inline" "method" "no parens"
  {
    if(114426 call _cond_test(114419 call ==(427115 call . this[114344] c"bounds") both[107114]))
    {
      (114351 return(114353 call . this[114344] c"lastAsInt"))
    }
    {
      if(114414 call _cond_test(114413 call(114410 call .(401523 call . this[114344] c"strides") c"isOne")))
      {
        (114358 return(114360 call chpl__idxToInt(114362 call highBoundForIter this[114344])))
      }
      {
        if(114404 call _cond_test(114403 call(114400 call .(401518 call . this[114344] c"strides") c"isNegOne")))
        {
          (114365 return(114367 call chpl__idxToInt(114369 call lowBoundForIter this[114344])))
        }
        {
          if(114395 call _cond_test(114394 call(427110 call . this[114344] c"hasPositiveStride")))
          {
            (114372 return(114374 call helpAlignHigh(114376 call chpl__idxToInt(114378 call highBoundForIter this[114344]))(427090 call . this[114344] c"_alignment")(427095 call . this[114344] c"_stride")))
          }
          {
            (114383 return(114385 call helpAlignLow(114387 call chpl__idxToInt(114389 call lowBoundForIter this[114344]))(427101 call . this[114344] c"_alignment")(427106 call . this[114344] c"_stride")))
          }
        }
      }
    }
  }
  function chpl_idxTypeSizeChange[114432](arg t[114434]:_any[141](?)) param : _unknown[42]
  {
    (114437 return(114438 call &&(114441 call isIntegralType t[114434])(114443 call != t[114434] int(64)[10])))
  }
  function range[240](?).contains[114449](arg _mt[114459]:_MT[201], arg this[114452]:range[240](?) :
  range[240](?), arg ind[114456] :
  (427122 call . this[114452] c"idxType")) : _unknown[42] "inline" "method"
  {
    if(114478 call _cond_test(114476 call chpl__singleValIdxType(427137 call . this[114452] c"idxType")))
    {
      if(114470 call _cond_test(114466 call >(427127 call . this[114452] c"_low")(427132 call . this[114452] c"_high")))
      {
        (114463 return 0)
      }
    }
    if(114492 call _cond_test(114485 call !(114491 call(114488 call . this[114452] c"isAligned"))))
    {
      (114482 return 0)
    }
    const i[114498] "const"(114500 call chpl__idxToInt ind[114456])
    (114503 'end of statement')
    if(114519 call _cond_test(114518 call(427148 call . this[114452] c"hasHighBound")))
    {
      if(114512 call _cond_test(114508 call > i[114498](427144 call . this[114452] c"_high")))
      {
        (114505 return 0)
      }
    }
    if(114538 call _cond_test(114537 call(427158 call . this[114452] c"hasLowBound")))
    {
      if(114531 call _cond_test(114527 call < i[114498](427154 call . this[114452] c"_low")))
      {
        (114524 return 0)
      }
    }
    if(114562 call _cond_test(114558 call !(114561 call(427173 call . this[114452] c"hasPosNegUnitStride"))))
    {
      if(114553 call _cond_test(114546 call !=(114549 call chpl__mod i[114498](427164 call . this[114452] c"_stride"))(427169 call . this[114452] c"_alignment")))
      {
        (114543 return 0)
      }
    }
    (114566 return 1)
  }
  function range[240](?).contains[114570](arg _mt[114582]:_MT[201], arg this[114573]:range[240](?) :
  range[240](?), arg other[114579] :
  (114577 call range[240](?) ?[227])) : _unknown[42] "inline" "method"
  {
    if(114607 call _cond_test(114605 call chpl__singleValIdxType(427189 call . this[114573] c"idxType")))
    {
      if(114599 call _cond_test(114595 call >(427179 call . this[114573] c"_low")(427184 call . this[114573] c"_high")))
      {
        (114586 return(114587 call ==(114590 call . other[114579] c"size") 0))
      }
    }
    if(114630 call _cond_test(114614 call ||(114616 call !(114622 call(114619 call . this[114573] c"isAligned")))(114623 call !(114629 call(114626 call . other[114579] c"isAligned")))))
    {
      (114611 return 0)
    }
    if(114679 call _cond_test(114658 call &&(114660 call ==(114663 call . this[114573] c"bounds") both[107114])(114670 call ==(114676 call(114673 call . this[114573] c"sizeAs") uint(64)[86]) 0)))
    {
      (114635 return(114636 call &&(114638 call ==(114641 call . other[114579] c"bounds") both[107114])(114648 call ==(114654 call(114651 call . other[114579] c"sizeAs") uint(64)[86]) 0)))
    }
    unknown slice[114685](114687 call this[114573] other[114579])
    (114690 'end of statement')
    function adjustedSlice[114691]() : _unknown[42] "no parens"
    {
      (114694 return(114707 IfExpr (114699 call(114696 call . this[114573] c"hasPositiveStride")) then
      { scopeless
        slice[114685]
      } else
      { scopeless
        (114701 call chpl_by slice[114685](114704 call - 1))
      } ))
    }
    (114712 return(114713 call == other[114579](427197 call adjustedSlice[114691])))
  }
  function ==[114719](arg r1[114724] :
  (114722 call range[240](?) ?[227]), arg r2[114730] :
  (114728 call range[240](?) ?[227])) param : _unknown[42] "operator"
  {
    (114764 return 0)
  }
  where {
    (114733 call &&(114735 call !=(114738 call . r1[114724] c"bounds")(114742 call . r2[114730] c"bounds"))(114745 call ||(114747 call !(114750 call isFiniteIdxType(114752 call . r1[114724] c"idxType")))(114755 call !(114758 call isFiniteIdxType(114760 call . r2[114730] c"idxType")))))
  }
  function ==[114769](arg r1[114774] :
  (114772 call range[240](?) ?[227]), arg r2[114780] :
  (114778 call range[240](?) ?[227])) : _unknown[42] "operator" "@unstable"
  {
    const boundedr1[114812] "const"(114855 IfExpr (114813 call ==(114816 call . r1[114774] c"bounds") both[107114]) then
    { scopeless
      r1[114774]
    } else
    { scopeless
      (114824 'new'(114826 call range[240](?)(114828 call . r1[114774] c"idxType") both[107114](114836 call . r1[114774] c"strides")(114840 call . r1[114774] c"_low")(114844 call . r1[114774] c"_high")(114848 call . r1[114774] c"_stride")(114852 call . r1[114774] c"_alignment")))
    } )
    (114859 'end of statement')
    const boundedr2[114861] "const"(114904 IfExpr (114862 call ==(114865 call . r2[114780] c"bounds") both[107114]) then
    { scopeless
      r2[114780]
    } else
    { scopeless
      (114873 'new'(114875 call range[240](?)(114877 call . r2[114780] c"idxType") both[107114](114885 call . r2[114780] c"strides")(114889 call . r2[114780] c"_low")(114893 call . r2[114780] c"_high")(114897 call . r2[114780] c"_stride")(114901 call . r2[114780] c"_alignment")))
    } )
    (114908 'end of statement')
    (114909 return(114910 call == boundedr1[114812] boundedr2[114861]))
  }
  where {
    (114784 call &&(114786 call &&(114788 call !=(114791 call . r1[114774] c"bounds")(114795 call . r2[114780] c"bounds"))(114799 call isFiniteIdxType(114801 call . r1[114774] c"idxType")))(114805 call isFiniteIdxType(114807 call . r2[114780] c"idxType")))
  }
  { scopeless type
    bool[19]
  }
  function ==[114918](arg r1[114923] :
  (114921 call range[240](?) ?[227]), arg r2[114929] :
  (114927 call range[240](?) ?[227])) : _unknown[42] "operator"
  {
    if(114959 call _cond_test(114947 call !=(114953 call(114950 call . r1[114923] c"isAligned"))(114958 call(114955 call . r2[114929] c"isAligned"))))
    {
      (114944 return 0)
    }
    if(114977 call _cond_test(114970 call !(114976 call(114973 call . r1[114923] c"isAligned"))))
    {
      (114964 return(114966 call chpl_ident r1[114923] r2[114929]))
    }
    if(115164 call _cond_test(115154 call ==(115157 call . r1[114923] c"bounds") both[107114]))
    {
      const len[114994] "const"(114999 call(114996 call . r1[114923] c"sizeAs") uint(64)[86])
      const l2[114985] "const"(114990 call(114987 call . r2[114929] c"sizeAs") uint(64)[86])
      (115002 'end of statement')
      if(115010 call _cond_test(115006 call != len[114994] l2[114985]))
      {
        (115003 return 0)
      }
      if(115022 call _cond_test(115018 call == len[114994] 0))
      {
        (115015 return 1)
      }
      if(115040 call _cond_test(115030 call !=(115033 call . r1[114923] c"first")(115037 call . r2[114929] c"first")))
      {
        (115027 return 0)
      }
      if(115052 call _cond_test(115048 call == len[114994] 1))
      {
        (115045 return 1)
      }
      if(115070 call _cond_test(115060 call !=(115063 call . r1[114923] c"stride")(115067 call . r2[114929] c"stride")))
      {
        (115057 return 0)
      }
      (115075 return 1)
    }
    {
      if(115091 call _cond_test(115081 call !=(115084 call . r1[114923] c"stride")(115088 call . r2[114929] c"stride")))
      {
        (115078 return 0)
      }
      if(115119 call _cond_test(115118 call(115115 call . r1[114923] c"hasLowBound")))
      {
        if(115109 call _cond_test(115099 call !=(115102 call . r1[114923] c"low")(115106 call . r2[114929] c"low")))
        {
          (115096 return 0)
        }
      }
      if(115147 call _cond_test(115146 call(115143 call . r1[114923] c"hasHighBound")))
      {
        if(115137 call _cond_test(115127 call !=(115130 call . r1[114923] c"high")(115134 call . r2[114929] c"high")))
        {
          (115124 return 0)
        }
      }
      (115152 return 1)
    }
  }
  where {
    (114933 call ==(114936 call . r1[114923] c"bounds")(114940 call . r2[114929] c"bounds"))
  }
  { scopeless type
    bool[19]
  }
  function !=[115172](arg r1[115177] :
  (115175 call range[240](?) ?[227]), arg r2[115183] :
  (115181 call range[240](?) ?[227])) : _unknown[42] "operator"
  {
    (115187 return(115188 call !(115190 call == r1[115177] r2[115183])))
  }
  function !=[115196](arg r1[115201] :
  (115199 call range[240](?) ?[227]), arg r2[115207] :
  (115205 call range[240](?) ?[227])) : _unknown[42] "operator" "@unstable"
  {
    (115238 return(115239 call !(115241 call == r1[115201] r2[115207])))
  }
  where {
    (115211 call &&(115213 call &&(115215 call !=(115218 call . r1[115201] c"bounds")(115222 call . r2[115207] c"bounds"))(115226 call isFiniteIdxType(115228 call . r1[115201] c"idxType")))(115232 call isFiniteIdxType(115234 call . r2[115207] c"idxType")))
  }
  { scopeless type
    bool[19]
  }
  function !=[115249](arg r1[115254] :
  (115252 call range[240](?) ?[227]), arg r2[115260] :
  (115258 call range[240](?) ?[227])) param : _unknown[42] "operator"
  {
    (115294 return 1)
  }
  where {
    (115263 call &&(115265 call !=(115268 call . r1[115254] c"bounds")(115272 call . r2[115260] c"bounds"))(115275 call ||(115277 call !(115280 call isFiniteIdxType(115282 call . r1[115254] c"idxType")))(115285 call !(115288 call isFiniteIdxType(115290 call . r2[115260] c"idxType")))))
  }
  function <[115299](arg r1[115304] :
  (115302 call range[240](?) ?[227]), arg r2[115310] :
  (115308 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (115337 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115313 call ||(115315 call !=(115318 call . r1[115304] c"bounds") both[107114])(115325 call !=(115328 call . r2[115310] c"bounds") both[107114]))
  }
  function >[115344](arg r1[115349] :
  (115347 call range[240](?) ?[227]), arg r2[115355] :
  (115353 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (115382 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115358 call ||(115360 call !=(115363 call . r1[115349] c"bounds") both[107114])(115370 call !=(115373 call . r2[115355] c"bounds") both[107114]))
  }
  function <=[115387](arg r1[115392] :
  (115390 call range[240](?) ?[227]), arg r2[115398] :
  (115396 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (115425 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115401 call ||(115403 call !=(115406 call . r1[115392] c"bounds") both[107114])(115413 call !=(115416 call . r2[115398] c"bounds") both[107114]))
  }
  function >=[115430](arg r1[115435] :
  (115433 call range[240](?) ?[227]), arg r2[115441] :
  (115439 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (115468 call compilerError "Unbounded ranges don't support comparisons other than '==' and '!='")
  }
  where {
    (115444 call ||(115446 call !=(115449 call . r1[115435] c"bounds") both[107114])(115456 call !=(115459 call . r2[115441] c"bounds") both[107114]))
  }
  function chpl_ident[115473](arg r1[115478] :
  (115476 call range[240](?) ?[227]), arg r2[115484] :
  (115482 call range[240](?) ?[227])) : _unknown[42]
  {
    if(115535 call _cond_test(115525 call !=(115528 call . r1[115478] c"_low")(115532 call . r2[115484] c"_low")))
    {
      (115522 return 0)
    }
    if(115553 call _cond_test(115543 call !=(115546 call . r1[115478] c"_high")(115550 call . r2[115484] c"_high")))
    {
      (115540 return 0)
    }
    if(115571 call _cond_test(115561 call !=(115564 call . r1[115478] c"_stride")(115568 call . r2[115484] c"_stride")))
    {
      (115558 return 0)
    }
    if(115589 call _cond_test(115579 call !=(115582 call . r1[115478] c"_alignment")(115586 call . r2[115484] c"_alignment")))
    {
      (115576 return 0)
    }
    (115594 return 1)
  }
  where {
    (115487 call &&(115489 call &&(115491 call ==(115494 call . r1[115478] c"idxType")(115498 call . r2[115484] c"idxType"))(115501 call ==(115504 call . r1[115478] c"bounds")(115508 call . r2[115484] c"bounds")))(115511 call ==(115514 call . r1[115478] c"strides")(115518 call . r2[115484] c"strides")))
  }
  function chpl_ident[115599](arg r1[115604] :
  (115602 call range[240](?) ?[227]), arg r2[115610] :
  (115608 call range[240](?) ?[227])) param : _unknown[42]
  {
    (115614 return 0)
  }
  function range[240](?).boundingBox[115618](arg _mt[115624]:_MT[201], arg this[115621]:range[240](?) :
  range[240](?)) : _unknown[42] "method"
  {
    (115628 call compilerAssert(115629 call ==(115632 call . this[115621] c"bounds") both[107114]))
    if(115650 call _cond_test(115649 call(115646 call .(115643 call . this[115621] c"strides") c"isOne")))
    {
      (115639 return this[115621])
    }
    (115655 return(115656 'new'(115658 call range[240](?)(115660 call . this[115621] c"idxType")(115664 call . this[115621] c"bounds") one[107127](115672 call . this[115621] c"alignedLowAsInt")(115676 call . this[115621] c"alignedHighAsInt") none[48] none[48])))
  }
  function range[240](?).tryCast[115683](arg _mt[115695]:_MT[201], arg this[115686]:range[240](?) :
  range[240](?), arg t[115692] :
  (115690 call range[240](?) ?[227])) : _unknown[42] "method" "no where doc"
  {
    const r[115703] "const" this[115686]
    (115706 'end of statement')
    (115708 call checkBounds t[115692] r[115703])
    (115712 call checkEnumBoolIdx t[115692] r[115703])
    unknown useR[115716] "param"(115717 call !(115719 call &&(115721 call ==(115724 call . t[115692] c"idxType") int(64)[10])(115729 call isBCPindex(115731 call . r[115703] c"idxType"))))
    (115735 'end of statement')
    unknown result[115737](115769 IfExpr  useR[115716] then
    { scopeless
      r[115703]
    } else
    { scopeless
      (115741 'new'(115743 call range[240](?) int(64)[10](115746 call . r[115703] c"bounds")(115750 call . r[115703] c"strides")(115754 call . r[115703] c"_low")(115758 call . r[115703] c"_high")(115762 call . r[115703] c"_stride")(115766 call . r[115703] c"_alignment")))
    } ) t[115692]
    (115773 'end of statement')
    (115774 return result[115737])
  }
  where {
    (115698 call chpl_tryCastIsSafe this[115686] t[115692])
  }
  function range[240](?).tryCast[115779](arg _mt[115791]:_MT[201], arg this[115782]:range[240](?) :
  range[240](?), arg t[115788] :
  (115786 call range[240](?) ?[227])) : _unknown[42] throws "method"
  {
    const r[115801] "const" this[115782]
    (115804 'end of statement')
    (115806 call checkBounds t[115788] r[115801])
    (115810 call checkEnumBoolIdx t[115788] r[115801])
    unknown tmp[115814] t[115788]
    (115817 'end of statement')
    unknown srcType[115834] "type variable"(115836 call . r[115801] c"idxType")
    unknown dstType[115827] "type variable"(115829 call . t[115788] c"idxType")
    unknown dstIntType[115820] "type variable"(115822 call . tmp[115814] c"chpl_integralIdxType")
    (115840 'end of statement')
    (115841 call =(115844 call . tmp[115814] c"_low")(115870 IfExpr (115847 call !(115853 call(115850 call . r[115801] c"hasLowBound"))) then
    { scopeless
      (115854 call :(115857 call . r[115801] c"_low") dstIntType[115820])
    } else
    { scopeless
      (115862 call chpl__idxToInt(115864 call chpl_throwingCast dstType[115827](115867 call . r[115801] c"lowBound")))
    } ))
    (115873 call =(115876 call . tmp[115814] c"_high")(115902 IfExpr (115879 call !(115885 call(115882 call . r[115801] c"hasHighBound"))) then
    { scopeless
      (115886 call :(115889 call . r[115801] c"_high") dstIntType[115820])
    } else
    { scopeless
      (115894 call chpl__idxToInt(115896 call chpl_throwingCast dstType[115827](115899 call . r[115801] c"highBound")))
    } ))
    unknown error[115906](115913 call(115910 call . r[115801] c"chpl_checkStrides") t[115788])
    (115916 'end of statement')
    if(115924 call _cond_test(115920 call != error[115906] nil[32]))
    {
      (115917 'throw' error[115906])
    }
    if(115979 call _cond_test(115972 call !(115978 call(115975 call . tmp[115814] c"hasParamStrideAltvalAld"))))
    {
      (115930 call =(115933 call . tmp[115814] c"_stride")(115937 call chpl_throwingCast(115939 call . tmp[115814] c"strType")(115943 call . r[115801] c"stride")))
      (115946 call =(115949 call . tmp[115814] c"_alignment")(115969 IfExpr (115953 call isNothingValue(115955 call . r[115801] c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (115959 call :(115962 call . r[115801] c"_alignment")(115966 call . tmp[115814] c"strType"))
      } ))
    }
    (115983 return tmp[115814])
  }
  where {
    (115793 call !(115796 call chpl_tryCastIsSafe this[115782] t[115788]))
  }
  function :[115988](arg r[115993] :
  (115991 call range[240](?) ?[227]), arg t[115999] :
  (115997 call range[240](?) ?[227])) : _unknown[42] "operator"
  {
    (116008 call checkBounds t[115999] r[115993])
    (116012 call checkEnumIdx t[115999] r[115993])
    unknown tmp[116016](116017 'new'(116019 call range[240](?)(116021 call . t[115999] c"idxType")(116025 call . t[115999] c"bounds")(116029 call . t[115999] c"strides") 1))
    (116034 'end of statement')
    unknown srcType[116051] "type variable"(116053 call . r[115993] c"idxType")
    unknown dstType[116044] "type variable"(116046 call . t[115999] c"idxType")
    unknown dstIntType[116037] "type variable"(116039 call . tmp[116016] c"chpl_integralIdxType")
    (116057 'end of statement')
    (116058 call =(116061 call . tmp[116016] c"_low")(116064 call :(116084 IfExpr (116070 call(116067 call . r[115993] c"hasLowBound")) then
    { scopeless
      (116072 call chpl__idxToInt(116073 call :(116076 call . r[115993] c"lowBound") dstType[116044]))
    } else
    { scopeless
      (116081 call . r[115993] c"_low")
    } )(116088 call . tmp[116016] c"chpl_integralIdxType")))
    (116091 call =(116094 call . tmp[116016] c"_high")(116097 call :(116117 IfExpr (116103 call(116100 call . r[115993] c"hasHighBound")) then
    { scopeless
      (116105 call chpl__idxToInt(116106 call :(116109 call . r[115993] c"highBound") dstType[116044]))
    } else
    { scopeless
      (116114 call . r[115993] c"_high")
    } )(116121 call . tmp[116016] c"chpl_integralIdxType")))
    if(116150 call _cond_test 1)
    {
      if(116144 call _cond_test(116143 'if var' const error[116141] "const"(116139 call(116136 call . r[115993] c"chpl_checkStrides") t[115999])))
      {
        (116128 call boundsCheckHalt module=[222] HaltWrappers[518](116133 call(116130 call . error[116141] c"message")))
        (401676 'referenced modules list' HaltWrappers[518])
      }
    }
    if(116207 call _cond_test(116200 call !(116206 call(116203 call . tmp[116016] c"hasParamStrideAltvalAld"))))
    {
      (116156 call =(116159 call . tmp[116016] c"_stride")(116169 call(116166 call .(116163 call . r[115993] c"stride") c"safeCast")(116171 call . tmp[116016] c"strType")))
      (116174 call =(116177 call . tmp[116016] c"_alignment")(116197 IfExpr (116181 call isNothingValue(116183 call . r[115993] c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (116187 call :(116190 call . r[115993] c"_alignment")(116194 call . tmp[116016] c"strType"))
      } ))
    }
    (116211 return tmp[116016])
  }
  where {
    (116003 call chpl_castIsSafe r[115993] t[115999])
  }
  function :[116216](arg r[116221] :
  (116219 call range[240](?) ?[227]), arg t[116227] :
  (116225 call range[240](?) ?[227])) : _unknown[42] throws "operator"
  {
    (116238 call checkBounds t[116227] r[116221])
    (116242 call checkEnumIdx t[116227] r[116221])
    unknown tmp[116246](116247 'new'(116249 call range[240](?)(116251 call . t[116227] c"idxType")(116255 call . t[116227] c"bounds")(116259 call . t[116227] c"strides") 1))
    (116264 'end of statement')
    unknown srcType[116281] "type variable"(116283 call . r[116221] c"idxType")
    unknown dstType[116274] "type variable"(116276 call . t[116227] c"idxType")
    unknown dstIntType[116267] "type variable"(116269 call . tmp[116246] c"chpl_integralIdxType")
    (116287 'end of statement')
    (116288 call =(116291 call . tmp[116246] c"_low")(116294 call :(116314 IfExpr (116300 call(116297 call . r[116221] c"hasLowBound")) then
    { scopeless
      (116302 call chpl__idxToInt(116303 call :(116306 call . r[116221] c"lowBound") dstType[116274]))
    } else
    { scopeless
      (116311 call . r[116221] c"_low")
    } )(116318 call . tmp[116246] c"chpl_integralIdxType")))
    (116321 call =(116324 call . tmp[116246] c"_high")(116327 call :(116347 IfExpr (116333 call(116330 call . r[116221] c"hasHighBound")) then
    { scopeless
      (116335 call chpl__idxToInt(116336 call :(116339 call . r[116221] c"highBound") dstType[116274]))
    } else
    { scopeless
      (116344 call . r[116221] c"_high")
    } )(116351 call . tmp[116246] c"chpl_integralIdxType")))
    if(116380 call _cond_test 1)
    {
      if(116374 call _cond_test(116373 'if var' const error[116371] "const"(116369 call(116366 call . r[116221] c"chpl_checkStrides") t[116227])))
      {
        (116358 call boundsCheckHalt module=[222] HaltWrappers[518](116363 call(116360 call . error[116371] c"message")))
        (401708 'referenced modules list' HaltWrappers[518])
      }
    }
    if(116437 call _cond_test(116430 call !(116436 call(116433 call . tmp[116246] c"hasParamStrideAltvalAld"))))
    {
      (116386 call =(116389 call . tmp[116246] c"_stride")(116399 call(116396 call .(116393 call . r[116221] c"stride") c"safeCast")(116401 call . tmp[116246] c"strType")))
      (116404 call =(116407 call . tmp[116246] c"_alignment")(116427 IfExpr (116411 call isNothingValue(116413 call . r[116221] c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (116417 call :(116420 call . r[116221] c"_alignment")(116424 call . tmp[116246] c"strType"))
      } ))
    }
    (116441 return tmp[116246])
  }
  where {
    (116230 call !(116233 call chpl_castIsSafe r[116221] t[116227]))
  }
  function chpl_throwingCast[116446](arg toType[116448]:_any[141](?), arg from[116450]:_any[141](?)) : _unknown[42] throws "inline"
  {
    unknown fromType[116454] "type variable"(116456 'typeof' from[116450])
    if(116491 call _cond_test(116483 call &&(116486 call isIntegral fromType[116454])(116489 call isIntegral toType[116448])))
    {
      unknown error[116460](116467 call(116464 call . from[116450] c"chpl_checkValue") toType[116448])
      (116470 'end of statement')
      if(116478 call _cond_test(116474 call != error[116460] nil[32]))
      {
        (116471 'throw' error[116460])
      }
    }
    if(116523 call _cond_test(116509 call &&(116511 call &&(116514 call isEnum fromType[116454])(116517 call isIntegral toType[116448]))(116519 call != toType[116448] int(64)[10])))
    {
      const e2i[116497] "const"(116498 call : from[116450] int(64)[10])
      (116503 'end of statement')
      (116504 return(116506 call chpl_throwingCast toType[116448] e2i[116497]))
    }
    (116527 return(116528 call : from[116450] toType[116448]))
  }
  function chpl_throwingCast[116534](arg toType[116536]:_any[141](?), arg from[116538]:_any[141](?)) : _unknown[42] "inline"
  {
    (116546 return(116547 call : from[116538] toType[116536]))
  }
  where {
    (116541 call chpl_idxCastIsSafe toType[116536](116544 'typeof' from[116538]))
  }
  function checkBounds[116554](arg toType[116556]:_any[141](?), arg from[116558]:_any[141](?)) : _unknown[42] "private" "no return value for void"
  {
    if(116594 call _cond_test(116584 call !=(116587 call . toType[116556] c"bounds")(116591 call . from[116558] c"bounds")))
    {
      (116562 call compilerError "cannot cast range from boundKind."(116566 call :(116569 call . from[116558] c"bounds") string[244]) " to boundKind."(116576 call :(116579 call . toType[116556] c"bounds") string[244]))
    }
  }
  function checkEnumBoolIdx[116601](arg toType[116603]:_any[141](?), arg from[116605]:_any[141](?)) : _unknown[42] "private" "no return value for void"
  {
    (116609 call checkEnumIdx toType[116603] from[116605])
    if(116634 call _cond_test(116618 call &&(116620 call ==(116623 call . toType[116603] c"idxType") bool[19])(116627 call !=(116630 call . from[116605] c"idxType") bool[19])))
    {
      (116613 call compilerError "'tryCast' to a range type with idxType=bool is not currently supported")
    }
  }
  function checkEnumIdx[116641](arg toType[116643]:_any[141](?), arg from[116645]:_any[141](?)) : _unknown[42] "private" "no return value for void"
  {
    unknown srcType[116657] "type variable"(116659 call . from[116645] c"idxType")
    unknown dstType[116650] "type variable"(116652 call . toType[116643] c"idxType")
    (116663 'end of statement')
    if(116687 call _cond_test(116670 call && 0(116673 call &&(116675 call ||(116678 call isEnumType srcType[116657])(116681 call isEnumType dstType[116650]))(116683 call != srcType[116657] dstType[116650]))))
    {
      (116665 call compilerWarning "Casts between ranges involving 'enum' indices are currently unstable (see issue #22406); consider performing the conversion ma)
    }
  }
  function range[240](?).chpl_checkStrides[116694](arg _mt[116702]:_MT[201], arg this[116697]:range[240](?) :
  range[240](?), arg toType[116700]:_any[141](?)) : _unknown[42] "method"
  {
    if(116742 call _cond_test(116733 call chpl_assignStrideIsUnsafe(116735 call . toType[116700] c"strides")(116739 call . this[116697] c"strides")))
    {
      (116710 call compilerError "cannot cast range from strideKind."(116714 call :(116717 call . this[116697] c"strides") string[244]) " to strideKind."(116724 call :(116727 call . toType[116700] c"strides") string[244]))
    }
    unknown needThrow[116748] 0
    (116751 'end of statement')
    {
      unknown tmp[116844] "expr temp" "maybe param" "maybe type" "temp"
      (116846 'move' tmp[116844](116753 call . toType[116700] c"strides"))
      if(116851 call _cond_test(116848 call == tmp[116844] one[107127]))
      {
        (116763 call = needThrow[116748](116766 call !=(116769 call . this[116697] c"stride") 1))
      }
      {
        if(116857 call _cond_test(116854 call == tmp[116844] negOne[107129]))
        {
          (116782 call = needThrow[116748](116785 call !=(116788 call . this[116697] c"stride")(116791 call - 1)))
        }
        {
          if(116864 call _cond_test(116861 call == tmp[116844] positive[107131]))
          {
            (116803 call = needThrow[116748](116806 call <(116809 call . this[116697] c"stride") 0))
          }
          {
            if(116871 call _cond_test(116868 call == tmp[116844] negative[107133]))
            {
              (116822 call = needThrow[116748](116825 call >(116828 call . this[116697] c"stride") 0))
            }
            {
              if(116878 call _cond_test(116875 call == tmp[116844] any[107135]))
              {
              }
            }
          }
        }
      }
    }
    if(116915 call _cond_test needThrow[116748])
    {
      (116882 return(116883 'new'(116885 call IllegalArgumentError[414940](?)(116886 call +(116888 call +(116890 call + "bad cast from stride "(116895 call :(116898 call . this[116697] c"stride") string[244])) " to strideKind.")(116903 call :(116906 call . toType[116700] c"strides") string[244])))))
    }
    {
      (116911 return nil[32])
    }
  }
  { scopeless type
    (116705 call _owned[238](?) borrowed IllegalArgumentError?[468067])
  }
  function chpl_tryCastIsSafe[116924](arg r[116929] :
  (116927 call range[240](?) ?[227]), arg t[116935] :
  (116933 call range[240](?) ?[227])) param : _unknown[42]
  {
    (116939 return(116940 call &&(116943 call chpl_assignStrideIsSafe(116945 call . t[116935] c"strides")(116949 call . r[116929] c"strides"))(116953 call chpl_idxCastIsSafe(to =(116955 call . t[116935] c"idxType"))(from =(116960 call . r[116929] c"idxType")))))
  }
  function chpl_castIsSafe[116966](arg r[116971] :
  (116969 call range[240](?) ?[227]), arg t[116977] :
  (116975 call range[240](?) ?[227])) param : _unknown[42]
  {
    (116981 return(116982 call !(116985 call chpl_idxCastThrows(to =(116987 call . t[116977] c"idxType"))(from =(116992 call . r[116971] c"idxType")))))
  }
  function chpl_idxCastIsSafe[116998](arg to[117000]:_any[141](?), arg from[117002]:_any[141](?)) param : _unknown[42]
  {
    (117005 return(117006 call ||(117008 call &&(117010 call !(117012 call &&(117015 call isUint to[117000])(117018 call isInt from[117002])))(117021 call assignmentIsLegal to[117000] from[117002]))(117024 call &&(117026 call == to[117000] int(64)[10])(117031 call isBCPindex from[117002]))))
  }
  function chpl_idxCastThrows[117035](arg to[117037]:_any[141](?), arg from[117039]:_any[141](?)) param : _unknown[42]
  {
    (117042 return(117043 call &&(117045 call != to[117037] from[117039])(117049 call ||(117052 call isEnumType to[117037])(117055 call isEnumType from[117039]))))
  }
  function isBCPindex[117059](arg t[117061]:_any[141](?)) param : _unknown[42] "private"
  {
    (117064 return(117065 call ||(117067 call == t[117061] byteIndex[18611])(117071 call == t[117061] codepointIndex[18730])))
  }
  function range[240](?).chpl_boundsCheck[117077](arg _mt[117094]:_MT[201], arg this[117080]:range[240](?) :
  range[240](?), arg other[117091] :
  (117084 call range[240](?) unknown e[117085] unknown b[117087] unknown s[117089])) : _unknown[42] "inline" "method"
  {
    if(117120 call _cond_test(117118 call chpl__singleValIdxType(427371 call . this[117080] c"idxType")))
    {
      if(117112 call _cond_test(117108 call >(427361 call . this[117080] c"_low")(427366 call . this[117080] c"_high")))
      {
        (117105 return 0)
      }
    }
    if(117134 call _cond_test(117127 call !(117133 call(117130 call . this[117080] c"isAligned"))))
    {
      (117124 return 0)
    }
    (117139 return 1)
  }
  where {
    (117096 call == b[117087] neither[107120])
  }
  function range[240](?).chpl_boundsCheck[117144](arg _mt[117161]:_MT[201], arg this[117147]:range[240](?) :
  range[240](?), arg other[117158] :
  (117151 call range[240](?) unknown e[117152] unknown b[117154] unknown s[117156])) : _unknown[42] "inline" "method"
  {
    if(117174 call _cond_test(117167 call !(117173 call(117170 call . this[117147] c"isAligned"))))
    {
      (117164 return 0)
    }
    unknown boundedOther[117180](117335 IfExpr (117185 call(117182 call . other[117158] c"isAligned")) then
    { scopeless
      (117186 'new'(117188 call range[240](?)(427378 call . this[117147] c"idxType") both[107114](117195 call . other[117158] c"strides")(117208 IfExpr (117202 call(117199 call . other[117158] c"hasLowBound")) then
      { scopeless
        (117204 call . other[117158] c"_low")
      } else
      { scopeless
        (427383 call . this[117147] c"_low")
      } )(117221 IfExpr (117215 call(117212 call . other[117158] c"hasHighBound")) then
      { scopeless
        (117217 call . other[117158] c"_high")
      } else
      { scopeless
        (427388 call . this[117147] c"_high")
      } )(117225 call . other[117158] c"_stride")(117229 call . other[117158] c"_alignment")))
    } else
    { scopeless(117332 IfExpr (117236 call(117233 call . this[117147] c"hasPosNegUnitStride")) then
      { scopeless
        (117237 'new'(117239 call range[240](?)(427394 call . this[117147] c"idxType") both[107114](117246 call . other[117158] c"strides")(117259 IfExpr (117253 call(117250 call . other[117158] c"hasLowBound")) then
        { scopeless
          (117255 call . other[117158] c"_low")
        } else
        { scopeless
          (427399 call . this[117147] c"_low")
        } )(117272 IfExpr (117266 call(117263 call . other[117158] c"hasHighBound")) then
        { scopeless
          (117268 call . other[117158] c"_high")
        } else
        { scopeless
          (427404 call . this[117147] c"_high")
        } )(117276 call . other[117158] c"_stride")(117279 call : 0(117283 call chpl__rangeStrideType(427409 call . this[117147] c"idxType")))))
      } else
      { scopeless
        (117285 'new'(117287 call range[240](?)(427415 call . this[117147] c"idxType") both[107114](117294 call . other[117158] c"strides")(117307 IfExpr (117301 call(117298 call . other[117158] c"hasLowBound")) then
        { scopeless
          (117303 call . other[117158] c"_low")
        } else
        { scopeless
          (427420 call . this[117147] c"_low")
        } )(117320 IfExpr (117314 call(117311 call . other[117158] c"hasHighBound")) then
        { scopeless
          (117316 call . other[117158] c"_high")
        } else
        { scopeless
          (427425 call . this[117147] c"_high")
        } )(117324 call . other[117158] c"_stride")(117328 call . this[117147] c"_alignment") 1))
      } )
    } )
    (117339 'end of statement')
    (117340 return(117341 call ||(117343 call ==(117349 call(117346 call . boundedOther[117180] c"sizeAs") uint(64)[86]) 0)(117353 call(427429 call . this[117147] c"contains") boundedOther[117180])))
  }
  function range[240](?).chpl_boundsCheck[117357](arg _mt[117367]:_MT[201], arg this[117360]:range[240](?) :
  range[240](?), arg other[117364] :
  (427435 call . this[117360] c"idxType")) : _unknown[42] "inline" "method"
  {
    (117370 return(117372 call(427439 call . this[117360] c"contains") other[117364]))
  }
  function range[240](?).alignLow[117376](arg _mt[117382]:_MT[201], ref arg this[117379]:range[240](?) :
  range[240](?)) : _unknown[42] "method"
  {
    if(117404 call _cond_test(117394 call && 1(117397 call !(117403 call(117400 call . this[117379] c"isAligned")))))
    {
      (117389 call boundsCheckHalt module=[222] HaltWrappers[518] "alignLow -- Cannot be applied to a range with ambiguous alignment.")
      (401784 'referenced modules list' HaltWrappers[518])
    }
    if(117421 call _cond_test(117417 call !(117420 call(427450 call . this[117379] c"hasPosNegUnitStride"))))
    {
      (117409 call =(427446 call . this[117379] c"_low")(117413 call . this[117379] c"alignedLowAsInt"))
    }
    (117426 return this[117379])
  }
  function range[240](?).alignHigh[117430](arg _mt[117436]:_MT[201], ref arg this[117433]:range[240](?) :
  range[240](?)) : _unknown[42] "method"
  {
    if(117458 call _cond_test(117448 call && 1(117451 call !(117457 call(117454 call . this[117433] c"isAligned")))))
    {
      (117443 call boundsCheckHalt module=[222] HaltWrappers[518] "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
      (401792 'referenced modules list' HaltWrappers[518])
    }
    if(117475 call _cond_test(117471 call !(117474 call(427461 call . this[117433] c"hasPosNegUnitStride"))))
    {
      (117463 call =(427457 call . this[117433] c"_high")(117467 call . this[117433] c"alignedHighAsInt"))
    }
    (117480 return this[117433])
  }
  function range[240](?).indexOrder[117484](arg _mt[117494]:_MT[201], arg this[117487]:range[240](?) :
  range[240](?), arg ind[117491] :
  (427467 call . this[117487] c"idxType")) : _unknown[42] "method" "@unstable"
  {
    if(117516 call _cond_test(117506 call && 1(117509 call !(117515 call(117512 call . this[117487] c"isAligned")))))
    {
      (117501 call boundsCheckHalt module=[222] HaltWrappers[518] "indexOrder -- Undefined on a range with ambiguous alignment.")
      (401800 'referenced modules list' HaltWrappers[518])
    }
    if(117534 call _cond_test(117529 call !(117532 call(427476 call . this[117487] c"contains") ind[117491])))
    {
      (117521 return(117522 call :(117524 call - 1)(427472 call . this[117487] c"chpl_integralIdxType")))
    }
    if(117627 call _cond_test(117626 call(117623 call .(401817 call . this[117487] c"strides") c"isOne")))
    {
      if(117553 call _cond_test(117552 call(117549 call . this[117487] c"hasLowBound")))
      {
        (117540 return(117541 call -(117544 call chpl__idxToInt ind[117491])(427483 call . this[117487] c"_low")))
      }
    }
    {
      if(117618 call _cond_test(117617 call(117614 call .(401812 call . this[117487] c"strides") c"isNegOne")))
      {
        if(117572 call _cond_test(117571 call(117568 call . this[117487] c"hasHighBound")))
        {
          (117559 return(117560 call -(427488 call . this[117487] c"_high")(117564 call chpl__idxToInt ind[117491])))
        }
      }
      {
        if(117608 call _cond_test(117607 call(117604 call . this[117487] c"hasFirst")))
        {
          (117578 return(117579 call :(117581 call /(117583 call -(117585 call :(117588 call chpl__idxToInt ind[117491])(427494 call . this[117487] c"strType"))(117591 call :(117594 call chpl__idxToInt(117596 call . this[117487] c"first"))(427498 call . this[117487] c"strType")))(427503 call . this[117487] c"_stride"))(427507 call . this[117487] c"chpl_integralIdxType")))
        }
      }
    }
    (117632 return(117633 call :(117635 call - 1)(427511 call . this[117487] c"chpl_integralIdxType")))
  }
  function range[240](?).orderToIndex[117641](arg _mt[117651]:_MT[201], arg this[117644]:range[240](?) :
  range[240](?), arg ord[117648] :
  integral[159](?)) : _unknown[42] "method" "@unstable"
  {
    if(117774 call _cond_test 1)
    {
      if(117669 call _cond_test(117665 call !(117668 call(427521 call . this[117644] c"hasFirst"))))
      {
        (117660 call boundsCheckHalt module=[222] HaltWrappers[518] "invoking orderToIndex on a range that has no first index")
        (401821 'referenced modules list' HaltWrappers[518])
      }
      if(117687 call _cond_test(117683 call !(117686 call(427525 call . this[117644] c"isAligned"))))
      {
        (117678 call boundsCheckHalt module=[222] HaltWrappers[518] "invoking orderToIndex on a range that is ambiguously aligned")
        (401827 'referenced modules list' HaltWrappers[518])
      }
      if(117711 call _cond_test(117707 call < ord[117648] 0))
      {
        (117696 call boundsCheckHalt module=[222] HaltWrappers[518](117697 call + "invoking orderToIndex on a negative integer: "(117702 call : ord[117648] string[244])))
        (401833 'referenced modules list' HaltWrappers[518])
      }
      if(117768 call _cond_test(117747 call &&(117749 call ==(117752 call . this[117644] c"bounds") both[107114])(117759 call >= ord[117648](117766 call(117763 call . this[117644] c"sizeAs") uint(64)[86]))))
      {
        (117720 call boundsCheckHalt module=[222] HaltWrappers[518](117721 call +(117723 call +(117725 call + "invoking orderToIndex on an integer "(117730 call : ord[117648] string[244])) " that is larger than the range's number of indices ")(117737 call :(117743 call(117740 call . this[117644] c"sizeAs") uint(64)[86]) string[244])))
        (401839 'referenced modules list' HaltWrappers[518])
      }
    }
    (117778 return(117780 call(427534 call . this[117644] c"chpl_intToIdx")(117782 call chpl__addRangeStrides(117784 call . this[117644] c"firstAsInt")(117788 call . this[117644] c"stride") ord[117648])))
  }
  { scopeless type
    (427517 call . this[117644] c"idxType")
  }
  function range[240](?).translate[117795](arg _mt[117805]:_MT[201], arg this[117798]:range[240](?) :
  range[240](?), arg offset[117802] :
  integral[159](?)) : _unknown[42] "inline" "method" "@unstable"
  {
    (117808 return(117809 call + this[117798] offset[117802]))
  }
  function range[240](?).translate[117815](arg _mt[117823]:_MT[201], arg this[117818]:range[240](?) :
  range[240](?), arg i[117821]:_any[141](?)) : _unknown[42] "inline" "last resort" "method" "no return value for void"
  {
    (117827 call compilerError "offsets must be of integral type")
  }
  function range[240](?).translate[117833](arg _mt[117843]:_MT[201], arg this[117836]:range[240](?) :
  range[240](?), arg offset[117840] :
  integral[159](?)) : _unknown[42] "inline" "method" "no return value for void"
  {
    (117850 call compilerError "can't apply '.translate()' to a range whose 'idxType' only has one value")
  }
  where {
    (117846 call chpl__singleValIdxType(427544 call . this[117836] c"idxType"))
  }
  function range[240](?).expand[117857](arg _mt[117867]:_MT[201], arg this[117860]:range[240](?) :
  range[240](?), arg offset[117864] :
  integral[159](?)) : _unknown[42] "method" "no return value for void"
  {
    (117878 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (117869 call !=(427550 call . this[117860] c"bounds") both[107114])
  }
  function range[240](?).expand[117885](arg _mt[117895]:_MT[201], arg this[117888]:range[240](?) :
  range[240](?), arg offset[117892] :
  integral[159](?)) : _unknown[42] "method" "@unstable"
  {
    const i[117899] "const"(117904 call(117901 call . offset[117892] c"safeCast")(117906 call chpl__signedType(427555 call . this[117888] c"chpl_integralIdxType")))
    (117909 'end of statement')
    (117910 return(117911 'new'(117913 call range[240](?)(427561 call . this[117888] c"idxType")(427566 call . this[117888] c"bounds")(427571 call . this[117888] c"strides")(117917 call -(427576 call . this[117888] c"_low") i[117899])(117921 call +(427582 call . this[117888] c"_high") i[117899])(427588 call . this[117888] c"_stride")(427593 call . this[117888] c"_alignment"))))
  }
  function range[240](?).expand[117929](arg _mt[117939]:_MT[201], arg this[117932]:range[240](?) :
  range[240](?), arg offset[117936] :
  integral[159](?)) : _unknown[42] "method" "no return value for void"
  {
    (117946 call compilerError "can't apply '.expand()' to a range whose 'idxType' only has one value")
  }
  where {
    (117942 call chpl__singleValIdxType(427599 call . this[117932] c"idxType"))
  }
  function range[240](?).interior[117953](arg _mt[117963]:_MT[201], arg this[117956]:range[240](?) :
  range[240](?), arg offset[117960] :
  integral[159](?)) : _unknown[42] "last resort" "method" "no return value for void"
  {
    (117974 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (117965 call !=(427605 call . this[117956] c"bounds") both[107114])
  }
  function range[240](?).interior[117981](arg _mt[117991]:_MT[201], arg this[117984]:range[240](?) :
  range[240](?), arg offset[117988] :
  integral[159](?)) : _unknown[42] "method" "@unstable"
  {
    if(118045 call _cond_test 1)
    {
      if(118039 call _cond_test(118025 call >(118027 call :(118030 call abs offset[117988]) uint(64)[86])(118037 call(118034 call . this[117984] c"sizeAs") uint(64)[86])))
      {
        (117998 call boundsCheckHalt module=[222] HaltWrappers[518](117999 call +(118001 call +(118003 call + "can't compute the interior "(118008 call : offset[117988] string[244])) " elements of a range with size ")(118015 call :(118021 call(118018 call . this[117984] c"sizeAs") uint(64)[86]) string[244])))
        (401854 'referenced modules list' HaltWrappers[518])
      }
    }
    const i[118051] "const"(118058 call(118055 call .(118053 call abs offset[117988]) c"safeCast")(427614 call . this[117984] c"chpl_integralIdxType"))
    (118061 'end of statement')
    if(118084 call _cond_test(118080 call < offset[117988] 0))
    {
      (118062 return(118063 'new'(118065 call range[240](?)(427620 call . this[117984] c"idxType")(427625 call . this[117984] c"bounds")(427630 call . this[117984] c"strides")(427635 call . this[117984] c"_low")(118070 call +(118072 call -(427640 call . this[117984] c"_low") 1) i[118051])(427646 call . this[117984] c"_stride")(427651 call . this[117984] c"_alignment"))))
    }
    if(118111 call _cond_test(118107 call > offset[117988] 0))
    {
      (118089 return(118090 'new'(118092 call range[240](?)(427658 call . this[117984] c"idxType")(427663 call . this[117984] c"bounds")(427668 call . this[117984] c"strides")(118096 call -(118098 call +(427673 call . this[117984] c"_high") 1) i[118051])(427679 call . this[117984] c"_high")(427684 call . this[117984] c"_stride")(427689 call . this[117984] c"_alignment"))))
    }
    (118116 return(118117 'new'(118119 call range[240](?)(427696 call . this[117984] c"idxType")(427701 call . this[117984] c"bounds")(427706 call . this[117984] c"strides")(427711 call . this[117984] c"_low")(427716 call . this[117984] c"_high")(427721 call . this[117984] c"_stride")(427726 call . this[117984] c"_alignment"))))
  }
  function range[240](?).exterior[118129](arg _mt[118139]:_MT[201], arg this[118132]:range[240](?) :
  range[240](?), arg offset[118136] :
  integral[159](?)) : _unknown[42] "last resort" "method" "no return value for void"
  {
    (118150 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (118141 call !=(427732 call . this[118132] c"bounds") both[107114])
  }
  function range[240](?).exterior[118157](arg _mt[118167]:_MT[201], arg this[118160]:range[240](?) :
  range[240](?), arg offset[118164] :
  integral[159](?)) : _unknown[42] "method" "@unstable"
  {
    const i[118171] "const"(118178 call(118175 call .(118173 call abs offset[118164]) c"safeCast")(427738 call . this[118160] c"chpl_integralIdxType"))
    (118181 'end of statement')
    if(118204 call _cond_test(118200 call < offset[118164] 0))
    {
      (118182 return(118183 'new'(118185 call range[240](?)(427744 call . this[118160] c"idxType")(427749 call . this[118160] c"bounds")(427754 call . this[118160] c"strides")(118189 call -(427759 call . this[118160] c"_low") i[118171])(118193 call -(427765 call . this[118160] c"_low") 1)(427770 call . this[118160] c"_stride")(427775 call . this[118160] c"_alignment"))))
    }
    if(118231 call _cond_test(118227 call > offset[118164] 0))
    {
      (118209 return(118210 'new'(118212 call range[240](?)(427782 call . this[118160] c"idxType")(427787 call . this[118160] c"bounds")(427792 call . this[118160] c"strides")(118216 call +(427797 call . this[118160] c"_high") 1)(118220 call +(427802 call . this[118160] c"_high") i[118171])(427808 call . this[118160] c"_stride")(427813 call . this[118160] c"_alignment"))))
    }
    (118236 return(118237 'new'(118239 call range[240](?)(427820 call . this[118160] c"idxType")(427825 call . this[118160] c"bounds")(427830 call . this[118160] c"strides")(427835 call . this[118160] c"_low")(427840 call . this[118160] c"_high")(427845 call . this[118160] c"_stride")(427850 call . this[118160] c"_alignment"))))
  }
  function range[240](?).exterior[118249](arg _mt[118259]:_MT[201], arg this[118252]:range[240](?) :
  range[240](?), arg offset[118256] :
  integral[159](?)) : _unknown[42] "method" "no return value for void"
  {
    (118266 call compilerError "can't apply '.exterior()' to a range whose 'idxType' only has one value")
  }
  where {
    (118262 call chpl__singleValIdxType(427856 call . this[118252] c"idxType"))
  }
  function =[118273](ref arg r1[118278] :
  (118276 call range[240](?) ?[227]), arg r2[118284] :
  (118282 call range[240](?) ?[227])) : _unknown[42] "assignop" "inline" "operator" "no return value for void"
  {
    if(118324 call _cond_test(118312 call !(118315 call assignmentIsLegal(118317 call . r1[118278] c"idxType")(118321 call . r2[118284] c"idxType"))))
    {
      (118289 call compilerError "assigning to a range with idxType "(118293 call :(118296 call . r1[118278] c"idxType") string[244]) " from a range with idxType "(118301 call :(118304 call . r2[118284] c"idxType") string[244]) " without an explicit cast")
    }
    if(118361 call _cond_test(118351 call !=(118354 call . r1[118278] c"bounds")(118358 call . r2[118284] c"bounds")))
    {
      (118330 call compilerError "assigning to a range with boundKind."(118334 call :(118337 call . r1[118278] c"bounds") string[244]) " from a range with boundKind."(118342 call :(118345 call . r2[118284] c"bounds") string[244]) " without an explicit cast")
    }
    if(118394 call _cond_test(118388 call !(118391 call chpl_assignStrideIsSafe r1[118278] r2[118284])))
    {
      (118367 call compilerError "assigning to a range with strideKind."(118371 call :(118374 call . r1[118278] c"strides") string[244]) " from a range with strideKind."(118379 call :(118382 call . r2[118284] c"strides") string[244]) " without an explicit cast")
    }
    (118399 call =(118402 call . r1[118278] c"_low")(118405 call :(118408 call . r2[118284] c"_low")(118412 call . r1[118278] c"chpl_integralIdxType")))
    (118415 call =(118418 call . r1[118278] c"_high")(118421 call :(118424 call . r2[118284] c"_high")(118428 call . r1[118278] c"chpl_integralIdxType")))
    if(118469 call _cond_test(118462 call !(118468 call(118465 call . r1[118278] c"hasParamStrideAltvalAld"))))
    {
      (118432 call =(118435 call . r1[118278] c"_stride")(118439 call . r2[118284] c"stride"))
      (118442 call =(118445 call . r1[118278] c"_alignment")(118459 IfExpr (118449 call isNothingValue(118451 call . r2[118284] c"_alignment")) then
      { scopeless
        0
      } else
      { scopeless
        (118456 call . r2[118284] c"_alignment")
      } ))
    }
  }
  function +[118475](arg r1[118480] :
  (118478 call range[240](?) ?[227]), arg r2[118486] :
  (118484 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (118491 call compilerError "range addition is currently not supported")
  }
  function -[118497](arg r1[118502] :
  (118500 call range[240](?) ?[227]), arg r2[118508] :
  (118506 call range[240](?) ?[227])) : _unknown[42] "operator" "no return value for void"
  {
    (118513 call compilerError "range subtraction is currently not supported")
  }
  function +[118519](arg r[118529] :
  (118522 call range[240](?) unknown e[118523] unknown b[118525] unknown s[118527]), arg i[118533] :
  integral[159](?)) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118537 return(118538 'new'(118540 call range[240](?) e[118523] b[118525] s[118527](118544 call +(118547 call . r[118529] c"_low") i[118533])(118551 call +(118554 call . r[118529] c"_high") i[118533])(118559 call . r[118529] c"_stride")(118562 call +(118565 call chpl__idxToInt(118569 call . r[118529] c"alignment")) i[118533])(118577 call(118574 call . r[118529] c"isAligned")))))
  }
  function +=[118580](ref arg r[118590] :
  (118583 call range[240](?) unknown e[118584] unknown b[118586] unknown s[118588]), arg offset[118594] :
  integral[159](?)) : _unknown[42] "assignop" "inline" "operator" "@unstable" "no return value for void"
  {
    (118598 call = r[118590](118601 call + r[118590] offset[118594]))
  }
  function +[118607](arg i[118610] :
  integral[159](?), arg r[118621] :
  (118614 call range[240](?) unknown e[118615] unknown b[118617] unknown s[118619])) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118625 return(118626 call + r[118621] i[118610]))
  }
  function -[118632](arg r[118642] :
  (118635 call range[240](?) unknown e[118636] unknown b[118638] unknown s[118640]), arg i[118646] :
  integral[159](?)) : _unknown[42] "inline" "operator" "@unstable"
  {
    (118650 return(118651 'new'(118653 call range[240](?) e[118636] b[118638] s[118640](118657 call -(118660 call . r[118642] c"_low") i[118646])(118664 call -(118667 call . r[118642] c"_high") i[118646])(118672 call . r[118642] c"_stride")(118675 call -(118678 call chpl__idxToInt(118680 call . r[118642] c"alignment")) i[118646])(118688 call(118685 call . r[118642] c"isAligned")))))
  }
  function -=[118691](ref arg r[118701] :
  (118694 call range[240](?) unknown e[118695] unknown b[118697] unknown s[118699]), arg offset[118705] :
  integral[159](?)) : _unknown[42] "assignop" "inline" "operator" "@unstable" "no return value for void"
  {
    (118709 call = r[118701](118712 call - r[118701] offset[118705]))
  }
  function chpl_check_step_integral[118718](arg step[118720]:_any[141](?)) : _unknown[42] "inline" "no return value for void"
  {
    if(118740 call _cond_test(118734 call !(118737 call isIntegral(118739 'typeof' step[118720]))))
    {
      (118724 call compilerError "can't apply 'by' using step of a non-integral type "(118728 call :(118731 'typeof' step[118720]) string[244]))
    }
  }
  function chpl_need_to_check_step[118747](arg step[118749]:_any[141](?), arg strType[118751]:_any[141](?)) param : _unknown[42]
  {
    (118755 call compilerAssert(118757 call isInt strType[118751]))
    (118759 return(118760 call &&(118762 call !=(118765 'typeof' step[118749]) strType[118751])(118767 call >=(118770 call numBits(118772 'typeof' step[118749]))(118774 call numBits strType[118751]))))
  }
  function chpl_range_check_stride[118778](arg step[118780]:_any[141](?), arg idxType[118782]:_any[141](?)) : _unknown[42] "inline" "no return value for void"
  {
    (118786 call chpl_check_step_integral step[118780])
    unknown strType[118789] "type variable"(118791 call chpl__rangeStrideType idxType[118782])
    if(118850 call _cond_test 1)
    {
      if(118808 call _cond_test(118804 call == step[118780] 0))
      {
        (118799 call boundsCheckHalt module=[222] HaltWrappers[518] "the step argument of the 'by' operator is zero")
        (401895 'referenced modules list' HaltWrappers[518])
      }
      if(118844 call _cond_test(118828 call &&(118831 call chpl_need_to_check_step step[118780] strType[118789])(118834 call > step[118780](118837 call :(118840 call max strType[118789])(118843 'typeof' step[118780])))))
      {
        (118817 call boundsCheckHalt module=[222] HaltWrappers[518](118818 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(118823 call : strType[118789] string[244])))
        (401901 'referenced modules list' HaltWrappers[518])
      }
    }
  }
  function chpl_range_check_stride[118856](param arg step[118858]:_any[141](?), arg idxType[118860]:_any[141](?)) : _unknown[42] "inline" "no return value for void"
  {
    (118864 call chpl_check_step_integral step[118858])
    unknown strType[118867] "type variable"(118869 call chpl__rangeStrideType idxType[118860])
    if(118880 call _cond_test(118876 call == step[118858] 0))
    {
      (118873 call compilerError "the step argument of the 'by' operator is zero")
    }
    if(118911 call _cond_test(118895 call &&(118898 call chpl_need_to_check_step step[118858] strType[118867])(118901 call > step[118858](118904 call :(118907 call max strType[118867])(118910 'typeof' step[118858])))))
    {
      (118886 call compilerError(118887 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(118890 call : strType[118867] string[244])))
    }
  }
  function chpl_by_help[118918](arg r[118928] :
  (118921 call range[240](?) unknown i[118922] unknown b[118924] unknown s[118926]), arg step[118931]:_any[141](?), param arg newStrides[118933]:_any[141](?)) : _unknown[42]
  {
    const lw[118961] "const"(118963 call . r[118928] c"_low")
    const hh[118954] "const"(118956 call . r[118928] c"_high")
    const st[118938] "const"(118939 call *(118942 call . r[118928] c"stride")(118945 call : step[118931](118949 call . r[118928] c"strType")))
    (118967 'end of statement')
    (118969 call compilerAssert(118970 call !(118976 call(118973 call . newStrides[118933] c"isPosNegOne"))))
    if(119005 call _cond_test(118998 call !(119004 call(119001 call . r[118928] c"isAligned"))))
    {
      (118977 return(118994 IfExpr (118978 call ||(118980 call == st[118938] 1)(118984 call == st[118938](118987 call - 1))) then
      { scopeless
        (118991 call newZeroAlmtRange)
      } else
      { scopeless
        (118993 call newUnalignedRange)
      } ))
    }
    if(119084 call _cond_test(119081 call isPositiveStride newStrides[118933] st[118938]))
    {
      (119010 return(119040 IfExpr (119012 call hasLowBoundForIter r[118928]) then
      { scopeless
        (119014 'new'(119016 call range[240](?) i[118922] b[118924] newStrides[118933] lw[118961] hh[118954] st[118938](119024 call . r[118928] c"chpl_alignedLowAsIntForIter") 1 1))
      } else
      { scopeless(119037 IfExpr (119029 call == st[118938] 1) then
        { scopeless
          (119034 call newZeroAlmtRange)
        } else
        { scopeless
          (119036 call newUnalignedRange)
        } )
      } ))
    }
    {
      (119044 return(119076 IfExpr (119046 call hasHighBoundForIter r[118928]) then
      { scopeless
        (119048 'new'(119050 call range[240](?) i[118922] b[118924] newStrides[118933] lw[118961] hh[118954] st[118938](119058 call . r[118928] c"chpl_alignedHighAsIntForIter") 1 1))
      } else
      { scopeless(119073 IfExpr (119063 call == st[118938](119066 call - 1)) then
        { scopeless
          (119070 call newZeroAlmtRange)
        } else
        { scopeless
          (119072 call newUnalignedRange)
        } )
      } ))
    }
    function newAlignedRange[119090](arg alignment[119092]:_any[141](?)) : _unknown[42]
    {
      (119095 return(119096 'new'(119098 call range[240](?) i[118922] b[118924] newStrides[118933] lw[118961] hh[118954] st[118938] alignment[119092] 1 1)))
    }
    function newZeroAlmtRange[119110]() : _unknown[42]
    {
      (119113 return(119114 'new'(119116 call range[240](?) i[118922] b[118924] newStrides[118933] lw[118961] hh[118954] st[118938](119123 call : 0(119127 call . r[118928] c"strType")))))
    }
    function newUnalignedRange[119132]() : _unknown[42] "inline"
    {
      (119135 return(119136 'new'(119138 call range[240](?) i[118922] b[118924] newStrides[118933] lw[118961] hh[118954] st[118938](119145 call : unalignedMark[107107](119149 call . r[118928] c"strType")))))
    }
  }
  function chpl_by[119156](arg r[119161] :
  (119159 call range[240](?) ?[227]), arg step[119164]:_any[141](?)) : _unknown[42] "inline" "operator"
  {
    (119168 call chpl_range_check_stride step[119164](119171 call . r[119161] c"idxType"))
    unknown newStrides[119175] "param"(119195 IfExpr (119176 call !(119179 call isUint step[119164])) then
    { scopeless
      any[107135]
    } else
    { scopeless
      (119186 call chpl_strideProduct(119188 call . r[119161] c"strides") positive[107131])
    } )
    (119199 'end of statement')
    (119200 return(119202 call chpl_by_help r[119161] step[119164] newStrides[119175]))
  }
  function chpl_by[119208](arg r[119213] :
  (119211 call range[240](?) ?[227]), param arg step[119216]:_any[141](?)) : _unknown[42] "inline" "operator"
  {
    (119220 call chpl_range_check_stride step[119216](119223 call . r[119213] c"idxType"))
    if(119233 call _cond_test(119229 call == step[119216] 1))
    {
      (119226 return r[119213])
    }
    if(119312 call _cond_test(119306 call == step[119216](119309 call - 1)))
    {
      (119238 return(119302 IfExpr (119243 call(119240 call . r[119213] c"hasParamStrideAltvalAld")) then
      { scopeless
        (119244 'new'(119246 call range[240](?)(119248 call . r[119213] c"idxType")(119252 call . r[119213] c"bounds")(119256 call chpl_strideProduct r[119213] step[119216])(119260 call . r[119213] c"_low")(119264 call . r[119213] c"_high") none[48] none[48]))
      } else
      { scopeless
        (119269 'new'(119271 call range[240](?)(119273 call . r[119213] c"idxType")(119277 call . r[119213] c"bounds")(119281 call chpl_strideProduct r[119213] step[119216])(119285 call . r[119213] c"_low")(119289 call . r[119213] c"_high")(119292 call -(119295 call . r[119213] c"_stride"))(119299 call . r[119213] c"_alignment")))
      } ))
    }
    (119317 return(119319 call chpl_by_help r[119213] step[119216](119323 call chpl_strideProduct r[119213] step[119216])))
  }
  function chpl_by[119328](arg r[119330]:_any[141](?), arg step[119332]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator" "no return value for void"
  {
    (119336 call compilerError "cannot apply 'by' to '"(119340 call :(119343 'typeof' r[119330]) string[244]) "'")
  }
  function chpl_align[119348](arg r[119358] :
  (119351 call range[240](?) unknown i[119352] unknown b[119354] unknown s[119356]), arg algn[119362] :
  i[119352]) : _unknown[42] "inline" "operator"
  {
    (119366 return(119367 'new'(119369 call range[240](?)(119371 call . r[119358] c"idxType")(119375 call . r[119358] c"bounds")(119379 call . r[119358] c"strides")(119383 call . r[119358] c"_low")(119387 call . r[119358] c"_high")(119391 call . r[119358] c"_stride")(119395 call chpl__idxToInt algn[119362]) 1)))
  }
  function chpl_align[119400](arg r[119410] :
  (119403 call range[240](?) unknown i[119404] unknown b[119406] unknown s[119408]), arg algn[119413]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator" "no return value for void"
  {
    (119417 call compilerError "can't align a range with idxType "(119421 call : i[119404] string[244]) " using a value of type "(119428 call :(119431 'typeof' algn[119413]) string[244]))
  }
  function chpl_align[119435](arg r[119437]:_any[141](?), arg algn[119439]:_any[141](?)) : _unknown[42] "inline" "last resort" "operator" "no return value for void"
  {
    (119443 call compilerError "cannot apply 'align' to '"(119447 call :(119450 'typeof' r[119437]) string[244]) "'")
  }
  function range[240](?).offset[119455](arg _mt[119465]:_MT[201], arg this[119458]:range[240](?) :
  range[240](?), in arg offset[119462] :
  integral[159](?)) : _unknown[42] "method" "@unstable"
  {
    if(119477 call _cond_test(119475 call chpl__singleValIdxType(428007 call . this[119458] c"idxType")))
    {
      (119470 call compilerError "can't apply '.offset()' to a range whose 'idxType' only has one value")
    }
    unknown offs[119482](119487 call(119484 call . offset[119462] c"safeCast")(428011 call . this[119458] c"chpl_integralIdxType"))
    (119490 'end of statement')
    if(119523 call _cond_test(119522 call(428016 call . this[119458] c"hasUnitStride")))
    {
      if(119511 call _cond_test(119504 call !(119510 call(119507 call . this[119458] c"hasLowBound"))))
      {
        (119493 call compilerError "can't invoke 'offset' on an unstrided range with no low bound")
      }
      {
        (119499 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
      }
      (119517 call = offs[119482] 0)
    }
    if(119543 call _cond_test(119536 call && 1(119539 call !(119542 call(428021 call . this[119458] c"hasFirst")))))
    {
      (119531 call boundsCheckHalt module=[222] HaltWrappers[518] "invoking 'offset' on a range without a first index")
      (401941 'referenced modules list' HaltWrappers[518])
    }
    (119548 return(119549 'new'(119551 call range[240](?)(428027 call . this[119458] c"idxType")(428032 call . this[119458] c"bounds")(428037 call . this[119458] c"strides")(428042 call . this[119458] c"_low")(428047 call . this[119458] c"_high")(428051 call . this[119458] c"stride")(119558 call +(119561 call . this[119458] c"firstAsInt") offs[119482]) 1)))
  }
  function range[240](?).this[119568](arg _mt[119580]:_MT[201], const arg this[119571]:range[240](?) :
  range[240](?), arg other[119577] :
  (119575 call range[240](?) ?[227])) : _unknown[42] "method"
  {
    if(119601 call _cond_test(119594 call !(119600 call(119597 call . this[119571] c"isAligned"))))
    {
      (119589 call unimplementedFeatureHalt module=[222] HaltWrappers[518] "slicing of an unaligned range")
      (401948 'referenced modules list' HaltWrappers[518])
    }
    unknown newBoundKind[119607] "param"(119609 call computeBoundedType this[119571] other[119577])
    (119613 'end of statement')
    function computeBoundedType[119614](arg r1[119616]:_any[141](?), arg r2[119618]:_any[141](?)) param : _unknown[42]
    {
      unknown low[119622] "param"(119623 call ||(119629 call(119626 call . r1[119616] c"hasLowBound"))(119634 call(119631 call . r2[119618] c"hasLowBound")))
      (119636 'end of statement')
      unknown high[119638] "param"(119639 call ||(119645 call(119642 call . r1[119616] c"hasHighBound"))(119650 call(119647 call . r2[119618] c"hasHighBound")))
      (119652 'end of statement')
      if(119695 call _cond_test(119691 call && low[119622] high[119638]))
      {
        (119653 return both[107114])
      }
      {
        if(119685 call _cond_test low[119622])
        {
          (119659 return low[107116])
        }
        {
          if(119678 call _cond_test high[119638])
          {
            (119665 return high[107118])
          }
          {
            (119671 return neither[107120])
          }
        }
      }
    }
    if(119756 call _cond_test(119725 call &&(119727 call &&(119729 call != newBoundKind[119607] both[107114])(119736 call !(119745 call(119742 call .(119739 call . this[119571] c"strides") c"isPosNegOne"))))(119746 call !(119755 call(119752 call .(119749 call . other[119577] c"strides") c"isPosNegOne")))))
    {
      (119704 call compilerWarning "slicing a "(119708 call :(119711 'typeof' this[119571]) string[244]) " with a "(119716 call :(119719 'typeof' other[119577]) string[244]) " might produce an empty range and result in a halt")
    }
    unknown lo1[119762](119773 IfExpr (119764 call(428066 call . this[119571] c"hasLowBound")) then
    { scopeless
      (119766 call . this[119571] c"_low")
    } else
    { scopeless
      (119770 call . other[119577] c"_low")
    } )
    (119777 'end of statement')
    unknown hi1[119779](119790 IfExpr (119781 call(428070 call . this[119571] c"hasHighBound")) then
    { scopeless
      (119783 call . this[119571] c"_high")
    } else
    { scopeless
      (119787 call . other[119577] c"_high")
    } )
    (119794 'end of statement')
    unknown st1[119796](119798 call abs(119800 call . this[119571] c"stride"))
    (119804 'end of statement')
    unknown lo2[119806](119820 IfExpr (119811 call(119808 call . other[119577] c"hasLowBound")) then
    { scopeless
      (119813 call . other[119577] c"_low")
    } else
    { scopeless
      (119817 call . this[119571] c"_low")
    } )
    (119824 'end of statement')
    unknown hi2[119826](119840 IfExpr (119831 call(119828 call . other[119577] c"hasHighBound")) then
    { scopeless
      (119833 call . other[119577] c"_high")
    } else
    { scopeless
      (119837 call . this[119571] c"_high")
    } )
    (119844 'end of statement')
    unknown st2[119846](119848 call abs(119850 call . other[119577] c"stride"))
    (119854 'end of statement')
    if(119873 call _cond_test(119871 call isUintType(428076 call . this[119571] c"chpl_integralIdxType")))
    {
      if(119865 call _cond_test(119861 call < lo1[119762] 0))
      {
        (119856 call = lo1[119762] 0)
      }
    }
    unknown emptyIntersection[119878] bool[19]
    (119881 'end of statement')
    function myMin[119882](arg x[119885] :
    int(64)[10], arg y[119889] :
    uint(64)[86]) : _unknown[42]
    {
      if(119902 call _cond_test(119896 call > y[119889](119900 call max int(64)[10])))
      {
        (119894 return x[119885])
      }
      (119906 return(119908 call min x[119885](119910 call : y[119889] int(64)[10])))
    }
    function myMin[119916](arg x[119919] :
    uint(64)[86], arg y[119923] :
    int(64)[10]) : _unknown[42]
    {
      if(119938 call _cond_test(119934 call < y[119923] 0))
      {
        (119928 call = emptyIntersection[119878] 1)
        (119932 return x[119919])
      }
      (119942 return(119944 call min x[119919](119946 call : y[119923] uint(64)[86])))
    }
    function myMin[119952](arg x[119955] :
    int(64)[10], arg y[119959] :
    int(64)[10]) : _unknown[42]
    {
      (119963 return(119965 call min x[119955] y[119959]))
    }
    function myMin[119970](arg x[119973] :
    uint(64)[86], arg y[119977] :
    uint(64)[86]) : _unknown[42]
    {
      (119981 return(119983 call min x[119973] y[119977]))
    }
    function myMax[119988](arg x[119991] :
    int(64)[10], arg y[119995] :
    uint(64)[86]) : _unknown[42]
    {
      if(120012 call _cond_test(120006 call > y[119995](120010 call max int(64)[10])))
      {
        (120000 call = emptyIntersection[119878] 1)
        (120004 return x[119991])
      }
      (120016 return(120018 call max x[119991](120020 call : y[119995] int(64)[10])))
    }
    function myMax[120026](arg x[120029] :
    uint(64)[86], arg y[120033] :
    int(64)[10]) : _unknown[42]
    {
      if(120044 call _cond_test(120040 call < y[120033] 0))
      {
        (120038 return x[120029])
      }
      (120048 return(120050 call max x[120029](120052 call : y[120033] uint(64)[86])))
    }
    function myMax[120058](arg x[120061] :
    int(64)[10], arg y[120065] :
    int(64)[10]) : _unknown[42]
    {
      (120069 return(120071 call max x[120061] y[120065]))
    }
    function myMax[120076](arg x[120079] :
    uint(64)[86], arg y[120083] :
    uint(64)[86]) : _unknown[42]
    {
      (120087 return(120089 call max x[120079] y[120083]))
    }
    (120094 call = emptyIntersection[119878] 0)
    unknown newlo[120099](120100 call :(120103 call myMax lo1[119762] lo2[119806])(428110 call . this[119571] c"chpl_integralIdxType"))
    (120108 'end of statement')
    unknown newhi[120110](120111 call :(120114 call myMin hi1[119779] hi2[119826])(428116 call . this[119571] c"chpl_integralIdxType"))
    (120119 'end of statement')
    if(120136 call _cond_test emptyIntersection[119878])
    {
      (120121 call = newlo[120099](120125 call chpl__defaultLowBound(428122 call . this[119571] c"idxType") newBoundKind[119607]))
      (120128 call = newhi[120110](120132 call chpl__defaultHighBound(428129 call . this[119571] c"idxType") newBoundKind[119607]))
    }
    unknown newStrideKind[120141] "param"(120143 call chpl_strideProduct this[119571] other[119577])
    (120147 'end of statement')
    unknown newStride[120154] st1[119796]
    unknown newAbsStride[120150] st1[119796]
    (120157 'end of statement')
    unknown type_tmp[120165] "temp" "type variable"(428139 call . this[119571] c"strType")
    unknown gcd[120164] type_tmp[120165]
    unknown x[120160] type_tmp[120165]
    (120170 'end of statement')
    if(120281 call _cond_test(120274 call !(120280 call(120277 call . newStrideKind[120141] c"isPosNegOne"))))
    {
      if(120207 call _cond_test(120203 call == st1[119796] st2[119846]))
      {
        (120173 call = gcd[120164] st1[119796])
      }
      {
        (120187 call =(120181 call _build_tuple gcd[120164] x[120160])(120184 call chpl__extendedEuclid st1[119796] st2[119846]))
        (120189 call = newStride[120154](120192 call *(120194 call / st1[119796] gcd[120164]) st2[119846]))
        (120199 call = newAbsStride[120150] newStride[120154])
      }
      if(120244 call _cond_test(120218 call ||(120220 call &&(120226 call(120223 call . this[119571] c"hasPositiveStride"))(120231 call(120228 call . other[119577] c"hasNegativeStride")))(120232 call &&(120238 call(120235 call . this[119571] c"hasNegativeStride"))(120243 call(120240 call . other[119577] c"hasPositiveStride")))))
      {
        (120211 call = newStride[120154](120214 call - newStride[120154]))
      }
    }
    {
      (120251 call compilerAssert(120256 call(120253 call . this[119571] c"hasPosNegUnitStride")))
      if(120269 call _cond_test(120268 call(120265 call . newStrideKind[120141] c"isNegOne")))
      {
        (120257 call = newStride[120154](120260 call - 1))
      }
    }
    unknown result[120286](120287 'new'(120289 call range[240](?)(428162 call . this[119571] c"idxType") newBoundKind[119607] newStrideKind[120141] newlo[120099] newhi[120110] newStride[120154](120296 call : 0(428171 call . this[119571] c"strType"))))
    (120301 'end of statement')
    if(120732 call _cond_test(120719 call &&(120721 call !(120727 call(120724 call . newStrideKind[120141] c"isPosNegOne")))(120728 call > newAbsStride[120150] 1)))
    {
      unknown al1[120304](120305 call :(120308 call chpl__idxToInt(120310 call . this[119571] c"alignment")) int(64)[10])
      (120315 'end of statement')
      unknown al2[120317](120318 call :(120321 call chpl__idxToInt(120323 call . other[119577] c"alignment")) int(64)[10])
      (120328 'end of statement')
      unknown newAlignmentIsInAl2[120330] 0
      (120333 'end of statement')
      if(120487 call _cond_test(120480 call !(120486 call(120483 call . other[119577] c"isAligned"))))
      {
        (120335 call = al2[120317] al1[120304])
        if(120348 call _cond_test(120344 call < al2[120317] 0))
        {
          (120339 call += al2[120317] st1[119796])
        }
        if(120476 call _cond_test(120472 call > st2[119846] gcd[120164]))
        {
          if(120442 call _cond_test(120430 call &&(120436 call(120433 call . result[120286] c"hasLowBound"))(120441 call(120438 call . result[120286] c"hasPositiveStride"))))
          {
            if(120380 call _cond_test(120370 call ==(120372 call %(120374 call - newlo[120099] al1[120304]) st1[119796]) 0))
            {
              (120356 call = al2[120317](120359 call :(120361 call % newlo[120099] newAbsStride[120150]) int(64)[10]))
              (120366 call = newAlignmentIsInAl2[120330] 1)
            }
          }
          {
            if(120426 call _cond_test(120414 call &&(120420 call(120417 call . result[120286] c"hasHighBound"))(120425 call(120422 call . result[120286] c"hasNegativeStride"))))
            {
              if(120410 call _cond_test(120400 call ==(120402 call %(120404 call - newhi[120110] al1[120304]) st1[119796]) 0))
              {
                (120386 call = al2[120317](120389 call :(120391 call % newhi[120110] newAbsStride[120150]) int(64)[10]))
                (120396 call = newAlignmentIsInAl2[120330] 1)
              }
            }
          }
          if(120467 call _cond_test(120461 call && 0(120464 call ! newAlignmentIsInAl2[120330])))
          {
            (120448 call warning "slicing '" this[119571] "' with the unaligned range '" other[119577] "' is unstable w.r.t. the choice of alignment")
          }
        }
      }
      const g[120492] "const" gcd[120164]
      (120495 'end of statement')
      if(120714 call _cond_test newAlignmentIsInAl2[120330])
      {
        if(120506 call _cond_test(120502 call < al2[120317] 0))
        {
          (120497 call += al2[120317] newAbsStride[120150])
        }
        (120511 call =(120514 call . result[120286] c"_alignment")(120517 call : al2[120317](428205 call . this[119571] c"strType")))
      }
      {
        if(120709 call _cond_test(120699 call !=(120701 call %(120703 call - al2[120317] al1[120304]) g[120492]) 0))
        {
          if(120544 call _cond_test(120531 call && 1(120534 call !=(120537 call . result[120286] c"bounds") both[107114])))
          {
            (120526 call boundsCheckHalt module=[222] HaltWrappers[518] "could not represent range slice - it needs to be empty, but the slice type is not bounded")
            (401993 'referenced modules list' HaltWrappers[518])
          }
          (120549 call =(120552 call . result[120286] c"_low")(120556 call chpl__defaultLowBound(428211 call . this[119571] c"idxType") newBoundKind[119607]))
          (120559 call =(120562 call . result[120286] c"_high")(120566 call chpl__defaultHighBound(428217 call . this[119571] c"idxType") newBoundKind[119607]))
          (120569 call =(120572 call . result[120286] c"_alignment")(120575 call :(120590 IfExpr (120581 call(120578 call . this[119571] c"hasPositiveStride")) then
          { scopeless
            (120583 call . result[120286] c"_low")
          } else
          { scopeless
            (120587 call . result[120286] c"_high")
          } )(428222 call . this[119571] c"strType")))
        }
        {
          unknown offset[120596](120597 call *(120599 call - al2[120317] al1[120304]) x[120160])
          (120605 'end of statement')
          (120606 call =(120609 call . result[120286] c"_alignment")(120612 call +(120614 call : al1[120304](428230 call . this[119571] c"strType"))(120618 call /(120620 call *(120622 call : offset[120596](428235 call . this[119571] c"strType")) st1[119796]) g[120492])))
          if(120694 call _cond_test(120687 call <(120690 call . result[120286] c"_alignment") 0))
          {
            (120629 call +=(120632 call . result[120286] c"_alignment") newAbsStride[120150])
            if(120647 call _cond_test 1)
            {
              (120637 call assert(120638 call >=(120641 call . result[120286] c"_alignment") 0))
            }
          }
          {
            if(120683 call _cond_test(120676 call >=(120679 call . result[120286] c"_alignment") newAbsStride[120150]))
            {
              (120653 call -=(120656 call . result[120286] c"_alignment") newAbsStride[120150])
              if(120671 call _cond_test 1)
              {
                (120661 call assert(120662 call <(120665 call . result[120286] c"_alignment") newAbsStride[120150]))
              }
            }
          }
        }
      }
    }
    (120736 return result[120286])
  }
  function chpl_count_help[120740](arg r[120745] :
  (120743 call range[240](?) ?[227]), arg i[120748]:_any[141](?)) : _unknown[42] "last resort" "no return value for void"
  {
    (120762 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (120750 call ==(120753 call . r[120745] c"bounds") neither[107120])
  }
  function chpl_count_help[120769](arg r[120771]:_any[141](?), arg count[120774] :
  integral[159](?)) : _unknown[42]
  {
    if(120794 call _cond_test(120784 call && 1(120787 call !(120793 call(120790 call . r[120771] c"isAligned")))))
    {
      (120779 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
    }
    unknown resultType[120800] "type variable"(120802 call . r[120771] c"chpl_integralIdxType")
    unknown strType[120807] "type variable"(120809 call chpl__rangeStrideType resultType[120800])
    function absSameType[120812](arg r[120814]:_any[141](?), arg resultType[120816]:_any[141](?)) : _unknown[42]
    {
      if(120844 call _cond_test(120843 call(120840 call . r[120814] c"hasNegativeStride")))
      {
        (120820 return(120821 call :(120823 call -(120826 call . r[120814] c"stride")) resultType[120816]))
      }
      {
        (120831 return(120832 call :(120835 call . r[120814] c"stride") resultType[120816]))
      }
    }
    if(121018 call _cond_test(121014 call == count[120774] 0))
    {
      if(121009 call _cond_test(121008 call(121005 call . r[120771] c"hasLowBound")))
      {
        (120852 return(120853 'new'(120855 call range[240](?)(idxType =(120857 call . r[120771] c"idxType"))(bounds = both[107114])(strides =(120867 call . r[120771] c"strides"))(_low =(120872 call . r[120771] c"_low"))(_high =(120876 call -(120879 call . r[120771] c"_low")(120883 call absSameType r[120771] resultType[120800])))(_stride =(120888 call . r[120771] c"stride"))(alignmentValue =(120893 call . r[120771] c"_alignment")))))
      }
      {
        if(121000 call _cond_test(120999 call(120996 call . r[120771] c"hasHighBound")))
        {
          (120898 return(120899 'new'(120901 call range[240](?)(idxType =(120903 call . r[120771] c"idxType"))(bounds = both[107114])(strides =(120913 call . r[120771] c"strides"))(_low =(120917 call +(120920 call . r[120771] c"_high")(120924 call absSameType r[120771] resultType[120800])))(_high =(120929 call . r[120771] c"_high"))(_stride =(120934 call . r[120771] c"stride"))(alignmentValue =(120939 call . r[120771] c"_alignment")))))
        }
        {
          (120944 return(120945 'new'(120947 call range[240](?)(idxType =(120949 call . r[120771] c"idxType"))(bounds = both[107114])(strides =(120959 call . r[120771] c"strides"))(_low =(120964 call chpl__defaultLowBound(120966 call . r[120771] c"idxType") both[107114]))(_high =(120975 call chpl__defaultHighBound(120977 call . r[120771] c"idxType") both[107114]))(_stride =(120986 call . r[120771] c"stride"))(alignmentValue =(120991 call . r[120771] c"_alignment")))))
        }
      }
    }
    if(121144 call _cond_test 1)
    {
      if(121044 call _cond_test(121029 call &&(121031 call > count[120774] 0)(121035 call !(121043 call(121040 call . r[120771] c"hasFirstForIter")))))
      {
        (121024 call boundsCheckHalt "With a positive count, the range must have a first index.")
      }
      if(121070 call _cond_test(121055 call &&(121057 call < count[120774] 0)(121061 call !(121069 call(121066 call . r[120771] c"hasLastForIter")))))
      {
        (121050 call boundsCheckHalt "With a negative count, the range must have a last index.")
      }
      if(121138 call _cond_test(121106 call &&(121108 call ==(121111 call . r[120771] c"bounds") both[107114])(121118 call >(121120 call :(121123 call abs(121124 call : count[120774](121128 call chpl__maxIntTypeSameSign(121130 'typeof' count[120774])))) uint(64)[86])(121136 call(121133 call . r[120771] c"sizeAs") uint(64)[86]))))
      {
        (121076 call boundsCheckHalt(121077 call +(121079 call +(121081 call +(121083 call + "range of size "(121088 call :(121091 call . r[120771] c"size") string[244])) " is too small for counting ")(121098 call :(121101 call abs count[120774]) string[244])) " elements"))
      }
    }
    function chpl__computeTypeForCountMath[121148](arg t1[121150]:_any[141](?), arg t2[121152]:_any[141](?)) type : _unknown[42]
    {
      unknown t1i[121156] "type variable"(121158 call chpl__idxTypeToIntIdxType t1[121150])
      unknown t2i[121162] "type variable"(121164 call chpl__idxTypeToIntIdxType t2[121152])
      if(121285 call _cond_test(121281 call == t1i[121156] t2i[121162]))
      {
        (121168 return t1i[121156])
      }
      {
        if(121276 call _cond_test(121268 call &&(121271 call isInt t1i[121156])(121274 call isInt t2i[121162])))
        {
          (121171 return(121173 call int(64)[10](121175 call max(121177 call numBits t1i[121156])(121180 call numBits t2i[121162]))))
        }
        {
          if(121263 call _cond_test(121255 call &&(121258 call isUint t1i[121156])(121261 call isUint t2i[121162])))
          {
            (121183 return(121185 call uint(64)[86](121187 call max(121189 call numBits t1i[121156])(121192 call numBits t2i[121162]))))
          }
          {
            if(121250 call _cond_test(121236 call ||(121238 call ==(121241 call numBits t1i[121156]) 64)(121244 call ==(121247 call numBits t2i[121162]) 64)))
            {
              (121195 return(121197 call int(64)[10] 64))
            }
            {
              if(121232 call _cond_test(121230 call isInt t1i[121156]))
              {
                (121200 return(121202 call int(64)[10](121204 call max(121206 call numBits t1i[121156])(121208 call * 2(121212 call numBits t2i[121162])))))
              }
              {
                (121215 return(121217 call int(64)[10](121219 call max(121220 call * 2(121224 call numBits t1i[121156]))(121227 call numBits t2i[121162]))))
              }
            }
          }
        }
      }
    }
    unknown computeType[121293] "type variable"(121295 call chpl__computeTypeForCountMath resultType[120800](121298 'typeof' count[120774]))
    unknown signedComputeType[121301] "type variable"(121303 call chpl__signedType computeType[121293])
    unknown diff[121307](121308 call *(121310 call : count[120774] signedComputeType[121301])(121314 call :(121317 call . r[120771] c"stride") signedComputeType[121301]))
    (121322 'end of statement')
    unknown lo[121324](121351 IfExpr (121326 call > diff[121307] 0) then
    { scopeless
      (121331 call . r[120771] c"_low")
    } else
    { scopeless
      (121335 call chpl__add(121336 call :(121339 call . r[120771] c"_high") computeType[121293])(121343 call :(121345 call + diff[121307] 1) computeType[121293]) resultType[120800])
    } ) resultType[120800]
    (121355 'end of statement')
    unknown hi[121357](121384 IfExpr (121359 call < diff[121307] 0) then
    { scopeless
      (121364 call . r[120771] c"_high")
    } else
    { scopeless
      (121368 call chpl__add(121369 call :(121372 call . r[120771] c"_low") computeType[121293])(121376 call -(121378 call : diff[121307] computeType[121293]) 1) resultType[120800])
    } ) resultType[120800]
    (121388 'end of statement')
    if(121451 call _cond_test(121444 call !(121450 call(121447 call . r[120771] c"hasPosNegUnitStride"))))
    {
      if(121412 call _cond_test(121398 call &&(121404 call(121401 call . r[120771] c"hasLowBound"))(121405 call < lo[121324](121409 call . r[120771] c"_low"))))
      {
        (121390 call = lo[121324](121394 call . r[120771] c"_low"))
      }
      if(121439 call _cond_test(121425 call &&(121431 call(121428 call . r[120771] c"hasHighBound"))(121432 call > hi[121357](121436 call . r[120771] c"_high"))))
      {
        (121417 call = hi[121357](121421 call . r[120771] c"_high"))
      }
    }
    (121455 return(121456 'new'(121458 call range[240](?)(idxType =(121460 call . r[120771] c"idxType"))(bounds = both[107114])(strides =(121470 call . r[120771] c"strides"))(_low = lo[121324])(_high = hi[121357])(121479 call . r[120771] c"_stride")(121483 call . r[120771] c"_alignment"))))
  }
  function #[121488](arg r[121493] :
  (121491 call range[240](?) ?[227]), arg count[121497] :
  bool[19]) : _unknown[42] "operator"
  {
    (121501 return(121503 call chpl_count_help r[121493](121505 call : count[121497] int(64)[10])))
  }
  function #[121511](arg r[121516] :
  (121514 call range[240](?) ?[227]), arg count[121520] :
  integral[159](?)) : _unknown[42] "operator"
  {
    (121524 return(121526 call chpl_count_help r[121516] count[121520]))
  }
  function #[121531](arg r[121537] :
  (121534 call range[240](?) unknown i[121535]), arg count[121540]:_any[141](?)) : _unknown[42] "last resort" "operator" "no return value for void"
  {
    (121544 call compilerError "can't apply '#' to a range with idxType "(121546 call : i[121535] string[244]) " using a count of type "(121551 call :(121554 'typeof' count[121540]) string[244]))
  }
  function #[121558](arg r[121560]:_any[141](?), arg count[121562]:_any[141](?)) : _unknown[42] "last resort" "operator" "no return value for void"
  {
    (121566 call compilerError "cannot apply '#' to '"(121570 call :(121573 'typeof' r[121560]) string[244]) "'")
  }
  function chpl_checkIfRangeIterWillOverflow[121578](arg idxType[121580]:_any[141](?), arg low[121582]:_any[141](?), arg high[121584]:_any[141](?), arg stride[121586]:_any[141](?), arg first[121589] =
  low[121582], arg last[121593] =
  high[121584], arg shouldHalt[121597] =
  1) : _unknown[42]
  {
    if(121608 call _cond_test(121604 call > low[121582] high[121584]))
    {
      (121602 return 0)
    }
    unknown willOverFlow[121613] 0
    (121616 'end of statement')
    if(121762 call _cond_test(121760 call isIntType idxType[121580]))
    {
      if(121680 call _cond_test(121670 call &&(121672 call > last[121593] 0)(121676 call > stride[121586] 0)))
      {
        if(121633 call _cond_test(121624 call > stride[121586](121627 call -(121630 call max idxType[121580]) last[121593])))
        {
          (121620 call = willOverFlow[121613] 1)
        }
      }
      {
        if(121666 call _cond_test(121656 call &&(121658 call < last[121593] 0)(121662 call < stride[121586] 0)))
        {
          if(121652 call _cond_test(121643 call < stride[121586](121646 call -(121649 call min idxType[121580]) last[121593])))
          {
            (121639 call = willOverFlow[121613] 1)
          }
        }
      }
    }
    {
      if(121755 call _cond_test(121753 call isUintType idxType[121580]))
      {
        if(121738 call _cond_test(121734 call > stride[121586] 0))
        {
          if(121702 call _cond_test(121692 call <(121694 call + last[121593](121697 call : stride[121586] idxType[121580])) last[121593]))
          {
            (121688 call = willOverFlow[121613] 1)
          }
        }
        {
          if(121730 call _cond_test(121726 call < stride[121586] 0))
          {
            if(121722 call _cond_test(121712 call >(121714 call + last[121593](121717 call : stride[121586] idxType[121580])) last[121593]))
            {
              (121708 call = willOverFlow[121613] 1)
            }
          }
        }
      }
      {
        (121745 call compilerError "Iterator overflow checking is only supported " "for integral types")
      }
    }
    if(121780 call _cond_test(121776 call && willOverFlow[121613] shouldHalt[121597]))
    {
      (121772 call boundsCheckHalt module=[222] HaltWrappers[518] "Iteration over a bounded range may be incorrect due to overflow.")
      (402070 'referenced modules list' HaltWrappers[518])
    }
    (121784 return willOverFlow[121613])
  }
  function range[240](?).checkIfIterWillOverflow[121788](arg _mt[121798]:_MT[201], arg this[121791]:range[240](?) :
  range[240](?), arg shouldHalt[121795] =
  1) : _unknown[42] "method"
  {
    if(121807 call _cond_test(121805 call isFiniteIdxType(428364 call . this[121791] c"idxType")))
    {
      (121801 return 0)
    }
    (121812 return(121814 call chpl_checkIfRangeIterWillOverflow(121816 call . this[121791] c"chpl_integralIdxType")(121820 call . this[121791] c"_low")(121824 call . this[121791] c"_high")(121828 call . this[121791] c"stride")(121834 call . this[121791] c"chpl_firstAsIntForIter")(121840 call . this[121791] c"chpl_lastAsIntForIter") shouldHalt[121795]))
  }
  function chpl_direct_range_iter[121846](param arg low[121849] :
  integral[159](?), param arg high[121853] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    unknown idxType[121858] "type variable"(121860 call computeParamRangeIndexType low[121849] high[121853])
    {
      unknown _indexOfInterest[121883] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[121884] "expr temp" "temp"
      (121893 'move' _iterator[121884](121891 call _getIterator(121867 call chpl_direct_param_stride_range_iter(121868 call : low[121849] idxType[121858])(121872 call : high[121853] idxType[121858])(121876 call : 1 idxType[121858]))))
      Defer
      {
        {
          (121908 call _freeIterator _iterator[121884])
        }
      }
      { scopeless type
        (121898 'move' _indexOfInterest[121883](121895 call iteratorIndex _iterator[121884]))
      }
      ForLoop[121885]
      {
        unknown i[121864] "index var" "insert auto destroy"
        (121903 'move' i[121864] _indexOfInterest[121883])
        (121880 yield i[121864])
        label _continueLabel[121888]
        _indexOfInterest[121883]
        _iterator[121884]
      }
      label _breakLabel[121889]
    }
  }
  function chpl_direct_range_iter[121917](arg low[121922] :
  (121920 call int(64)[10] 8), arg high[121928] :
  (121926 call int(64)[10] 8)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[121947] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[121948] "expr temp" "temp"
      (121957 'move' _iterator[121948](121955 call _getIterator(121935 call chpl_direct_param_stride_range_iter low[121922] high[121928](121938 call : 1(121942 call int(64)[10] 8)))))
      Defer
      {
        {
          (121972 call _freeIterator _iterator[121948])
        }
      }
      { scopeless type
        (121962 'move' _indexOfInterest[121947](121959 call iteratorIndex _iterator[121948]))
      }
      ForLoop[121949]
      {
        unknown i[121932] "index var" "insert auto destroy"
        (121967 'move' i[121932] _indexOfInterest[121947])
        (121944 yield i[121932])
        label _continueLabel[121952]
        _indexOfInterest[121947]
        _iterator[121948]
      }
      label _breakLabel[121953]
    }
  }
  function chpl_direct_range_iter[121981](arg low[121986] :
  (121984 call int(64)[10] 16), arg high[121992] :
  (121990 call int(64)[10] 16)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122011] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122012] "expr temp" "temp"
      (122021 'move' _iterator[122012](122019 call _getIterator(121999 call chpl_direct_param_stride_range_iter low[121986] high[121992](122002 call : 1(122006 call int(64)[10] 16)))))
      Defer
      {
        {
          (122036 call _freeIterator _iterator[122012])
        }
      }
      { scopeless type
        (122026 'move' _indexOfInterest[122011](122023 call iteratorIndex _iterator[122012]))
      }
      ForLoop[122013]
      {
        unknown i[121996] "index var" "insert auto destroy"
        (122031 'move' i[121996] _indexOfInterest[122011])
        (122008 yield i[121996])
        label _continueLabel[122016]
        _indexOfInterest[122011]
        _iterator[122012]
      }
      label _breakLabel[122017]
    }
  }
  function chpl_direct_range_iter[122045](arg low[122050] :
  (122048 call int(64)[10] 32), arg high[122056] :
  (122054 call int(64)[10] 32)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122075] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122076] "expr temp" "temp"
      (122085 'move' _iterator[122076](122083 call _getIterator(122063 call chpl_direct_param_stride_range_iter low[122050] high[122056](122066 call : 1(122070 call int(64)[10] 32)))))
      Defer
      {
        {
          (122100 call _freeIterator _iterator[122076])
        }
      }
      { scopeless type
        (122090 'move' _indexOfInterest[122075](122087 call iteratorIndex _iterator[122076]))
      }
      ForLoop[122077]
      {
        unknown i[122060] "index var" "insert auto destroy"
        (122095 'move' i[122060] _indexOfInterest[122075])
        (122072 yield i[122060])
        label _continueLabel[122080]
        _indexOfInterest[122075]
        _iterator[122076]
      }
      label _breakLabel[122081]
    }
  }
  function chpl_direct_range_iter[122109](arg low[122114] :
  (122112 call int(64)[10] 64), arg high[122120] :
  (122118 call int(64)[10] 64)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122139] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122140] "expr temp" "temp"
      (122149 'move' _iterator[122140](122147 call _getIterator(122127 call chpl_direct_param_stride_range_iter low[122114] high[122120](122130 call : 1(122134 call int(64)[10] 64)))))
      Defer
      {
        {
          (122164 call _freeIterator _iterator[122140])
        }
      }
      { scopeless type
        (122154 'move' _indexOfInterest[122139](122151 call iteratorIndex _iterator[122140]))
      }
      ForLoop[122141]
      {
        unknown i[122124] "index var" "insert auto destroy"
        (122159 'move' i[122124] _indexOfInterest[122139])
        (122136 yield i[122124])
        label _continueLabel[122144]
        _indexOfInterest[122139]
        _iterator[122140]
      }
      label _breakLabel[122145]
    }
  }
  function chpl_direct_range_iter[122173](arg low[122178] :
  (122176 call uint(64)[86] 8), arg high[122184] :
  (122182 call uint(64)[86] 8)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122203] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122204] "expr temp" "temp"
      (122213 'move' _iterator[122204](122211 call _getIterator(122191 call chpl_direct_param_stride_range_iter low[122178] high[122184](122194 call : 1(122198 call uint(64)[86] 8)))))
      Defer
      {
        {
          (122228 call _freeIterator _iterator[122204])
        }
      }
      { scopeless type
        (122218 'move' _indexOfInterest[122203](122215 call iteratorIndex _iterator[122204]))
      }
      ForLoop[122205]
      {
        unknown i[122188] "index var" "insert auto destroy"
        (122223 'move' i[122188] _indexOfInterest[122203])
        (122200 yield i[122188])
        label _continueLabel[122208]
        _indexOfInterest[122203]
        _iterator[122204]
      }
      label _breakLabel[122209]
    }
  }
  function chpl_direct_range_iter[122237](arg low[122242] :
  (122240 call uint(64)[86] 16), arg high[122248] :
  (122246 call uint(64)[86] 16)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122267] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122268] "expr temp" "temp"
      (122277 'move' _iterator[122268](122275 call _getIterator(122255 call chpl_direct_param_stride_range_iter low[122242] high[122248](122258 call : 1(122262 call uint(64)[86] 16)))))
      Defer
      {
        {
          (122292 call _freeIterator _iterator[122268])
        }
      }
      { scopeless type
        (122282 'move' _indexOfInterest[122267](122279 call iteratorIndex _iterator[122268]))
      }
      ForLoop[122269]
      {
        unknown i[122252] "index var" "insert auto destroy"
        (122287 'move' i[122252] _indexOfInterest[122267])
        (122264 yield i[122252])
        label _continueLabel[122272]
        _indexOfInterest[122267]
        _iterator[122268]
      }
      label _breakLabel[122273]
    }
  }
  function chpl_direct_range_iter[122301](arg low[122306] :
  (122304 call uint(64)[86] 32), arg high[122312] :
  (122310 call uint(64)[86] 32)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122331] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122332] "expr temp" "temp"
      (122341 'move' _iterator[122332](122339 call _getIterator(122319 call chpl_direct_param_stride_range_iter low[122306] high[122312](122322 call : 1(122326 call uint(64)[86] 32)))))
      Defer
      {
        {
          (122356 call _freeIterator _iterator[122332])
        }
      }
      { scopeless type
        (122346 'move' _indexOfInterest[122331](122343 call iteratorIndex _iterator[122332]))
      }
      ForLoop[122333]
      {
        unknown i[122316] "index var" "insert auto destroy"
        (122351 'move' i[122316] _indexOfInterest[122331])
        (122328 yield i[122316])
        label _continueLabel[122336]
        _indexOfInterest[122331]
        _iterator[122332]
      }
      label _breakLabel[122337]
    }
  }
  function chpl_direct_range_iter[122365](arg low[122370] :
  (122368 call uint(64)[86] 64), arg high[122376] :
  (122374 call uint(64)[86] 64)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[122395] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122396] "expr temp" "temp"
      (122405 'move' _iterator[122396](122403 call _getIterator(122383 call chpl_direct_param_stride_range_iter low[122370] high[122376](122386 call : 1(122390 call uint(64)[86] 64)))))
      Defer
      {
        {
          (122420 call _freeIterator _iterator[122396])
        }
      }
      { scopeless type
        (122410 'move' _indexOfInterest[122395](122407 call iteratorIndex _iterator[122396]))
      }
      ForLoop[122397]
      {
        unknown i[122380] "index var" "insert auto destroy"
        (122415 'move' i[122380] _indexOfInterest[122395])
        (122392 yield i[122380])
        label _continueLabel[122400]
        _indexOfInterest[122395]
        _iterator[122396]
      }
      label _breakLabel[122401]
    }
  }
  function chpl_direct_range_iter[122429](arg low[122432] :
  enum[147](?), arg high[122436] :
  enum[147](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122441] "const"(122444 call chpl_build_bounded_range low[122432] high[122436])
    (122447 'end of statement')
    {
      unknown _indexOfInterest[122454] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122455] "expr temp" "temp"
      (122464 'move' _iterator[122455](122462 call _getIterator r[122441]))
      Defer
      {
        {
          (122479 call _freeIterator _iterator[122455])
        }
      }
      { scopeless type
        (122469 'move' _indexOfInterest[122454](122466 call iteratorIndex _iterator[122455]))
      }
      ForLoop[122456]
      {
        unknown i[122448] "index var" "insert auto destroy"
        (122474 'move' i[122448] _indexOfInterest[122454])
        (122451 yield i[122448])
        label _continueLabel[122459]
        _indexOfInterest[122454]
        _iterator[122455]
      }
      label _breakLabel[122460]
    }
  }
  function chpl_direct_range_iter[122488](arg low[122491] :
  bool[19], arg high[122495] :
  bool[19]) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122500] "const"(122503 call chpl_build_bounded_range low[122491] high[122495])
    (122506 'end of statement')
    {
      unknown _indexOfInterest[122513] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122514] "expr temp" "temp"
      (122523 'move' _iterator[122514](122521 call _getIterator r[122500]))
      Defer
      {
        {
          (122538 call _freeIterator _iterator[122514])
        }
      }
      { scopeless type
        (122528 'move' _indexOfInterest[122513](122525 call iteratorIndex _iterator[122514]))
      }
      ForLoop[122515]
      {
        unknown i[122507] "index var" "insert auto destroy"
        (122533 'move' i[122507] _indexOfInterest[122513])
        (122510 yield i[122507])
        label _continueLabel[122518]
        _indexOfInterest[122513]
        _iterator[122514]
      }
      label _breakLabel[122519]
    }
  }
  function chpl_direct_range_iter[122547](arg low[122549]:_any[141](?), arg high[122551]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (122567 call chpl_build_bounded_range low[122549] high[122551])
    (122571 call compilerError(122572 call +(122574 call +(122576 call +(122578 call + "Ranges defined using bounds of type '"(122581 call :(122584 'typeof' low[122549]) string[244])) "..")(122587 call :(122590 'typeof' high[122551]) string[244])) "' are not currently supported"))
  }
  where {
    (122553 call !(122555 call &&(122558 call chpl_isValidRangeIdxType(122560 'typeof' low[122549]))(122562 call chpl_isValidRangeIdxType(122564 'typeof' high[122551]))))
  }
  function chpl_direct_strided_range_iter[122596](param arg low[122599] :
  integral[159](?), param arg high[122603] :
  integral[159](?), arg stride[122607] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    unknown idxType[122612] "type variable"(122614 call computeParamRangeIndexType low[122599] high[122603])
    const r[122619] "const"(122620 call chpl_by(122630 call chpl_build_bounded_range(122622 call : low[122599] idxType[122612])(122626 call : high[122603] idxType[122612])) stride[122607])
    (122634 'end of statement')
    {
      unknown _indexOfInterest[122641] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122642] "expr temp" "temp"
      (122651 'move' _iterator[122642](122649 call _getIterator r[122619]))
      Defer
      {
        {
          (122666 call _freeIterator _iterator[122642])
        }
      }
      { scopeless type
        (122656 'move' _indexOfInterest[122641](122653 call iteratorIndex _iterator[122642]))
      }
      ForLoop[122643]
      {
        unknown i[122635] "index var" "insert auto destroy"
        (122661 'move' i[122635] _indexOfInterest[122641])
        (122638 yield i[122635])
        label _continueLabel[122646]
        _indexOfInterest[122641]
        _iterator[122642]
      }
      label _breakLabel[122647]
    }
  }
  function chpl_direct_strided_range_iter[122675](arg low[122680] :
  (122678 call int(64)[10] 8), arg high[122686] :
  (122684 call int(64)[10] 8), arg stride[122690] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122695] "const"(122696 call chpl_by(122700 call chpl_build_bounded_range low[122680] high[122686]) stride[122690])
    (122704 'end of statement')
    {
      unknown _indexOfInterest[122711] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122712] "expr temp" "temp"
      (122721 'move' _iterator[122712](122719 call _getIterator r[122695]))
      Defer
      {
        {
          (122736 call _freeIterator _iterator[122712])
        }
      }
      { scopeless type
        (122726 'move' _indexOfInterest[122711](122723 call iteratorIndex _iterator[122712]))
      }
      ForLoop[122713]
      {
        unknown i[122705] "index var" "insert auto destroy"
        (122731 'move' i[122705] _indexOfInterest[122711])
        (122708 yield i[122705])
        label _continueLabel[122716]
        _indexOfInterest[122711]
        _iterator[122712]
      }
      label _breakLabel[122717]
    }
  }
  function chpl_direct_strided_range_iter[122745](arg low[122750] :
  (122748 call int(64)[10] 16), arg high[122756] :
  (122754 call int(64)[10] 16), arg stride[122760] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122765] "const"(122766 call chpl_by(122770 call chpl_build_bounded_range low[122750] high[122756]) stride[122760])
    (122774 'end of statement')
    {
      unknown _indexOfInterest[122781] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122782] "expr temp" "temp"
      (122791 'move' _iterator[122782](122789 call _getIterator r[122765]))
      Defer
      {
        {
          (122806 call _freeIterator _iterator[122782])
        }
      }
      { scopeless type
        (122796 'move' _indexOfInterest[122781](122793 call iteratorIndex _iterator[122782]))
      }
      ForLoop[122783]
      {
        unknown i[122775] "index var" "insert auto destroy"
        (122801 'move' i[122775] _indexOfInterest[122781])
        (122778 yield i[122775])
        label _continueLabel[122786]
        _indexOfInterest[122781]
        _iterator[122782]
      }
      label _breakLabel[122787]
    }
  }
  function chpl_direct_strided_range_iter[122815](arg low[122820] :
  (122818 call int(64)[10] 32), arg high[122826] :
  (122824 call int(64)[10] 32), arg stride[122830] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122835] "const"(122836 call chpl_by(122840 call chpl_build_bounded_range low[122820] high[122826]) stride[122830])
    (122844 'end of statement')
    {
      unknown _indexOfInterest[122851] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122852] "expr temp" "temp"
      (122861 'move' _iterator[122852](122859 call _getIterator r[122835]))
      Defer
      {
        {
          (122876 call _freeIterator _iterator[122852])
        }
      }
      { scopeless type
        (122866 'move' _indexOfInterest[122851](122863 call iteratorIndex _iterator[122852]))
      }
      ForLoop[122853]
      {
        unknown i[122845] "index var" "insert auto destroy"
        (122871 'move' i[122845] _indexOfInterest[122851])
        (122848 yield i[122845])
        label _continueLabel[122856]
        _indexOfInterest[122851]
        _iterator[122852]
      }
      label _breakLabel[122857]
    }
  }
  function chpl_direct_strided_range_iter[122885](arg low[122890] :
  (122888 call int(64)[10] 64), arg high[122896] :
  (122894 call int(64)[10] 64), arg stride[122900] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122905] "const"(122906 call chpl_by(122910 call chpl_build_bounded_range low[122890] high[122896]) stride[122900])
    (122914 'end of statement')
    {
      unknown _indexOfInterest[122921] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122922] "expr temp" "temp"
      (122931 'move' _iterator[122922](122929 call _getIterator r[122905]))
      Defer
      {
        {
          (122946 call _freeIterator _iterator[122922])
        }
      }
      { scopeless type
        (122936 'move' _indexOfInterest[122921](122933 call iteratorIndex _iterator[122922]))
      }
      ForLoop[122923]
      {
        unknown i[122915] "index var" "insert auto destroy"
        (122941 'move' i[122915] _indexOfInterest[122921])
        (122918 yield i[122915])
        label _continueLabel[122926]
        _indexOfInterest[122921]
        _iterator[122922]
      }
      label _breakLabel[122927]
    }
  }
  function chpl_direct_strided_range_iter[122955](arg low[122960] :
  (122958 call uint(64)[86] 8), arg high[122966] :
  (122964 call uint(64)[86] 8), arg stride[122970] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[122975] "const"(122976 call chpl_by(122980 call chpl_build_bounded_range low[122960] high[122966]) stride[122970])
    (122984 'end of statement')
    {
      unknown _indexOfInterest[122991] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[122992] "expr temp" "temp"
      (123001 'move' _iterator[122992](122999 call _getIterator r[122975]))
      Defer
      {
        {
          (123016 call _freeIterator _iterator[122992])
        }
      }
      { scopeless type
        (123006 'move' _indexOfInterest[122991](123003 call iteratorIndex _iterator[122992]))
      }
      ForLoop[122993]
      {
        unknown i[122985] "index var" "insert auto destroy"
        (123011 'move' i[122985] _indexOfInterest[122991])
        (122988 yield i[122985])
        label _continueLabel[122996]
        _indexOfInterest[122991]
        _iterator[122992]
      }
      label _breakLabel[122997]
    }
  }
  function chpl_direct_strided_range_iter[123025](arg low[123030] :
  (123028 call uint(64)[86] 16), arg high[123036] :
  (123034 call uint(64)[86] 16), arg stride[123040] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[123045] "const"(123046 call chpl_by(123050 call chpl_build_bounded_range low[123030] high[123036]) stride[123040])
    (123054 'end of statement')
    {
      unknown _indexOfInterest[123061] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123062] "expr temp" "temp"
      (123071 'move' _iterator[123062](123069 call _getIterator r[123045]))
      Defer
      {
        {
          (123086 call _freeIterator _iterator[123062])
        }
      }
      { scopeless type
        (123076 'move' _indexOfInterest[123061](123073 call iteratorIndex _iterator[123062]))
      }
      ForLoop[123063]
      {
        unknown i[123055] "index var" "insert auto destroy"
        (123081 'move' i[123055] _indexOfInterest[123061])
        (123058 yield i[123055])
        label _continueLabel[123066]
        _indexOfInterest[123061]
        _iterator[123062]
      }
      label _breakLabel[123067]
    }
  }
  function chpl_direct_strided_range_iter[123095](arg low[123100] :
  (123098 call uint(64)[86] 32), arg high[123106] :
  (123104 call uint(64)[86] 32), arg stride[123110] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[123115] "const"(123116 call chpl_by(123120 call chpl_build_bounded_range low[123100] high[123106]) stride[123110])
    (123124 'end of statement')
    {
      unknown _indexOfInterest[123131] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123132] "expr temp" "temp"
      (123141 'move' _iterator[123132](123139 call _getIterator r[123115]))
      Defer
      {
        {
          (123156 call _freeIterator _iterator[123132])
        }
      }
      { scopeless type
        (123146 'move' _indexOfInterest[123131](123143 call iteratorIndex _iterator[123132]))
      }
      ForLoop[123133]
      {
        unknown i[123125] "index var" "insert auto destroy"
        (123151 'move' i[123125] _indexOfInterest[123131])
        (123128 yield i[123125])
        label _continueLabel[123136]
        _indexOfInterest[123131]
        _iterator[123132]
      }
      label _breakLabel[123137]
    }
  }
  function chpl_direct_strided_range_iter[123165](arg low[123170] :
  (123168 call uint(64)[86] 64), arg high[123176] :
  (123174 call uint(64)[86] 64), arg stride[123180] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[123185] "const"(123186 call chpl_by(123190 call chpl_build_bounded_range low[123170] high[123176]) stride[123180])
    (123194 'end of statement')
    {
      unknown _indexOfInterest[123201] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123202] "expr temp" "temp"
      (123211 'move' _iterator[123202](123209 call _getIterator r[123185]))
      Defer
      {
        {
          (123226 call _freeIterator _iterator[123202])
        }
      }
      { scopeless type
        (123216 'move' _indexOfInterest[123201](123213 call iteratorIndex _iterator[123202]))
      }
      ForLoop[123203]
      {
        unknown i[123195] "index var" "insert auto destroy"
        (123221 'move' i[123195] _indexOfInterest[123201])
        (123198 yield i[123195])
        label _continueLabel[123206]
        _indexOfInterest[123201]
        _iterator[123202]
      }
      label _breakLabel[123207]
    }
  }
  function chpl_direct_strided_range_iter[123235](arg low[123238] :
  enum[147](?), arg high[123242] :
  enum[147](?), arg stride[123246] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[123251] "const"(123252 call chpl_by(123256 call chpl_build_bounded_range low[123238] high[123242]) stride[123246])
    (123260 'end of statement')
    {
      unknown _indexOfInterest[123267] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123268] "expr temp" "temp"
      (123277 'move' _iterator[123268](123275 call _getIterator r[123251]))
      Defer
      {
        {
          (123292 call _freeIterator _iterator[123268])
        }
      }
      { scopeless type
        (123282 'move' _indexOfInterest[123267](123279 call iteratorIndex _iterator[123268]))
      }
      ForLoop[123269]
      {
        unknown i[123261] "index var" "insert auto destroy"
        (123287 'move' i[123261] _indexOfInterest[123267])
        (123264 yield i[123261])
        label _continueLabel[123272]
        _indexOfInterest[123267]
        _iterator[123268]
      }
      label _breakLabel[123273]
    }
  }
  function chpl_direct_strided_range_iter[123301](arg low[123304] :
  bool[19], arg high[123308] :
  bool[19], arg stride[123312] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[123317] "const"(123318 call chpl_by(123322 call chpl_build_bounded_range low[123304] high[123308]) stride[123312])
    (123326 'end of statement')
    {
      unknown _indexOfInterest[123333] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123334] "expr temp" "temp"
      (123343 'move' _iterator[123334](123341 call _getIterator r[123317]))
      Defer
      {
        {
          (123358 call _freeIterator _iterator[123334])
        }
      }
      { scopeless type
        (123348 'move' _indexOfInterest[123333](123345 call iteratorIndex _iterator[123334]))
      }
      ForLoop[123335]
      {
        unknown i[123327] "index var" "insert auto destroy"
        (123353 'move' i[123327] _indexOfInterest[123333])
        (123330 yield i[123327])
        label _continueLabel[123338]
        _indexOfInterest[123333]
        _iterator[123334]
      }
      label _breakLabel[123339]
    }
  }
  function chpl_direct_strided_range_iter[123367](param arg low[123370] :
  integral[159](?), param arg high[123374] :
  integral[159](?), param arg stride[123378] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123392] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123393] "expr temp" "temp"
      (123402 'move' _iterator[123393](123400 call _getIterator(123385 call chpl_direct_param_stride_range_iter low[123370] high[123374] stride[123378])))
      Defer
      {
        {
          (123417 call _freeIterator _iterator[123393])
        }
      }
      { scopeless type
        (123407 'move' _indexOfInterest[123392](123404 call iteratorIndex _iterator[123393]))
      }
      ForLoop[123394]
      {
        unknown i[123382] "index var" "insert auto destroy"
        (123412 'move' i[123382] _indexOfInterest[123392])
        (123389 yield i[123382])
        label _continueLabel[123397]
        _indexOfInterest[123392]
        _iterator[123393]
      }
      label _breakLabel[123398]
    }
  }
  function chpl_direct_strided_range_iter[123426](arg low[123431] :
  (123429 call int(64)[10] 8), arg high[123437] :
  (123435 call int(64)[10] 8), param arg stride[123441] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123455] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123456] "expr temp" "temp"
      (123465 'move' _iterator[123456](123463 call _getIterator(123448 call chpl_direct_param_stride_range_iter low[123431] high[123437] stride[123441])))
      Defer
      {
        {
          (123480 call _freeIterator _iterator[123456])
        }
      }
      { scopeless type
        (123470 'move' _indexOfInterest[123455](123467 call iteratorIndex _iterator[123456]))
      }
      ForLoop[123457]
      {
        unknown i[123445] "index var" "insert auto destroy"
        (123475 'move' i[123445] _indexOfInterest[123455])
        (123452 yield i[123445])
        label _continueLabel[123460]
        _indexOfInterest[123455]
        _iterator[123456]
      }
      label _breakLabel[123461]
    }
  }
  function chpl_direct_strided_range_iter[123489](arg low[123494] :
  (123492 call int(64)[10] 16), arg high[123500] :
  (123498 call int(64)[10] 16), param arg stride[123504] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123518] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123519] "expr temp" "temp"
      (123528 'move' _iterator[123519](123526 call _getIterator(123511 call chpl_direct_param_stride_range_iter low[123494] high[123500] stride[123504])))
      Defer
      {
        {
          (123543 call _freeIterator _iterator[123519])
        }
      }
      { scopeless type
        (123533 'move' _indexOfInterest[123518](123530 call iteratorIndex _iterator[123519]))
      }
      ForLoop[123520]
      {
        unknown i[123508] "index var" "insert auto destroy"
        (123538 'move' i[123508] _indexOfInterest[123518])
        (123515 yield i[123508])
        label _continueLabel[123523]
        _indexOfInterest[123518]
        _iterator[123519]
      }
      label _breakLabel[123524]
    }
  }
  function chpl_direct_strided_range_iter[123552](arg low[123557] :
  (123555 call int(64)[10] 32), arg high[123563] :
  (123561 call int(64)[10] 32), param arg stride[123567] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123581] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123582] "expr temp" "temp"
      (123591 'move' _iterator[123582](123589 call _getIterator(123574 call chpl_direct_param_stride_range_iter low[123557] high[123563] stride[123567])))
      Defer
      {
        {
          (123606 call _freeIterator _iterator[123582])
        }
      }
      { scopeless type
        (123596 'move' _indexOfInterest[123581](123593 call iteratorIndex _iterator[123582]))
      }
      ForLoop[123583]
      {
        unknown i[123571] "index var" "insert auto destroy"
        (123601 'move' i[123571] _indexOfInterest[123581])
        (123578 yield i[123571])
        label _continueLabel[123586]
        _indexOfInterest[123581]
        _iterator[123582]
      }
      label _breakLabel[123587]
    }
  }
  function chpl_direct_strided_range_iter[123615](arg low[123620] :
  (123618 call int(64)[10] 64), arg high[123626] :
  (123624 call int(64)[10] 64), param arg stride[123630] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123644] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123645] "expr temp" "temp"
      (123654 'move' _iterator[123645](123652 call _getIterator(123637 call chpl_direct_param_stride_range_iter low[123620] high[123626] stride[123630])))
      Defer
      {
        {
          (123669 call _freeIterator _iterator[123645])
        }
      }
      { scopeless type
        (123659 'move' _indexOfInterest[123644](123656 call iteratorIndex _iterator[123645]))
      }
      ForLoop[123646]
      {
        unknown i[123634] "index var" "insert auto destroy"
        (123664 'move' i[123634] _indexOfInterest[123644])
        (123641 yield i[123634])
        label _continueLabel[123649]
        _indexOfInterest[123644]
        _iterator[123645]
      }
      label _breakLabel[123650]
    }
  }
  function chpl_direct_strided_range_iter[123678](arg low[123683] :
  (123681 call uint(64)[86] 8), arg high[123689] :
  (123687 call uint(64)[86] 8), param arg stride[123693] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123707] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123708] "expr temp" "temp"
      (123717 'move' _iterator[123708](123715 call _getIterator(123700 call chpl_direct_param_stride_range_iter low[123683] high[123689] stride[123693])))
      Defer
      {
        {
          (123732 call _freeIterator _iterator[123708])
        }
      }
      { scopeless type
        (123722 'move' _indexOfInterest[123707](123719 call iteratorIndex _iterator[123708]))
      }
      ForLoop[123709]
      {
        unknown i[123697] "index var" "insert auto destroy"
        (123727 'move' i[123697] _indexOfInterest[123707])
        (123704 yield i[123697])
        label _continueLabel[123712]
        _indexOfInterest[123707]
        _iterator[123708]
      }
      label _breakLabel[123713]
    }
  }
  function chpl_direct_strided_range_iter[123741](arg low[123746] :
  (123744 call uint(64)[86] 16), arg high[123752] :
  (123750 call uint(64)[86] 16), param arg stride[123756] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123770] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123771] "expr temp" "temp"
      (123780 'move' _iterator[123771](123778 call _getIterator(123763 call chpl_direct_param_stride_range_iter low[123746] high[123752] stride[123756])))
      Defer
      {
        {
          (123795 call _freeIterator _iterator[123771])
        }
      }
      { scopeless type
        (123785 'move' _indexOfInterest[123770](123782 call iteratorIndex _iterator[123771]))
      }
      ForLoop[123772]
      {
        unknown i[123760] "index var" "insert auto destroy"
        (123790 'move' i[123760] _indexOfInterest[123770])
        (123767 yield i[123760])
        label _continueLabel[123775]
        _indexOfInterest[123770]
        _iterator[123771]
      }
      label _breakLabel[123776]
    }
  }
  function chpl_direct_strided_range_iter[123804](arg low[123809] :
  (123807 call uint(64)[86] 32), arg high[123815] :
  (123813 call uint(64)[86] 32), param arg stride[123819] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123833] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123834] "expr temp" "temp"
      (123843 'move' _iterator[123834](123841 call _getIterator(123826 call chpl_direct_param_stride_range_iter low[123809] high[123815] stride[123819])))
      Defer
      {
        {
          (123858 call _freeIterator _iterator[123834])
        }
      }
      { scopeless type
        (123848 'move' _indexOfInterest[123833](123845 call iteratorIndex _iterator[123834]))
      }
      ForLoop[123835]
      {
        unknown i[123823] "index var" "insert auto destroy"
        (123853 'move' i[123823] _indexOfInterest[123833])
        (123830 yield i[123823])
        label _continueLabel[123838]
        _indexOfInterest[123833]
        _iterator[123834]
      }
      label _breakLabel[123839]
    }
  }
  function chpl_direct_strided_range_iter[123867](arg low[123872] :
  (123870 call uint(64)[86] 64), arg high[123878] :
  (123876 call uint(64)[86] 64), param arg stride[123882] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[123896] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[123897] "expr temp" "temp"
      (123906 'move' _iterator[123897](123904 call _getIterator(123889 call chpl_direct_param_stride_range_iter low[123872] high[123878] stride[123882])))
      Defer
      {
        {
          (123921 call _freeIterator _iterator[123897])
        }
      }
      { scopeless type
        (123911 'move' _indexOfInterest[123896](123908 call iteratorIndex _iterator[123897]))
      }
      ForLoop[123898]
      {
        unknown i[123886] "index var" "insert auto destroy"
        (123916 'move' i[123886] _indexOfInterest[123896])
        (123893 yield i[123886])
        label _continueLabel[123901]
        _indexOfInterest[123896]
        _iterator[123897]
      }
      label _breakLabel[123902]
    }
  }
  function chpl_direct_strided_range_iter[123930](arg low[123933] :
  enum[147](?), arg high[123937] :
  enum[147](?), param arg stride[123941] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(124046 call _cond_test(124042 call == stride[123941] 1))
    {
      const r[123947] "const"(123950 call chpl_build_bounded_range low[123933] high[123937])
      (123953 'end of statement')
      {
        unknown _indexOfInterest[123960] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[123961] "expr temp" "temp"
        (123970 'move' _iterator[123961](123968 call _getIterator r[123947]))
        Defer
        {
          {
            (123985 call _freeIterator _iterator[123961])
          }
        }
        { scopeless type
          (123975 'move' _indexOfInterest[123960](123972 call iteratorIndex _iterator[123961]))
        }
        ForLoop[123962]
        {
          unknown i[123954] "index var" "insert auto destroy"
          (123980 'move' i[123954] _indexOfInterest[123960])
          (123957 yield i[123954])
          label _continueLabel[123965]
          _indexOfInterest[123960]
          _iterator[123961]
        }
        label _breakLabel[123966]
      }
    }
    {
      const r[123994] "const"(123995 call chpl_by(123999 call chpl_build_bounded_range low[123933] high[123937]) stride[123941])
      (124003 'end of statement')
      {
        unknown _indexOfInterest[124010] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124011] "expr temp" "temp"
        (124020 'move' _iterator[124011](124018 call _getIterator r[123994]))
        Defer
        {
          {
            (124035 call _freeIterator _iterator[124011])
          }
        }
        { scopeless type
          (124025 'move' _indexOfInterest[124010](124022 call iteratorIndex _iterator[124011]))
        }
        ForLoop[124012]
        {
          unknown i[124004] "index var" "insert auto destroy"
          (124030 'move' i[124004] _indexOfInterest[124010])
          (124007 yield i[124004])
          label _continueLabel[124015]
          _indexOfInterest[124010]
          _iterator[124011]
        }
        label _breakLabel[124016]
      }
    }
  }
  function chpl_direct_strided_range_iter[124052](arg low[124055] :
  bool[19], arg high[124059] :
  bool[19], param arg stride[124063] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(124168 call _cond_test(124164 call == stride[124063] 1))
    {
      const r[124069] "const"(124072 call chpl_build_bounded_range low[124055] high[124059])
      (124075 'end of statement')
      {
        unknown _indexOfInterest[124082] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124083] "expr temp" "temp"
        (124092 'move' _iterator[124083](124090 call _getIterator r[124069]))
        Defer
        {
          {
            (124107 call _freeIterator _iterator[124083])
          }
        }
        { scopeless type
          (124097 'move' _indexOfInterest[124082](124094 call iteratorIndex _iterator[124083]))
        }
        ForLoop[124084]
        {
          unknown i[124076] "index var" "insert auto destroy"
          (124102 'move' i[124076] _indexOfInterest[124082])
          (124079 yield i[124076])
          label _continueLabel[124087]
          _indexOfInterest[124082]
          _iterator[124083]
        }
        label _breakLabel[124088]
      }
    }
    {
      const r[124116] "const"(124117 call chpl_by(124121 call chpl_build_bounded_range low[124055] high[124059]) stride[124063])
      (124125 'end of statement')
      {
        unknown _indexOfInterest[124132] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[124133] "expr temp" "temp"
        (124142 'move' _iterator[124133](124140 call _getIterator r[124116]))
        Defer
        {
          {
            (124157 call _freeIterator _iterator[124133])
          }
        }
        { scopeless type
          (124147 'move' _indexOfInterest[124132](124144 call iteratorIndex _iterator[124133]))
        }
        ForLoop[124134]
        {
          unknown i[124126] "index var" "insert auto destroy"
          (124152 'move' i[124126] _indexOfInterest[124132])
          (124129 yield i[124126])
          label _continueLabel[124137]
          _indexOfInterest[124132]
          _iterator[124133]
        }
        label _breakLabel[124138]
      }
    }
  }
  function chpl_direct_strided_range_iter[124174](arg low[124179] :
  (124177 call int(64)[10] 8), arg high[124185] :
  (124183 call int(64)[10] 8), arg stride[124192] :
  (124189 call uint(64)[86] unknown w2[124190])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124206] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124207] "expr temp" "temp"
      (124216 'move' _iterator[124207](124214 call _getIterator(124199 call chpl_direct_pos_stride_range_iter low[124179] high[124185] stride[124192])))
      Defer
      {
        {
          (124231 call _freeIterator _iterator[124207])
        }
      }
      { scopeless type
        (124221 'move' _indexOfInterest[124206](124218 call iteratorIndex _iterator[124207]))
      }
      ForLoop[124208]
      {
        unknown i[124196] "index var" "insert auto destroy"
        (124226 'move' i[124196] _indexOfInterest[124206])
        (124203 yield i[124196])
        label _continueLabel[124211]
        _indexOfInterest[124206]
        _iterator[124207]
      }
      label _breakLabel[124212]
    }
  }
  function chpl_direct_strided_range_iter[124240](arg low[124245] :
  (124243 call int(64)[10] 16), arg high[124251] :
  (124249 call int(64)[10] 16), arg stride[124258] :
  (124255 call uint(64)[86] unknown w2[124256])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124272] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124273] "expr temp" "temp"
      (124282 'move' _iterator[124273](124280 call _getIterator(124265 call chpl_direct_pos_stride_range_iter low[124245] high[124251] stride[124258])))
      Defer
      {
        {
          (124297 call _freeIterator _iterator[124273])
        }
      }
      { scopeless type
        (124287 'move' _indexOfInterest[124272](124284 call iteratorIndex _iterator[124273]))
      }
      ForLoop[124274]
      {
        unknown i[124262] "index var" "insert auto destroy"
        (124292 'move' i[124262] _indexOfInterest[124272])
        (124269 yield i[124262])
        label _continueLabel[124277]
        _indexOfInterest[124272]
        _iterator[124273]
      }
      label _breakLabel[124278]
    }
  }
  function chpl_direct_strided_range_iter[124306](arg low[124311] :
  (124309 call int(64)[10] 32), arg high[124317] :
  (124315 call int(64)[10] 32), arg stride[124324] :
  (124321 call uint(64)[86] unknown w2[124322])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124338] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124339] "expr temp" "temp"
      (124348 'move' _iterator[124339](124346 call _getIterator(124331 call chpl_direct_pos_stride_range_iter low[124311] high[124317] stride[124324])))
      Defer
      {
        {
          (124363 call _freeIterator _iterator[124339])
        }
      }
      { scopeless type
        (124353 'move' _indexOfInterest[124338](124350 call iteratorIndex _iterator[124339]))
      }
      ForLoop[124340]
      {
        unknown i[124328] "index var" "insert auto destroy"
        (124358 'move' i[124328] _indexOfInterest[124338])
        (124335 yield i[124328])
        label _continueLabel[124343]
        _indexOfInterest[124338]
        _iterator[124339]
      }
      label _breakLabel[124344]
    }
  }
  function chpl_direct_strided_range_iter[124372](arg low[124377] :
  (124375 call int(64)[10] 64), arg high[124383] :
  (124381 call int(64)[10] 64), arg stride[124390] :
  (124387 call uint(64)[86] unknown w2[124388])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124404] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124405] "expr temp" "temp"
      (124414 'move' _iterator[124405](124412 call _getIterator(124397 call chpl_direct_pos_stride_range_iter low[124377] high[124383] stride[124390])))
      Defer
      {
        {
          (124429 call _freeIterator _iterator[124405])
        }
      }
      { scopeless type
        (124419 'move' _indexOfInterest[124404](124416 call iteratorIndex _iterator[124405]))
      }
      ForLoop[124406]
      {
        unknown i[124394] "index var" "insert auto destroy"
        (124424 'move' i[124394] _indexOfInterest[124404])
        (124401 yield i[124394])
        label _continueLabel[124409]
        _indexOfInterest[124404]
        _iterator[124405]
      }
      label _breakLabel[124410]
    }
  }
  function chpl_direct_strided_range_iter[124438](arg low[124443] :
  (124441 call uint(64)[86] 8), arg high[124449] :
  (124447 call uint(64)[86] 8), arg stride[124456] :
  (124453 call uint(64)[86] unknown w2[124454])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124470] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124471] "expr temp" "temp"
      (124480 'move' _iterator[124471](124478 call _getIterator(124463 call chpl_direct_pos_stride_range_iter low[124443] high[124449] stride[124456])))
      Defer
      {
        {
          (124495 call _freeIterator _iterator[124471])
        }
      }
      { scopeless type
        (124485 'move' _indexOfInterest[124470](124482 call iteratorIndex _iterator[124471]))
      }
      ForLoop[124472]
      {
        unknown i[124460] "index var" "insert auto destroy"
        (124490 'move' i[124460] _indexOfInterest[124470])
        (124467 yield i[124460])
        label _continueLabel[124475]
        _indexOfInterest[124470]
        _iterator[124471]
      }
      label _breakLabel[124476]
    }
  }
  function chpl_direct_strided_range_iter[124504](arg low[124509] :
  (124507 call uint(64)[86] 16), arg high[124515] :
  (124513 call uint(64)[86] 16), arg stride[124522] :
  (124519 call uint(64)[86] unknown w2[124520])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124536] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124537] "expr temp" "temp"
      (124546 'move' _iterator[124537](124544 call _getIterator(124529 call chpl_direct_pos_stride_range_iter low[124509] high[124515] stride[124522])))
      Defer
      {
        {
          (124561 call _freeIterator _iterator[124537])
        }
      }
      { scopeless type
        (124551 'move' _indexOfInterest[124536](124548 call iteratorIndex _iterator[124537]))
      }
      ForLoop[124538]
      {
        unknown i[124526] "index var" "insert auto destroy"
        (124556 'move' i[124526] _indexOfInterest[124536])
        (124533 yield i[124526])
        label _continueLabel[124541]
        _indexOfInterest[124536]
        _iterator[124537]
      }
      label _breakLabel[124542]
    }
  }
  function chpl_direct_strided_range_iter[124570](arg low[124575] :
  (124573 call uint(64)[86] 32), arg high[124581] :
  (124579 call uint(64)[86] 32), arg stride[124588] :
  (124585 call uint(64)[86] unknown w2[124586])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124602] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124603] "expr temp" "temp"
      (124612 'move' _iterator[124603](124610 call _getIterator(124595 call chpl_direct_pos_stride_range_iter low[124575] high[124581] stride[124588])))
      Defer
      {
        {
          (124627 call _freeIterator _iterator[124603])
        }
      }
      { scopeless type
        (124617 'move' _indexOfInterest[124602](124614 call iteratorIndex _iterator[124603]))
      }
      ForLoop[124604]
      {
        unknown i[124592] "index var" "insert auto destroy"
        (124622 'move' i[124592] _indexOfInterest[124602])
        (124599 yield i[124592])
        label _continueLabel[124607]
        _indexOfInterest[124602]
        _iterator[124603]
      }
      label _breakLabel[124608]
    }
  }
  function chpl_direct_strided_range_iter[124636](arg low[124641] :
  (124639 call uint(64)[86] 64), arg high[124647] :
  (124645 call uint(64)[86] 64), arg stride[124654] :
  (124651 call uint(64)[86] unknown w2[124652])) : _unknown[42] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[124668] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[124669] "expr temp" "temp"
      (124678 'move' _iterator[124669](124676 call _getIterator(124661 call chpl_direct_pos_stride_range_iter low[124641] high[124647] stride[124654])))
      Defer
      {
        {
          (124693 call _freeIterator _iterator[124669])
        }
      }
      { scopeless type
        (124683 'move' _indexOfInterest[124668](124680 call iteratorIndex _iterator[124669]))
      }
      ForLoop[124670]
      {
        unknown i[124658] "index var" "insert auto destroy"
        (124688 'move' i[124658] _indexOfInterest[124668])
        (124665 yield i[124658])
        label _continueLabel[124673]
        _indexOfInterest[124668]
        _iterator[124669]
      }
      label _breakLabel[124674]
    }
  }
  function chpl_direct_strided_range_iter[124702](arg low[124707] :
  (124705 call int(64)[10] 8), arg high[124713] :
  (124711 call int(64)[10] 8), arg stride[124716]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124720 call compilerError "can't apply 'by' to a range with idxType "(124724 call :(124727 call int(64)[10] 8) string[244]) " using a step of type "(124733 call :(124736 'typeof' stride[124716]) string[244]))
  }
  function chpl_direct_strided_range_iter[124740](arg low[124745] :
  (124743 call int(64)[10] 16), arg high[124751] :
  (124749 call int(64)[10] 16), arg stride[124754]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124758 call compilerError "can't apply 'by' to a range with idxType "(124760 call :(124763 call int(64)[10] 16) string[244]) " using a step of type "(124767 call :(124770 'typeof' stride[124754]) string[244]))
  }
  function chpl_direct_strided_range_iter[124774](arg low[124779] :
  (124777 call int(64)[10] 32), arg high[124785] :
  (124783 call int(64)[10] 32), arg stride[124788]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124792 call compilerError "can't apply 'by' to a range with idxType "(124794 call :(124797 call int(64)[10] 32) string[244]) " using a step of type "(124801 call :(124804 'typeof' stride[124788]) string[244]))
  }
  function chpl_direct_strided_range_iter[124808](arg low[124813] :
  (124811 call int(64)[10] 64), arg high[124819] :
  (124817 call int(64)[10] 64), arg stride[124822]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124826 call compilerError "can't apply 'by' to a range with idxType "(124828 call :(124831 call int(64)[10] 64) string[244]) " using a step of type "(124835 call :(124838 'typeof' stride[124822]) string[244]))
  }
  function chpl_direct_strided_range_iter[124842](arg low[124847] :
  (124845 call uint(64)[86] 8), arg high[124853] :
  (124851 call uint(64)[86] 8), arg stride[124856]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124860 call compilerError "can't apply 'by' to a range with idxType "(124862 call :(124865 call uint(64)[86] 8) string[244]) " using a step of type "(124869 call :(124872 'typeof' stride[124856]) string[244]))
  }
  function chpl_direct_strided_range_iter[124876](arg low[124881] :
  (124879 call uint(64)[86] 16), arg high[124887] :
  (124885 call uint(64)[86] 16), arg stride[124890]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124894 call compilerError "can't apply 'by' to a range with idxType "(124896 call :(124899 call uint(64)[86] 16) string[244]) " using a step of type "(124903 call :(124906 'typeof' stride[124890]) string[244]))
  }
  function chpl_direct_strided_range_iter[124910](arg low[124915] :
  (124913 call uint(64)[86] 32), arg high[124921] :
  (124919 call uint(64)[86] 32), arg stride[124924]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124928 call compilerError "can't apply 'by' to a range with idxType "(124930 call :(124933 call uint(64)[86] 32) string[244]) " using a step of type "(124937 call :(124940 'typeof' stride[124924]) string[244]))
  }
  function chpl_direct_strided_range_iter[124944](arg low[124949] :
  (124947 call uint(64)[86] 64), arg high[124955] :
  (124953 call uint(64)[86] 64), arg stride[124958]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (124962 call compilerError "can't apply 'by' to a range with idxType "(124964 call :(124967 call uint(64)[86] 64) string[244]) " using a step of type "(124971 call :(124974 'typeof' stride[124958]) string[244]))
  }
  function chpl_direct_strided_range_iter[124978](arg low[124980]:_any[141](?), arg high[124982]:_any[141](?), arg stride[124984]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (125000 call chpl_build_bounded_range low[124980] high[124982] stride[124984])
    if(125070 call _cond_test(125064 call ==(125067 'typeof' low[124980])(125069 'typeof' high[124982])))
    {
      (125005 call compilerError(125006 call +(125008 call +(125010 call +(125012 call + "Ranges defined using bounds of type '"(125015 call :(125018 'typeof' low[124980]) string[244])) "' and strides of type '")(125023 call :(125026 'typeof' stride[124984]) string[244])) "' are not currently supported"))
    }
    {
      (125031 call compilerError(125032 call +(125034 call +(125036 call +(125038 call +(125040 call +(125042 call + "Ranges defined using bounds of type '"(125045 call :(125048 'typeof' low[124980]) string[244])) "..")(125051 call :(125054 'typeof' high[124982]) string[244])) "' and strides of type '")(125057 call :(125060 'typeof' stride[124984]) string[244])) "' are not currently supported"))
    }
  }
  where {
    (124986 call !(124988 call &&(124991 call chpl_isValidRangeIdxType(124993 'typeof' low[124980]))(124995 call chpl_isValidRangeIdxType(124997 'typeof' high[124982]))))
  }
  function chpl_direct_counted_range_iter[125079](arg low[125085] :
  (125082 call int(64)[10] unknown w[125083]), arg count[125088]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(125118 call _cond_test(125106 call &&(125108 call !(125111 call isIntegral count[125088]))(125113 call !(125116 call isBool count[125088]))))
    {
      (125093 call compilerError "can't apply '#' to a range with idxType "(125095 call :(125098 'typeof' low[125085]) string[244]) " using a count of type "(125101 call :(125104 'typeof' count[125088]) string[244]))
    }
    {
      unknown _indexOfInterest[125131] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125132] "expr temp" "temp"
      (125141 'move' _iterator[125132](125139 call _getIterator(125125 call chpl_direct_counted_range_iter_helper low[125085] count[125088])))
      Defer
      {
        {
          (125156 call _freeIterator _iterator[125132])
        }
      }
      { scopeless type
        (125146 'move' _indexOfInterest[125131](125143 call iteratorIndex _iterator[125132]))
      }
      ForLoop[125133]
      {
        unknown i[125122] "index var" "insert auto destroy"
        (125151 'move' i[125122] _indexOfInterest[125131])
        (125128 yield i[125122])
        label _continueLabel[125136]
        _indexOfInterest[125131]
        _iterator[125132]
      }
      label _breakLabel[125137]
    }
  }
  function chpl_direct_counted_range_iter[125165](arg low[125171] :
  (125168 call uint(64)[86] unknown w[125169]), arg count[125174]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(125204 call _cond_test(125192 call &&(125194 call !(125197 call isIntegral count[125174]))(125199 call !(125202 call isBool count[125174]))))
    {
      (125179 call compilerError "can't apply '#' to a range with idxType "(125181 call :(125184 'typeof' low[125171]) string[244]) " using a count of type "(125187 call :(125190 'typeof' count[125174]) string[244]))
    }
    {
      unknown _indexOfInterest[125217] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125218] "expr temp" "temp"
      (125227 'move' _iterator[125218](125225 call _getIterator(125211 call chpl_direct_counted_range_iter_helper low[125171] count[125174])))
      Defer
      {
        {
          (125242 call _freeIterator _iterator[125218])
        }
      }
      { scopeless type
        (125232 'move' _indexOfInterest[125217](125229 call iteratorIndex _iterator[125218]))
      }
      ForLoop[125219]
      {
        unknown i[125208] "index var" "insert auto destroy"
        (125237 'move' i[125208] _indexOfInterest[125217])
        (125214 yield i[125208])
        label _continueLabel[125222]
        _indexOfInterest[125217]
        _iterator[125218]
      }
      label _breakLabel[125223]
    }
  }
  function chpl_direct_counted_range_iter[125251](arg low[125254] :
  enum[147](?), arg count[125258] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[125263] "const"(125265 call chpl_build_low_bounded_range low[125254])
    (125268 'end of statement')
    {
      unknown _indexOfInterest[125278] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125279] "expr temp" "temp"
      (125288 'move' _iterator[125279](125286 call _getIterator(125271 call # r[125263] count[125258])))
      Defer
      {
        {
          (125305 call _freeIterator _iterator[125279])
        }
      }
      { scopeless type
        (125295 'move' _indexOfInterest[125278](125292 call iteratorIndex _iterator[125279]))
      }
      ForLoop[125280]
      {
        unknown i[125269] "index var" "insert auto destroy"
        (125300 'move' i[125269] _indexOfInterest[125278])
        (125275 yield i[125269])
        label _continueLabel[125283]
        _indexOfInterest[125278]
        _iterator[125279]
      }
      label _breakLabel[125284]
    }
  }
  function chpl_direct_counted_range_iter[125314](arg low[125317] :
  bool[19], arg count[125321] :
  integral[159](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    const r[125326] "const"(125328 call chpl_build_low_bounded_range low[125317])
    (125331 'end of statement')
    {
      unknown _indexOfInterest[125341] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125342] "expr temp" "temp"
      (125351 'move' _iterator[125342](125349 call _getIterator(125334 call # r[125326] count[125321])))
      Defer
      {
        {
          (125368 call _freeIterator _iterator[125342])
        }
      }
      { scopeless type
        (125358 'move' _indexOfInterest[125341](125355 call iteratorIndex _iterator[125342]))
      }
      ForLoop[125343]
      {
        unknown i[125332] "index var" "insert auto destroy"
        (125363 'move' i[125332] _indexOfInterest[125341])
        (125338 yield i[125332])
        label _continueLabel[125346]
        _indexOfInterest[125341]
        _iterator[125342]
      }
      label _breakLabel[125347]
    }
  }
  function chpl_direct_counted_range_iter[125377](arg low[125379]:_any[141](?), arg count[125381]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    (125397 call chpl_build_low_bounded_range low[125379])
    (125400 call compilerError "can't apply '#' to a range with idxType "(125402 call :(125405 'typeof' low[125379]) string[244]) " using a count of type "(125408 call :(125411 'typeof' count[125381]) string[244]))
  }
  where {
    (125383 call !(125385 call &&(125388 call chpl_isValidRangeIdxType(125390 'typeof' low[125379]))(125392 call chpl_isValidRangeIdxType(125394 'typeof' count[125381]))))
  }
  function chpl_direct_counted_range_iter_helper[125416](arg low[125418]:_any[141](?), arg count[125420]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(125443 call _cond_test(125430 call &&(125432 call && 1(125436 call isIntType(125438 'typeof' count[125420])))(125439 call < count[125420] 0)))
    {
      (125427 call boundsCheckHalt module=[222] HaltWrappers[518] "With a negative count, the range must have a last index.")
      (402082 'referenced modules list' HaltWrappers[518])
    }
    const start[125449] "const" low[125418]
    (125452 'end of statement')
    const end[125454] "const"(125485 IfExpr (125455 call == count[125420] 0) then
    { scopeless
      (125459 call :(125461 call -(125463 call : low[125418] uint(64)[86]) 1)(125469 'typeof' low[125418]))
    } else
    { scopeless
      (125470 call :(125472 call + low[125418](125475 call -(125477 call : count[125420](125481 'typeof' low[125418])) 1))(125484 'typeof' low[125418]))
    } )
    (125489 'end of statement')
    {
      unknown _indexOfInterest[125500] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[125501] "expr temp" "temp"
      (125510 'move' _iterator[125501](125508 call _getIterator(125493 call chpl_direct_param_stride_range_iter start[125449] end[125454] 1)))
      Defer
      {
        {
          (125525 call _freeIterator _iterator[125501])
        }
      }
      { scopeless type
        (125515 'move' _indexOfInterest[125500](125512 call iteratorIndex _iterator[125501]))
      }
      ForLoop[125502]
      {
        unknown i[125490] "index var" "insert auto destroy"
        (125520 'move' i[125490] _indexOfInterest[125500])
        (125497 yield i[125490])
        label _continueLabel[125505]
        _indexOfInterest[125500]
        _iterator[125501]
      }
      label _breakLabel[125506]
    }
  }
  function chpl_direct_pos_stride_range_iter[125534](arg low[125538] :
  unknown t[125536], arg high[125541]:_any[141](?), arg stride[125543]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(125658 call _cond_test useOptimizedRangeIterators[107092])
    {
      (125548 call chpl_range_check_stride stride[125543] t[125536])
      if(125559 call _cond_test 1)
      {
        (125552 call chpl_checkIfRangeIterWillOverflow t[125536] low[125538] high[125541] stride[125543])
      }
      unknown i[125565] t[125536]
      (125568 'end of statement')
      CForLoop[125586]
      {
        {
          (125583 yield i[125565])
        }
        label _continueLabel[125602]
        {
          (125587 '=' i[125565] low[125538])
        }
        {
          (125590 '<=' i[125565] high[125541])
        }
        {
          (125593 '+=' i[125565](125596 call : stride[125543] t[125536]))
        }
      }
      label _breakLabel[125603]
    }
    {
      {
        unknown _indexOfInterest[125625] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[125626] "expr temp" "temp"
        (125635 'move' _iterator[125626](125633 call _getIterator(125621 call(125618 call .(125609 call chpl_by(125613 call chpl_build_bounded_range low[125538] high[125541]) stride[125543]) c"generalIterator"))))
        Defer
        {
          {
            (125650 call _freeIterator _iterator[125626])
          }
        }
        { scopeless type
          (125640 'move' _indexOfInterest[125625](125637 call iteratorIndex _iterator[125626]))
        }
        ForLoop[125627]
        {
          unknown i[125607] "index var" "insert auto destroy"
          (125645 'move' i[125607] _indexOfInterest[125625])
          (125622 yield i[125607])
          label _continueLabel[125630]
          _indexOfInterest[125625]
          _iterator[125626]
        }
        label _breakLabel[125631]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[125664](arg low[125668] :
  unknown t[125666], arg high[125671]:_any[141](?), param arg stride[125673]:_any[141](?)) : _unknown[42] "iterator fn" "no return value for void"
  {
    if(125857 call _cond_test useOptimizedRangeIterators[107092])
    {
      (125678 call chpl_range_check_stride stride[125673] t[125666])
      unknown i[125682] t[125666]
      (125685 'end of statement')
      if(125802 call _cond_test(125798 call > stride[125673] 0))
      {
        if(125695 call _cond_test 1)
        {
          (125688 call chpl_checkIfRangeIterWillOverflow t[125666] low[125668] high[125671] stride[125673])
        }
        CForLoop[125717]
        {
          {
            (125714 yield i[125682])
          }
          label _continueLabel[125733]
          {
            (125718 '=' i[125682] low[125668])
          }
          {
            (125721 '<=' i[125682] high[125671])
          }
          {
            (125724 '+=' i[125682](125727 call : stride[125673] t[125666]))
          }
        }
        label _breakLabel[125734]
      }
      {
        if(125794 call _cond_test(125790 call < stride[125673] 0))
        {
          if(125748 call _cond_test 1)
          {
            (125739 call chpl_checkIfRangeIterWillOverflow t[125666] low[125668] high[125671] stride[125673] high[125671] low[125668])
          }
          CForLoop[125770]
          {
            {
              (125767 yield i[125682])
            }
            label _continueLabel[125786]
            {
              (125771 '=' i[125682] high[125671])
            }
            {
              (125774 '>=' i[125682] low[125668])
            }
            {
              (125777 '+=' i[125682](125780 call : stride[125673] t[125666]))
            }
          }
          label _breakLabel[125787]
        }
      }
    }
    {
      {
        unknown _indexOfInterest[125824] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[125825] "expr temp" "temp"
        (125834 'move' _iterator[125825](125832 call _getIterator(125820 call(125817 call .(125810 call chpl_by(125814 call chpl_build_bounded_range low[125668] high[125671]) stride[125673]) c"generalIterator"))))
        Defer
        {
          {
            (125849 call _freeIterator _iterator[125825])
          }
        }
        { scopeless type
          (125839 'move' _indexOfInterest[125824](125836 call iteratorIndex _iterator[125825]))
        }
        ForLoop[125826]
        {
          unknown i[125808] "index var" "insert auto destroy"
          (125844 'move' i[125808] _indexOfInterest[125824])
          (125821 yield i[125808])
          label _continueLabel[125829]
          _indexOfInterest[125824]
          _iterator[125825]
        }
        label _breakLabel[125830]
      }
    }
  }
  function range[240](?).these[125863](arg _mt[125869]:_MT[201], arg this[125866]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    (125886 call compilerError "iteration over a range with no bounds")
  }
  where {
    (125872 call &&(125874 call !(125877 call hasLowBoundForIter this[125866]))(125879 call !(125882 call hasHighBoundForIter this[125866])))
  }
  { scopeless type
    nothing[7]
  }
  function boundsCheckUnboundedRange[125894](arg r[125899] :
  (125897 call range[240](?) ?[227])) : _unknown[42] "inline" "private" "no return value for void"
  {
    if(125943 call _cond_test 1)
    {
      if(125920 call _cond_test(125913 call !(125919 call(125916 call . r[125899] c"hasFirstForIter"))))
      {
        (125908 call boundsCheckHalt module=[222] HaltWrappers[518] "iteration over range that has no first index")
        (402088 'referenced modules list' HaltWrappers[518])
      }
      if(125937 call _cond_test(125935 call hasAmbiguousAlignmentForIter r[125899]))
      {
        (125929 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
        (402095 'referenced modules list' HaltWrappers[518])
      }
    }
  }
  function range[240](?).these[125949](arg _mt[125955]:_MT[201], arg this[125952]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    (125969 call boundsCheckUnboundedRange this[125952])
    if(125982 call _cond_test(125981 call(125978 call .(402102 call . this[125952] c"strides") c"isNegative")))
    {
      (125972 call compilerError "iteration over a range with no first index")
    }
    unknown i[125988](428735 call . this[125952] c"chpl_integralIdxType")
    (125991 'end of statement')
    const start[125993] "const"(125995 call chpl__idxToInt(125997 call . this[125952] c"first"))
    (126001 'end of statement')
    const end[126003] "const"(126004 call -(126007 call max(428739 call . this[125952] c"chpl_integralIdxType"))(126009 call :(428743 call . this[125952] c"stride")(428747 call . this[125952] c"chpl_integralIdxType")))
    (126014 'end of statement')
    CForLoop[126034]
    {
      {
        (126029 yield(126031 call(428751 call . this[125952] c"chpl_intToIdx") i[125988]))
      }
      label _continueLabel[126050]
      {
        (126035 '=' i[125988] start[125993])
      }
      {
        (126038 '<=' i[125988] end[126003])
      }
      {
        (126041 '+=' i[125988](126044 call :(428761 call . this[125952] c"stride")(428765 call . this[125952] c"chpl_integralIdxType")))
      }
    }
    label _breakLabel[126051]
    if(126073 call _cond_test(126069 call > i[125988] end[126003]))
    {
      if(126064 call _cond_test(126062 call isIntegralType(428770 call . this[125952] c"idxType")))
      {
        (126056 call halt "Loop over unbounded range surpassed representable values")
      }
    }
  }
  where {
    (125957 call &&(125960 call hasLowBoundForIter this[125952])(125962 call !(125965 call hasHighBoundForIter this[125952])))
  }
  function range[240](?).these[126080](arg _mt[126086]:_MT[201], arg this[126083]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    (126100 call boundsCheckUnboundedRange this[126083])
    if(126111 call _cond_test(126110 call(126107 call .(402108 call . this[126083] c"strides") c"isPositive")))
    {
      (126103 call compilerError "iteration over a range with no first index")
    }
    unknown i[126117](428779 call . this[126083] c"chpl_integralIdxType")
    (126120 'end of statement')
    const start[126122] "const"(126124 call chpl__idxToInt(126126 call . this[126083] c"first"))
    (126130 'end of statement')
    const end[126132] "const"(126133 call -(126136 call min(428783 call . this[126083] c"chpl_integralIdxType"))(126138 call :(428787 call . this[126083] c"stride")(428791 call . this[126083] c"chpl_integralIdxType")))
    (126143 'end of statement')
    CForLoop[126163]
    {
      {
        (126158 yield(126160 call(428795 call . this[126083] c"chpl_intToIdx") i[126117]))
      }
      label _continueLabel[126179]
      {
        (126164 '=' i[126117] start[126122])
      }
      {
        (126167 '>=' i[126117] end[126132])
      }
      {
        (126170 '+=' i[126117](126173 call :(428805 call . this[126083] c"stride")(428809 call . this[126083] c"chpl_integralIdxType")))
      }
    }
    label _breakLabel[126180]
    if(126200 call _cond_test(126196 call < i[126117] end[126132]))
    {
      if(126191 call _cond_test(126189 call isIntegralType(428814 call . this[126083] c"idxType")))
      {
        (126185 call halt "Loop over unbounded range surpassed representable values")
      }
    }
  }
  where {
    (126088 call &&(126090 call !(126093 call hasLowBoundForIter this[126083]))(126096 call hasHighBoundForIter this[126083]))
  }
  function range[240](?).these[126207](arg _mt[126213]:_MT[201], arg this[126210]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    if(126245 call _cond_test(126243 call chpl__singleValIdxType(428837 call . this[126210] c"idxType")))
    {
      if(126237 call _cond_test(126233 call >(428827 call . this[126210] c"_low")(428832 call . this[126210] c"_high")))
      {
        (126231 return _void[46])
      }
    }
    if(126394 call _cond_test useOptimizedRangeIterators[107092])
    {
      if(126269 call _cond_test 1)
      {
        (126252 call(428843 call . this[126210] c"checkIfIterWillOverflow"))
        if(126263 call _cond_test(126261 call hasAmbiguousAlignmentForIter this[126210]))
        {
          (126257 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
          (402113 'referenced modules list' HaltWrappers[518])
        }
      }
      unknown i[126274](428849 call . this[126210] c"chpl_integralIdxType")
      (126277 'end of statement')
      const start[126279] "const"(428853 call . this[126210] c"chpl_firstAsIntForIter")
      (126282 'end of statement')
      const end[126284] "const"(126304 IfExpr (126286 call >(126289 call . this[126210] c"_low")(126293 call . this[126210] c"_high")) then
      { scopeless
        start[126279]
      } else
      { scopeless
        (126297 call +(428862 call . this[126210] c"chpl_lastAsIntForIter")(126300 call :(428866 call . this[126210] c"stride")(428870 call . this[126210] c"chpl_integralIdxType")))
      } )(428857 call . this[126210] c"chpl_integralIdxType")
      (126308 'end of statement')
      CForLoop[126328]
      {
        {
          (126323 yield(126325 call(428874 call . this[126210] c"chpl_intToIdx") i[126274]))
        }
        label _continueLabel[126344]
        {
          (126329 '=' i[126274] start[126279])
        }
        {
          (126332 '!=' i[126274] end[126284])
        }
        {
          (126335 '+=' i[126274](126338 call :(428884 call . this[126210] c"stride")(428888 call . this[126210] c"chpl_integralIdxType")))
        }
      }
      label _breakLabel[126345]
    }
    {
      {
        unknown _indexOfInterest[126361] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[126362] "expr temp" "temp"
        (126371 'move' _iterator[126362](126369 call _getIterator(126355 call(126352 call . this[126210] c"generalIterator"))))
        Defer
        {
          {
            (126386 call _freeIterator _iterator[126362])
          }
        }
        { scopeless type
          (126376 'move' _indexOfInterest[126361](126373 call iteratorIndex _iterator[126362]))
        }
        ForLoop[126363] order-independent
        {
          unknown i[126349] "index var" "insert auto destroy"
          (126381 'move' i[126349] _indexOfInterest[126361])
          (126356 yield i[126349])
          label _continueLabel[126366]
          _indexOfInterest[126361]
          _iterator[126362]
        }
        label _breakLabel[126367]
      }
    }
  }
  where {
    (126215 call &&(126217 call &&(126220 call hasLowBoundForIter this[126210])(126223 call hasHighBoundForIter this[126210]))(126225 call !(126228 call(428822 call . this[126210] c"hasPosNegUnitStride"))))
  }
  function range[240](?).these[126401](arg _mt[126407]:_MT[201], arg this[126404]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    if(126437 call _cond_test(126435 call chpl__singleValIdxType(428911 call . this[126404] c"idxType")))
    {
      if(126429 call _cond_test(126425 call >(428901 call . this[126404] c"_low")(428906 call . this[126404] c"_high")))
      {
        (126423 return _void[46])
      }
    }
    if(126608 call _cond_test useOptimizedRangeIterators[107092])
    {
      if(126446 call _cond_test 1)
      {
        (126443 call(428915 call . this[126404] c"checkIfIterWillOverflow"))
      }
      unknown i[126452](428920 call . this[126404] c"chpl_integralIdxType")
      (126455 'end of statement')
      const start[126457] "const"(126459 call chpl__idxToInt(126461 call lowBoundForIter this[126404]))
      (126464 'end of statement')
      const end[126466] "const"(126468 call chpl__idxToInt(126470 call highBoundForIter this[126404]))
      (126473 'end of statement')
      if(126556 call _cond_test(126552 call ==(428954 call . this[126404] c"stride") 1))
      {
        CForLoop[126493]
        {
          {
            (126488 yield(126490 call(428926 call . this[126404] c"chpl_intToIdx") i[126452]))
          }
          label _continueLabel[126509]
          {
            (126494 '=' i[126452] start[126457])
          }
          {
            (126497 '<=' i[126452] end[126466])
          }
          {
            (126500 '+=' i[126452](126503 call : 1(428936 call . this[126404] c"chpl_integralIdxType")))
          }
        }
        label _breakLabel[126510]
      }
      {
        CForLoop[126532]
        {
          {
            (126527 yield(126529 call(428940 call . this[126404] c"chpl_intToIdx") i[126452]))
          }
          label _continueLabel[126548]
          {
            (126533 '=' i[126452] end[126466])
          }
          {
            (126536 '>=' i[126452] start[126457])
          }
          {
            (126539 '-=' i[126452](126542 call : 1(428950 call . this[126404] c"chpl_integralIdxType")))
          }
        }
        label _breakLabel[126549]
      }
    }
    {
      {
        unknown _indexOfInterest[126575] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[126576] "expr temp" "temp"
        (126585 'move' _iterator[126576](126583 call _getIterator(126569 call(126566 call . this[126404] c"generalIterator"))))
        Defer
        {
          {
            (126600 call _freeIterator _iterator[126576])
          }
        }
        { scopeless type
          (126590 'move' _indexOfInterest[126575](126587 call iteratorIndex _iterator[126576]))
        }
        ForLoop[126577] order-independent
        {
          unknown i[126563] "index var" "insert auto destroy"
          (126595 'move' i[126563] _indexOfInterest[126575])
          (126570 yield i[126563])
          label _continueLabel[126580]
          _indexOfInterest[126575]
          _iterator[126576]
        }
        label _breakLabel[126581]
      }
    }
  }
  where {
    (126409 call &&(126411 call &&(126414 call hasLowBoundForIter this[126404])(126417 call hasHighBoundForIter this[126404]))(126420 call(428896 call . this[126404] c"hasPosNegUnitStride")))
  }
  function range[240](?).generalIterator[126615](arg _mt[126621]:_MT[201], arg this[126618]:range[240](?) :
  range[240](?)) : _unknown[42] "iterator fn" "method" "order independent yielding loops" "no return value for void"
  {
    if(126637 call _cond_test(126631 call && 1(126635 call hasAmbiguousAlignmentForIter this[126618])))
    {
      (126628 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (402123 'referenced modules list' HaltWrappers[518])
    }
    unknown i[126643](428962 call . this[126618] c"chpl_integralIdxType")
    (126646 'end of statement')
    const start[126648] "const"(126650 call . this[126618] c"first")
    (126654 'end of statement')
    const end[126656] "const"(126672 IfExpr (126657 call >(126660 call . this[126618] c"_low")(126664 call . this[126618] c"_high")) then
    { scopeless
      start[126648]
    } else
    { scopeless
      (126669 call . this[126618] c"last")
    } )
    (126676 'end of statement')
    CForLoop[126710]
    {
      {
        (126695 yield i[126643])
        if(126704 call _cond_test(126700 call == i[126643] end[126656]))
        {
          break _breakLabel[126731] _breakLabel[126731]
        }
      }
      label _continueLabel[126730]
      {
        (126711 '=' i[126643] start[126648])
      }
      {
        (126714 '>='(126716 call highBoundForIter this[126618])(126719 call lowBoundForIter this[126618]))
      }
      {
        (126721 '+=' i[126643](126724 call :(428975 call . this[126618] c"stride")(428979 call . this[126618] c"chpl_integralIdxType")))
      }
    }
    label _breakLabel[126731]
  }
  function range[240](?).these[126736](arg _mt[126746]:_MT[201], arg this[126739]:range[240](?) :
  range[240](?), param arg tag[126743] :
  iterKind[52144]) : _unknown[42] "iterator fn" "method" "no return value for void"
  {
    if(126779 call _cond_test(126769 call !(126771 call &&(126774 call hasLowBoundForIter this[126739])(126777 call hasHighBoundForIter this[126739]))))
    {
      (126765 call compilerError "parallel iteration is not currently supported over ranges without bounds")
    }
    if(126796 call _cond_test(126790 call && 1(126794 call hasAmbiguousAlignmentForIter this[126739])))
    {
      (126788 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (402134 'referenced modules list' HaltWrappers[518])
    }
    if(126807 call _cond_test debugChapelRange[107087])
    {
      (126802 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    const len[126812] "const"(126817 call(126814 call . this[126739] c"sizeAs")(428991 call . this[126739] c"chpl_integralIdxType"))
    (126820 'end of statement')
    const numChunks[126822] "const"(126828 IfExpr (126823 'task_get_serial') then
    { scopeless
      1
    } else
    { scopeless
      (126826 call _computeNumChunks len[126812])
    } )
    (126832 'end of statement')
    if(126845 call _cond_test debugChapelRange[107087])
    {
      (126835 call chpl_debug_writeln "*** RI: length=" len[126812] " numChunks=" numChunks[126822])
    }
    {
      unknown tmpIter[387312] "expr temp" "maybe ref" "no copy" "temp"
      (387315 'move' tmpIter[387312](126851 call #(126854 call chpl_build_low_bounded_range 0) numChunks[126822]))
      unknown isBounded[387659] "maybe param" "temp"
      (387665 'move' isBounded[387659](387661 call chpl_supportsBoundedCoforall tmpIter[387312] 0))
      if isBounded[387659]
      {
        const _coforallCount[387528] "const" "end count" "temp"
        (387596 'move' _coforallCount[387528](387593 call _endCountAlloc 1))
        unknown numTasks[387529] "temp"
        (387580 'move' numTasks[387529](387576 call chpl_boundedCoforallSize tmpIter[387312] 0))
        (387571 call _upEndCount _coforallCount[387528] 1 numTasks[387529])
        (387568 call chpl_resetTaskSpawn numTasks[387529])
        unknown _indexOfInterest[387536] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[387537] "expr temp" "temp"
        (387546 'move' _iterator[387537](387544 call _getIterator tmpIter[387312]))
        Defer
        {
          {
            (387561 call _freeIterator _iterator[387537])
          }
        }
        { scopeless type
          (387551 'move' _indexOfInterest[387536](387548 call iteratorIndex _iterator[387537]))
        }
        ForLoop[387538]
        {
          unknown chunk[387319] "coforall index var" "index var" "insert auto destroy"
          (387556 'move' chunk[387319] _indexOfInterest[387536])
          {
            {
              if(387323 call _cond_test(387325 call !(387327 call(466458 call . this[126739] c"hasUnitStride"))))
              {
                const tmp[387330] "const" "temp"(387332 call _computeBlock len[126812] numChunks[126822] chunk[387319](387337 call - len[126812] 1))
                (387342 call _check_tuple_var_decl tmp[387330] 2)
                const lo[387345] "const"(387347 call tmp[387330] 0)
                const hi[387350] "const"(387352 call tmp[387330] 1)
                (387355 'end of statement')
                const mylen[387357] "const"(387359 call - hi[387350](387362 call - lo[387345] 1))
                (387366 'end of statement')
                unknown low[387368](387370 call(466468 call . this[126739] c"orderToIndex") lo[387345])
                (387373 'end of statement')
                unknown high[387375](387377 call(466473 call . this[126739] c"chpl_intToIdx")(387379 call +(387381 call :(387383 call chpl__idxToInt low[387368])(466478 call . this[126739] c"strType"))(387387 call *(466482 call . this[126739] c"stride")(387390 call :(387392 call - mylen[387357] 1)(466487 call . this[126739] c"strType")))))
                (387397 'end of statement')
                if(387399 call _cond_test(387401 call(466491 call . this[126739] c"hasNegativeStride")))
                {
                  (387405 call <=> low[387368] high[387375])
                }
                {
                  unknown _indexOfInterest[387410] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[387412] "expr temp" "temp"
                  (387414 'move' _iterator[387412](387417 call _getIterator(387419 call chpl_direct_strided_range_iter low[387368] high[387375](466499 call . this[126739] c"stride"))))
                  Defer
                  {
                    {
                      (387425 call _freeIterator _iterator[387412])
                    }
                  }
                  { scopeless type
                    (387429 'move' _indexOfInterest[387410](387432 call iteratorIndex _iterator[387412]))
                  }
                  ForLoop[387434] order-independent
                  {
                    unknown i[387437] "index var" "insert auto destroy"
                    (387439 'move' i[387437] _indexOfInterest[387410])
                    {
                      (387443 yield i[387437])
                    }
                    label _continueLabel[387445]
                    _indexOfInterest[387410]
                    _iterator[387412]
                  }
                  label _breakLabel[387447]
                }
              }
              {
                const tmp[387451] "const" "temp"(387453 call _computeBlock len[126812] numChunks[126822] chunk[387319](387458 call . this[126739] c"_high")(387462 call . this[126739] c"_low")(387466 call . this[126739] c"_low"))
                (387471 call _check_tuple_var_decl tmp[387451] 2)
                const lo[387474] "const"(387476 call tmp[387451] 0)
                const hi[387479] "const"(387481 call tmp[387451] 1)
                (387484 'end of statement')
                {
                  unknown _indexOfInterest[387486] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[387488] "expr temp" "temp"
                  (387490 'move' _iterator[387488](387493 call _getIterator(387495 call chpl_direct_range_iter lo[387474] hi[387479])))
                  Defer
                  {
                    {
                      (387500 call _freeIterator _iterator[387488])
                    }
                  }
                  { scopeless type
                    (387504 'move' _indexOfInterest[387486](387507 call iteratorIndex _iterator[387488]))
                  }
                  ForLoop[387509] order-independent
                  {
                    unknown i[387512] "index var" "insert auto destroy"
                    (387514 'move' i[387512] _indexOfInterest[387486])
                    {
                      (387518 yield(387520 call(466509 call . this[126739] c"chpl_intToIdx") i[387512]))
                    }
                    label _continueLabel[387522]
                    _indexOfInterest[387486]
                    _iterator[387488]
                  }
                  label _breakLabel[387524]
                }
              }
            }
            (387531 call _downEndCount _coforallCount[387528] nil[32])
            (387530 'coforall loop')
          }
          label _continueLabel[387541]
          _indexOfInterest[387536]
          _iterator[387537]
        }
        label _breakLabel[387542]
        Defer
        {
          {
            (387583 call _endCountFree _coforallCount[387528])
          }
        }
        (387588 call _waitEndCount _coforallCount[387528] 1 numTasks[387529])
      }
      {
        const _coforallCount[387600] "const" "end count" "temp"
        (387656 'move' _coforallCount[387600](387653 call _endCountAlloc 1))
        unknown _indexOfInterest[387608] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[387609] "expr temp" "temp"
        (387618 'move' _iterator[387609](387616 call _getIterator tmpIter[387312]))
        Defer
        {
          {
            (387633 call _freeIterator _iterator[387609])
          }
        }
        { scopeless type
          (387623 'move' _indexOfInterest[387608](387620 call iteratorIndex _iterator[387609]))
        }
        ForLoop[387610]
        {
          unknown chunk[126849] "coforall index var" "index var" "insert auto destroy"
          (387628 'move' chunk[126849] _indexOfInterest[387608])
          (387640 call _upEndCount _coforallCount[387600] 1)
          {
            {
              if(127084 call _cond_test(127080 call !(127083 call(429052 call . this[126739] c"hasUnitStride"))))
              {
                const tmp[126873] "const" "temp"(126865 call _computeBlock len[126812] numChunks[126822] chunk[126849](126869 call - len[126812] 1))
                (126880 call _check_tuple_var_decl tmp[126873] 2)
                const lo[126860] "const"(126874 call tmp[126873] 0)
                const hi[126862] "const"(126877 call tmp[126873] 1)
                (126885 'end of statement')
                const mylen[126887] "const"(126888 call - hi[126862](126891 call - lo[126860] 1))
                (126896 'end of statement')
                unknown low[126898](126900 call(429006 call . this[126739] c"orderToIndex") lo[126860])
                (126903 'end of statement')
                unknown high[126905](126907 call(429011 call . this[126739] c"chpl_intToIdx")(126908 call +(126910 call :(126913 call chpl__idxToInt low[126898])(429016 call . this[126739] c"strType"))(126916 call *(429020 call . this[126739] c"stride")(126919 call :(126921 call - mylen[126887] 1)(429025 call . this[126739] c"strType")))))
                (126927 'end of statement')
                if(126935 call _cond_test(126934 call(429031 call . this[126739] c"hasNegativeStride")))
                {
                  (126928 call <=> low[126898] high[126905])
                }
                {
                  unknown _indexOfInterest[126954] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[126955] "expr temp" "temp"
                  (126964 'move' _iterator[126955](126962 call _getIterator(126973 call chpl_direct_strided_range_iter low[126898] high[126905](429036 call . this[126739] c"stride"))))
                  Defer
                  {
                    {
                      (126988 call _freeIterator _iterator[126955])
                    }
                  }
                  { scopeless type
                    (126978 'move' _indexOfInterest[126954](126975 call iteratorIndex _iterator[126955]))
                  }
                  ForLoop[126956] order-independent
                  {
                    unknown i[126940] "index var" "insert auto destroy"
                    (126983 'move' i[126940] _indexOfInterest[126954])
                    {
                      (126950 yield i[126940])
                    }
                    label _continueLabel[126959]
                    _indexOfInterest[126954]
                    _iterator[126955]
                  }
                  label _breakLabel[126960]
                }
              }
              {
                const tmp[127018] "const" "temp"(127002 call _computeBlock len[126812] numChunks[126822] chunk[126849](127007 call . this[126739] c"_high")(127011 call . this[126739] c"_low")(127015 call . this[126739] c"_low"))
                (127025 call _check_tuple_var_decl tmp[127018] 2)
                const lo[126997] "const"(127019 call tmp[127018] 0)
                const hi[126999] "const"(127022 call tmp[127018] 1)
                (127030 'end of statement')
                {
                  unknown _indexOfInterest[127044] "an _indexOfInterest or chpl__followIdx variable" "temp"
                  unknown _iterator[127045] "expr temp" "temp"
                  (127054 'move' _iterator[127045](127052 call _getIterator(127058 call chpl_direct_range_iter lo[126997] hi[126999])))
                  Defer
                  {
                    {
                      (127073 call _freeIterator _iterator[127045])
                    }
                  }
                  { scopeless type
                    (127063 'move' _indexOfInterest[127044](127060 call iteratorIndex _iterator[127045]))
                  }
                  ForLoop[127046] order-independent
                  {
                    unknown i[127031] "index var" "insert auto destroy"
                    (127068 'move' i[127031] _indexOfInterest[127044])
                    {
                      (127038 yield(127040 call(429045 call . this[126739] c"chpl_intToIdx") i[127031]))
                    }
                    label _continueLabel[127049]
                    _indexOfInterest[127044]
                    _iterator[127045]
                  }
                  label _breakLabel[127050]
                }
              }
            }
            (387603 call _downEndCount _coforallCount[387600] nil[32])
            (387602 'coforall loop')
          }
          label _continueLabel[387613]
          _indexOfInterest[387608]
          _iterator[387609]
        }
        label _breakLabel[387614]
        Defer
        {
          {
            (387644 call _endCountFree _coforallCount[387600])
          }
        }
        (387649 call _waitEndCount _coforallCount[387600] 1)
      }
    }
  }
  where {
    (126748 call &&(126750 call == tag[126743] standalone[52142])(126759 call ! localeModelPartitionsIterationOnSublocales[306872]))
  }
  function range[240](?).these[127092](arg _mt[127102]:_MT[201], arg this[127095]:range[240](?) :
  range[240](?), param arg tag[127099] :
  iterKind[52144]) : _unknown[42] "iterator fn" "method" "no return value for void"
  {
    if(127126 call _cond_test(127116 call !(127118 call &&(127121 call hasLowBoundForIter this[127095])(127124 call hasHighBoundForIter this[127095]))))
    {
      (127113 call compilerError "parallel iteration is not currently supported over ranges without bounds")
    }
    if(127144 call _cond_test(127138 call && 1(127142 call hasAmbiguousAlignmentForIter this[127095])))
    {
      (127135 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (402145 'referenced modules list' HaltWrappers[518])
    }
    if(127156 call _cond_test debugChapelRange[107087])
    {
      (127150 call chpl_debug_writeln "*** In range leader:")
    }
    const numSublocs[127162] "const"(127169 call(127166 call .(402150 call here[135591]) c"_getChildCount"))
    (127171 'end of statement')
    if(127642 call _cond_test(127635 call && localeModelPartitionsIterationOnSublocales[306872](127638 call != numSublocs[127162] 0)))
    {
      const len[127174] "const"(127179 call(127176 call . this[127095] c"sizeAs")(429063 call . this[127095] c"chpl_integralIdxType"))
      (127182 'end of statement')
      const tasksPerLocale[127184] "const" dataParTasksPerLocale[287582]
      (127187 'end of statement')
      const ignoreRunning[127189] "const" dataParIgnoreRunningTasks[287587]
      (127192 'end of statement')
      const minIndicesPerTask[127194] "const" dataParMinGranularity[287592]
      (127197 'end of statement')
      unknown dptpl[127199](127209 IfExpr (127200 call == tasksPerLocale[127184] 0) then
      { scopeless
        (127205 call .(402153 call here[135591]) c"maxTaskPar")
      } else
      { scopeless
        tasksPerLocale[127184]
      } )
      (127213 'end of statement')
      if(127248 call _cond_test(127245 call ! ignoreRunning[127189]))
      {
        const otherTasks[127216] "const"(127217 call -(127223 call(127220 call .(402155 call here[135591]) c"runningTasks")) 1)
        (127226 'end of statement')
        (127227 call = dptpl[127199](127242 IfExpr (127230 call < otherTasks[127216] dptpl[127199]) then
        { scopeless
          (127234 call :(127236 call - dptpl[127199] otherTasks[127216]) int(64)[10])
        } else
        { scopeless
          1
        } ))
      }
      const numSublocTasks[127253] "const"(127255 call min numSublocs[127162] dptpl[127199])
      (127259 'end of statement')
      const numChunks[127261] "const"(127271 IfExpr (127262 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (127265 call _computeNumChunks numSublocTasks[127253](ignoreRunning = 1) minIndicesPerTask[127194] len[127174])
      } )
      (127275 'end of statement')
      if(127304 call _cond_test debugDataParNuma[287677])
      {
        (127278 call chpl_debug_writeln "### numSublocs = " numSublocs[127162] "\n" "### numTasksPerSubloc = " numSublocTasks[127253] "\n" "### ignoreRunning = " ignoreRunning[127189] "\n" "### minIndicesPerTask = " minIndicesPerTask[127194] "\n" "### numChunks = " numChunks[127261])
      }
      {
        unknown tmpIter[387873] "expr temp" "maybe ref" "no copy" "temp"
        (387876 'move' tmpIter[387873](127310 call #(127313 call chpl_build_low_bounded_range 0) numChunks[127261]))
        unknown isBounded[388394] "maybe param" "temp"
        (388400 'move' isBounded[388394](388396 call chpl_supportsBoundedCoforall tmpIter[387873] 0))
        if isBounded[388394]
        {
          const _coforallCount[388263] "const" "end count" "temp"
          (388331 'move' _coforallCount[388263](388328 call _endCountAlloc 1))
          unknown numTasks[388264] "temp"
          (388315 'move' numTasks[388264](388311 call chpl_boundedCoforallSize tmpIter[387873] 0))
          (388306 call _upEndCount _coforallCount[388263] 1 numTasks[388264])
          (388303 call chpl_resetTaskSpawn numTasks[388264])
          unknown _indexOfInterest[388271] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388272] "expr temp" "temp"
          (388281 'move' _iterator[388272](388279 call _getIterator tmpIter[387873]))
          Defer
          {
            {
              (388296 call _freeIterator _iterator[388272])
            }
          }
          { scopeless type
            (388286 'move' _indexOfInterest[388271](388283 call iteratorIndex _iterator[388272]))
          }
          ForLoop[388273]
          {
            unknown chunk[387880] "coforall index var" "index var" "insert auto destroy"
            (388291 'move' chunk[387880] _indexOfInterest[388271])
            {
              {
                const tmp[387887] "const" "temp"
                (387889 'move' tmp[387887](387891 'deref'(387892 '_wide_get_locale'(387897 call(387894 call .(412856 call here[135591]) c"_getChild") chunk[387880]))))
                {
                  if(387901 call _cond_test debugDataParNuma[287677])
                  {
                    if(387905 call _cond_test(387907 call != chunk[387880](387910 call chpl_getSubloc)))
                    {
                      (387914 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[387880] ", on "(387919 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[387924] "const" "temp"(387926 call _computeBlock len[127174] numChunks[127261] chunk[387880](387931 call - len[127174] 1))
                  (387936 call _check_tuple_var_decl tmp[387924] 2)
                  const lo[387939] "const"(387941 call tmp[387924] 0)
                  const hi[387944] "const"(387946 call tmp[387924] 1)
                  (387949 'end of statement')
                  const locRange[387951] "const"(387953 call chpl_build_bounded_range lo[387939] hi[387944])
                  (387957 'end of statement')
                  const locLen[387959] "const"(387964 call(387961 call . locRange[387951] c"sizeAs")(466538 call . this[127095] c"chpl_integralIdxType"))
                  (387967 'end of statement')
                  const numSublocTasks[387969] "const"(387990 IfExpr (387971 call < chunk[387880](387974 call % dptpl[127199] numChunks[127261])) then
                  { scopeless
                    (387979 call +(387981 call / dptpl[127199] numChunks[127261]) 1)
                  } else
                  { scopeless
                    (387987 call / dptpl[127199] numChunks[127261])
                  } )
                  (387992 'end of statement')
                  const numTasks[387994] "const"(387996 call _computeNumChunks numSublocTasks[387969](ignoreRunning = 1) minIndicesPerTask[127194] locLen[387959])
                  (388003 'end of statement')
                  {
                    unknown tmpIter[388005] "expr temp" "maybe ref" "no copy" "temp"
                    (388007 'move' tmpIter[388005](388010 call #(388012 call chpl_build_low_bounded_range 0) numTasks[387994]))
                    unknown isBounded[388015] "maybe param" "temp"
                    (388017 'move' isBounded[388015](388020 call chpl_supportsBoundedCoforall tmpIter[388005] 0))
                    if isBounded[388015]
                    {
                      const _coforallCount[388025] "const" "end count" "temp"
                      (388027 'move' _coforallCount[388025](388030 call _endCountAlloc 1))
                      unknown numTasks[388032] "temp"
                      (388034 'move' numTasks[388032](388037 call chpl_boundedCoforallSize tmpIter[388005] 0))
                      (388041 call _upEndCount _coforallCount[388025] 1 numTasks[388032])
                      (388046 call chpl_resetTaskSpawn numTasks[388032])
                      unknown _indexOfInterest[388048] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[388050] "expr temp" "temp"
                      (388052 'move' _iterator[388050](388055 call _getIterator tmpIter[388005]))
                      Defer
                      {
                        {
                          (388059 call _freeIterator _iterator[388050])
                        }
                      }
                      { scopeless type
                        (388063 'move' _indexOfInterest[388048](388066 call iteratorIndex _iterator[388050]))
                      }
                      ForLoop[388068]
                      {
                        unknown core[388071] "coforall index var" "index var" "insert auto destroy"
                        (388073 'move' core[388071] _indexOfInterest[388048])
                        {
                          {
                            const tmp[388080] "const" "temp"(388082 call _computeBlock locLen[387959] numTasks[387994] core[388071] hi[387944] lo[387939] lo[387939])
                            (388091 call _check_tuple_var_decl tmp[388080] 2)
                            const low[388094] "const"(388096 call tmp[388080] 0)
                            const high[388099] "const"(388101 call tmp[388080] 1)
                            (388104 'end of statement')
                            if(388106 call _cond_test debugDataParNuma[287677])
                            {
                              (388110 call chpl_debug_writeln "### chunk = " chunk[387880] "  core = " core[388071] "  " "locRange = " locRange[387951] "  coreRange = "(388120 call chpl_build_bounded_range low[388094] high[388099]))
                            }
                            (388124 yield(388126 call _build_tuple(388128 call chpl_build_bounded_range low[388094] high[388099])))
                          }
                          (388132 call _downEndCount _coforallCount[388025] nil[32])
                          (388077 'coforall loop')
                        }
                        label _continueLabel[388135]
                        _indexOfInterest[388048]
                        _iterator[388050]
                      }
                      label _breakLabel[388137]
                      Defer
                      {
                        {
                          (388141 call _endCountFree _coforallCount[388025])
                        }
                      }
                      (388145 call _waitEndCount _coforallCount[388025] 1 numTasks[388032])
                    }
                    {
                      const _coforallCount[388150] "const" "end count" "temp"
                      (388152 'move' _coforallCount[388150](388155 call _endCountAlloc 1))
                      unknown _indexOfInterest[388157] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[388159] "expr temp" "temp"
                      (388161 'move' _iterator[388159](388164 call _getIterator tmpIter[388005]))
                      Defer
                      {
                        {
                          (388168 call _freeIterator _iterator[388159])
                        }
                      }
                      { scopeless type
                        (388172 'move' _indexOfInterest[388157](388175 call iteratorIndex _iterator[388159]))
                      }
                      ForLoop[388177]
                      {
                        unknown core[388180] "coforall index var" "index var" "insert auto destroy"
                        (388182 'move' core[388180] _indexOfInterest[388157])
                        (388186 call _upEndCount _coforallCount[388150] 1)
                        {
                          {
                            const tmp[388193] "const" "temp"(388195 call _computeBlock locLen[387959] numTasks[387994] core[388180] hi[387944] lo[387939] lo[387939])
                            (388204 call _check_tuple_var_decl tmp[388193] 2)
                            const low[388207] "const"(388209 call tmp[388193] 0)
                            const high[388212] "const"(388214 call tmp[388193] 1)
                            (388217 'end of statement')
                            if(388219 call _cond_test debugDataParNuma[287677])
                            {
                              (388223 call chpl_debug_writeln "### chunk = " chunk[387880] "  core = " core[388180] "  " "locRange = " locRange[387951] "  coreRange = "(388233 call chpl_build_bounded_range low[388207] high[388212]))
                            }
                            (388237 yield(388239 call _build_tuple(388241 call chpl_build_bounded_range low[388207] high[388212])))
                          }
                          (388245 call _downEndCount _coforallCount[388150] nil[32])
                          (388190 'coforall loop')
                        }
                        label _continueLabel[388248]
                        _indexOfInterest[388157]
                        _iterator[388159]
                      }
                      label _breakLabel[388250]
                      Defer
                      {
                        {
                          (388254 call _endCountFree _coforallCount[388150])
                        }
                      }
                      (388258 call _waitEndCount _coforallCount[388150] 1)
                    }
                  }
                }
                (387884 'elided on block' 0 tmp[387887])
              }
              (388266 call _downEndCount _coforallCount[388263] nil[32])
              (388265 'coforall loop')
            }
            label _continueLabel[388276]
            _indexOfInterest[388271]
            _iterator[388272]
          }
          label _breakLabel[388277]
          Defer
          {
            {
              (388318 call _endCountFree _coforallCount[388263])
            }
          }
          (388323 call _waitEndCount _coforallCount[388263] 1 numTasks[388264])
        }
        {
          const _coforallCount[388335] "const" "end count" "temp"
          (388391 'move' _coforallCount[388335](388388 call _endCountAlloc 1))
          unknown _indexOfInterest[388343] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388344] "expr temp" "temp"
          (388353 'move' _iterator[388344](388351 call _getIterator tmpIter[387873]))
          Defer
          {
            {
              (388368 call _freeIterator _iterator[388344])
            }
          }
          { scopeless type
            (388358 'move' _indexOfInterest[388343](388355 call iteratorIndex _iterator[388344]))
          }
          ForLoop[388345]
          {
            unknown chunk[127308] "coforall index var" "index var" "insert auto destroy"
            (388363 'move' chunk[127308] _indexOfInterest[388343])
            (388375 call _upEndCount _coforallCount[388335] 1)
            {
              {
                const tmp[127515] "const" "temp"
                (127516 'move' tmp[127515](127513 'deref'(127512 '_wide_get_locale'(127323 call(127320 call .(402157 call here[135591]) c"_getChild") chunk[127308]))))
                {
                  if(127353 call _cond_test debugDataParNuma[287677])
                  {
                    if(127347 call _cond_test(127342 call != chunk[127308](127346 call chpl_getSubloc)))
                    {
                      (127328 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[127308] ", on "(127337 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[127371] "const" "temp"(127363 call _computeBlock len[127174] numChunks[127261] chunk[127308](127367 call - len[127174] 1))
                  (127378 call _check_tuple_var_decl tmp[127371] 2)
                  const lo[127358] "const"(127372 call tmp[127371] 0)
                  const hi[127360] "const"(127375 call tmp[127371] 1)
                  (127383 'end of statement')
                  const locRange[127385] "const"(127388 call chpl_build_bounded_range lo[127358] hi[127360])
                  (127391 'end of statement')
                  const locLen[127393] "const"(127398 call(127395 call . locRange[127385] c"sizeAs")(429100 call . this[127095] c"chpl_integralIdxType"))
                  (127401 'end of statement')
                  const numSublocTasks[127403] "const"(127422 IfExpr (127404 call < chunk[127308](127407 call % dptpl[127199] numChunks[127261])) then
                  { scopeless
                    (127411 call +(127413 call / dptpl[127199] numChunks[127261]) 1)
                  } else
                  { scopeless
                    (127418 call / dptpl[127199] numChunks[127261])
                  } )
                  (127426 'end of statement')
                  const numTasks[127428] "const"(127430 call _computeNumChunks numSublocTasks[127403](ignoreRunning = 1) minIndicesPerTask[127194] locLen[127393])
                  (127437 'end of statement')
                  {
                    unknown tmpIter[387669] "expr temp" "maybe ref" "no copy" "temp"
                    (387672 'move' tmpIter[387669](127440 call #(127443 call chpl_build_low_bounded_range 0) numTasks[127428]))
                    unknown isBounded[387863] "maybe param" "temp"
                    (387869 'move' isBounded[387863](387865 call chpl_supportsBoundedCoforall tmpIter[387669] 0))
                    if isBounded[387863]
                    {
                      const _coforallCount[387732] "const" "end count" "temp"
                      (387800 'move' _coforallCount[387732](387797 call _endCountAlloc 1))
                      unknown numTasks[387733] "temp"
                      (387784 'move' numTasks[387733](387780 call chpl_boundedCoforallSize tmpIter[387669] 0))
                      (387775 call _upEndCount _coforallCount[387732] 1 numTasks[387733])
                      (387772 call chpl_resetTaskSpawn numTasks[387733])
                      unknown _indexOfInterest[387740] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[387741] "expr temp" "temp"
                      (387750 'move' _iterator[387741](387748 call _getIterator tmpIter[387669]))
                      Defer
                      {
                        {
                          (387765 call _freeIterator _iterator[387741])
                        }
                      }
                      { scopeless type
                        (387755 'move' _indexOfInterest[387740](387752 call iteratorIndex _iterator[387741]))
                      }
                      ForLoop[387742]
                      {
                        unknown core[387676] "coforall index var" "index var" "insert auto destroy"
                        (387760 'move' core[387676] _indexOfInterest[387740])
                        {
                          {
                            const tmp[387680] "const" "temp"(387682 call _computeBlock locLen[127393] numTasks[127428] core[387676] hi[127360] lo[127358] lo[127358])
                            (387691 call _check_tuple_var_decl tmp[387680] 2)
                            const low[387694] "const"(387696 call tmp[387680] 0)
                            const high[387699] "const"(387701 call tmp[387680] 1)
                            (387704 'end of statement')
                            if(387706 call _cond_test debugDataParNuma[287677])
                            {
                              (387710 call chpl_debug_writeln "### chunk = " chunk[127308] "  core = " core[387676] "  " "locRange = " locRange[127385] "  coreRange = "(387720 call chpl_build_bounded_range low[387694] high[387699]))
                            }
                            (387724 yield(387726 call _build_tuple(387728 call chpl_build_bounded_range low[387694] high[387699])))
                          }
                          (387735 call _downEndCount _coforallCount[387732] nil[32])
                          (387734 'coforall loop')
                        }
                        label _continueLabel[387745]
                        _indexOfInterest[387740]
                        _iterator[387741]
                      }
                      label _breakLabel[387746]
                      Defer
                      {
                        {
                          (387787 call _endCountFree _coforallCount[387732])
                        }
                      }
                      (387792 call _waitEndCount _coforallCount[387732] 1 numTasks[387733])
                    }
                    {
                      const _coforallCount[387804] "const" "end count" "temp"
                      (387860 'move' _coforallCount[387804](387857 call _endCountAlloc 1))
                      unknown _indexOfInterest[387812] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[387813] "expr temp" "temp"
                      (387822 'move' _iterator[387813](387820 call _getIterator tmpIter[387669]))
                      Defer
                      {
                        {
                          (387837 call _freeIterator _iterator[387813])
                        }
                      }
                      { scopeless type
                        (387827 'move' _indexOfInterest[387812](387824 call iteratorIndex _iterator[387813]))
                      }
                      ForLoop[387814]
                      {
                        unknown core[127438] "coforall index var" "index var" "insert auto destroy"
                        (387832 'move' core[127438] _indexOfInterest[387812])
                        (387844 call _upEndCount _coforallCount[387804] 1)
                        {
                          {
                            const tmp[127460] "const" "temp"(127453 call _computeBlock locLen[127393] numTasks[127428] core[127438] hi[127360] lo[127358] lo[127358])
                            (127467 call _check_tuple_var_decl tmp[127460] 2)
                            const low[127448] "const"(127461 call tmp[127460] 0)
                            const high[127450] "const"(127464 call tmp[127460] 1)
                            (127472 'end of statement')
                            if(127499 call _cond_test debugDataParNuma[287677])
                            {
                              (127475 call chpl_debug_writeln "### chunk = " chunk[127308] "  core = " core[127438] "  " "locRange = " locRange[127385] "  coreRange = "(127496 call chpl_build_bounded_range low[127448] high[127450]))
                            }
                            (127503 yield(127509 call _build_tuple(127507 call chpl_build_bounded_range low[127448] high[127450])))
                          }
                          (387807 call _downEndCount _coforallCount[387804] nil[32])
                          (387806 'coforall loop')
                        }
                        label _continueLabel[387817]
                        _indexOfInterest[387812]
                        _iterator[387813]
                      }
                      label _breakLabel[387818]
                      Defer
                      {
                        {
                          (387848 call _endCountFree _coforallCount[387804])
                        }
                      }
                      (387853 call _waitEndCount _coforallCount[387804] 1)
                    }
                  }
                }
                (127519 'elided on block' 0 tmp[127515])
              }
              (388338 call _downEndCount _coforallCount[388335] nil[32])
              (388337 'coforall loop')
            }
            label _continueLabel[388348]
            _indexOfInterest[388343]
            _iterator[388344]
          }
          label _breakLabel[388349]
          Defer
          {
            {
              (388379 call _endCountFree _coforallCount[388335])
            }
          }
          (388384 call _waitEndCount _coforallCount[388335] 1)
        }
      }
    }
    {
      unknown v[127527](127534 call(127531 call . this[127095] c"chpl_sizeAsForIter")(429129 call . this[127095] c"chpl_integralIdxType"))
      (127537 'end of statement')
      const numChunks[127539] "const"(127545 IfExpr (127540 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (127543 call _computeNumChunks v[127527])
      } )
      (127549 'end of statement')
      if(127567 call _cond_test debugChapelRange[107087])
      {
        (127552 call chpl_debug_writeln "*** RI: length=" v[127527] " numChunks=" numChunks[127539])
        (127558 call chpl_debug_writeln "*** RI: Using " numChunks[127539] " chunk(s)")
      }
      {
        unknown tmpIter[388404] "expr temp" "maybe ref" "no copy" "temp"
        (388407 'move' tmpIter[388404](127573 call #(127576 call chpl_build_low_bounded_range 0) numChunks[127539]))
        unknown isBounded[388595] "maybe param" "temp"
        (388601 'move' isBounded[388595](388597 call chpl_supportsBoundedCoforall tmpIter[388404] 0))
        if isBounded[388595]
        {
          const _coforallCount[388464] "const" "end count" "temp"
          (388532 'move' _coforallCount[388464](388529 call _endCountAlloc 1))
          unknown numTasks[388465] "temp"
          (388516 'move' numTasks[388465](388512 call chpl_boundedCoforallSize tmpIter[388404] 0))
          (388507 call _upEndCount _coforallCount[388464] 1 numTasks[388465])
          (388504 call chpl_resetTaskSpawn numTasks[388465])
          unknown _indexOfInterest[388472] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388473] "expr temp" "temp"
          (388482 'move' _iterator[388473](388480 call _getIterator tmpIter[388404]))
          Defer
          {
            {
              (388497 call _freeIterator _iterator[388473])
            }
          }
          { scopeless type
            (388487 'move' _indexOfInterest[388472](388484 call iteratorIndex _iterator[388473]))
          }
          ForLoop[388474]
          {
            unknown chunk[388411] "coforall index var" "index var" "insert auto destroy"
            (388492 'move' chunk[388411] _indexOfInterest[388472])
            {
              {
                const tmp[388415] "const" "temp"(388417 call _computeBlock v[127527] numChunks[127539] chunk[388411](388422 call - v[127527] 1))
                (388427 call _check_tuple_var_decl tmp[388415] 2)
                const lo[388430] "const"(388432 call tmp[388415] 0)
                const hi[388435] "const"(388437 call tmp[388415] 1)
                (388440 'end of statement')
                if(388442 call _cond_test debugChapelRange[107087])
                {
                  (388447 call chpl_debug_writeln "*** RI: tuple = "(388450 call _build_tuple(388452 call chpl_build_bounded_range lo[388430] hi[388435])))
                }
                (388456 yield(388458 call _build_tuple(388460 call chpl_build_bounded_range lo[388430] hi[388435])))
              }
              (388467 call _downEndCount _coforallCount[388464] nil[32])
              (388466 'coforall loop')
            }
            label _continueLabel[388477]
            _indexOfInterest[388472]
            _iterator[388473]
          }
          label _breakLabel[388478]
          Defer
          {
            {
              (388519 call _endCountFree _coforallCount[388464])
            }
          }
          (388524 call _waitEndCount _coforallCount[388464] 1 numTasks[388465])
        }
        {
          const _coforallCount[388536] "const" "end count" "temp"
          (388592 'move' _coforallCount[388536](388589 call _endCountAlloc 1))
          unknown _indexOfInterest[388544] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[388545] "expr temp" "temp"
          (388554 'move' _iterator[388545](388552 call _getIterator tmpIter[388404]))
          Defer
          {
            {
              (388569 call _freeIterator _iterator[388545])
            }
          }
          { scopeless type
            (388559 'move' _indexOfInterest[388544](388556 call iteratorIndex _iterator[388545]))
          }
          ForLoop[388546]
          {
            unknown chunk[127571] "coforall index var" "index var" "insert auto destroy"
            (388564 'move' chunk[127571] _indexOfInterest[388544])
            (388576 call _upEndCount _coforallCount[388536] 1)
            {
              {
                const tmp[127594] "const" "temp"(127586 call _computeBlock v[127527] numChunks[127539] chunk[127571](127590 call - v[127527] 1))
                (127601 call _check_tuple_var_decl tmp[127594] 2)
                const lo[127581] "const"(127595 call tmp[127594] 0)
                const hi[127583] "const"(127598 call tmp[127594] 1)
                (127606 'end of statement')
                if(127621 call _cond_test debugChapelRange[107087])
                {
                  (127608 call chpl_debug_writeln "*** RI: tuple = "(127617 call _build_tuple(127615 call chpl_build_bounded_range lo[127581] hi[127583])))
                }
                (127626 yield(127632 call _build_tuple(127630 call chpl_build_bounded_range lo[127581] hi[127583])))
              }
              (388539 call _downEndCount _coforallCount[388536] nil[32])
              (388538 'coforall loop')
            }
            label _continueLabel[388549]
            _indexOfInterest[388544]
            _iterator[388545]
          }
          label _breakLabel[388550]
          Defer
          {
            {
              (388580 call _endCountFree _coforallCount[388536])
            }
          }
          (388585 call _waitEndCount _coforallCount[388536] 1)
        }
      }
    }
  }
  where {
    (127104 call == tag[127099] leader[52138])
  }
  function range[240](?).these[127649](arg _mt[127661]:_MT[201], arg this[127652]:range[240](?) :
  range[240](?), param arg tag[127656] :
  iterKind[52144], arg followThis[127659]:_any[141](?)) : _unknown[42] "iterator fn" "method" "no return value for void"
  {
    if(127684 call _cond_test(127678 call && 1(127682 call hasAmbiguousAlignmentForIter this[127652])))
    {
      (127675 call boundsCheckHalt module=[222] HaltWrappers[518] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (402163 'referenced modules list' HaltWrappers[518])
    }
    if(127700 call _cond_test(127693 call ==(429155 call . this[127652] c"bounds") neither[107120]))
    {
      (127690 call compilerError "iteration over a range with no bounds")
    }
    if(127723 call _cond_test(127709 call &&(127715 call(127712 call .(402171 call . this[127652] c"strides") c"isPositive"))(127716 call ==(429160 call . this[127652] c"bounds") high[107118])))
    {
      (127706 call compilerError "iteration over a range with no first index")
    }
    if(127746 call _cond_test(127732 call &&(127738 call(127735 call .(402177 call . this[127652] c"strides") c"isNegative"))(127739 call ==(429165 call . this[127652] c"bounds") low[107116])))
    {
      (127729 call compilerError "iteration over a range with no first index")
    }
    if(127778 call _cond_test(127771 call !=(127774 call . followThis[127659] c"size") 1))
    {
      (127752 call compilerError(127753 call +(127755 call + "rank mismatch in zippered iteration (can't zip a "(127760 call :(127763 call . followThis[127659] c"size") string[244])) "D expression with a range, which is 1D)"))
    }
    if(127791 call _cond_test debugChapelRange[107087])
    {
      (127784 call chpl_debug_writeln "In range follower code: Following " followThis[127659])
    }
    unknown myFollowThis[127797](127799 call followThis[127659] 0)
    (127802 'end of statement')
    if(127811 call _cond_test debugChapelRange[107087])
    {
      (127804 call chpl_debug_writeln "Range = " myFollowThis[127797])
    }
    if(127865 call _cond_test(127855 call && 1(127858 call !(127864 call(127861 call . this[127652] c"hasFirstForIter")))))
    {
      if(127851 call _cond_test(127850 call(127847 call . this[127652] c"isEmpty")))
      {
        if(127834 call _cond_test(127827 call !(127833 call(127830 call . myFollowThis[127797] c"isEmpty"))))
        {
          (127822 call boundsCheckHalt module=[222] HaltWrappers[518] "size mismatch in zippered iteration")
          (402184 'referenced modules list' HaltWrappers[518])
        }
      }
      {
        (127844 call boundsCheckHalt module=[222] HaltWrappers[518] "iteration over a range with no first index")
        (402191 'referenced modules list' HaltWrappers[518])
      }
    }
    if(127908 call _cond_test(127898 call && 1(127901 call !(127907 call(127904 call . myFollowThis[127797] c"hasFirstForIter")))))
    {
      if(127893 call _cond_test(127879 call !(127881 call &&(127887 call(127884 call . myFollowThis[127797] c"isAligned"))(127892 call(127889 call . myFollowThis[127797] c"isEmpty")))))
      {
        (127874 call boundsCheckHalt module=[222] HaltWrappers[518] "zippered iteration over a range with no first index")
        (402199 'referenced modules list' HaltWrappers[518])
      }
    }
    unknown newStrides[127913] "param"(127915 call chpl_strideProduct this[127652] myFollowThis[127797])
    (127919 'end of statement')
    if(128405 call _cond_test(128381 call ||(128383 call &&(128385 call ==(128388 call . myFollowThis[127797] c"bounds") both[107114])(128399 call(128396 call . myFollowThis[127797] c"hasPosNegUnitStride")))(128404 call(128401 call . myFollowThis[127797] c"hasLastForIter"))))
    {
      const flwlen[127922] "const"(127927 call(127924 call . myFollowThis[127797] c"sizeAs")(127929 call . myFollowThis[127797] c"chpl_integralIdxType"))
      (127933 'end of statement')
      if(128020 call _cond_test 1)
      {
        if(127970 call _cond_test(127969 call(127966 call . this[127652] c"hasLastForIter")))
        {
          if(127960 call _cond_test(127943 call &&(127945 call !=(127948 call . this[127652] c"bounds") both[107114])(127955 call !(127958 call isFiniteIdxType(429179 call . this[127652] c"idxType")))))
          {
            (127937 call assert 0 "hasFirstForIter && hasLastForIter do not imply a range is bounded")
          }
        }
        if(128014 call _cond_test(128010 call != flwlen[127922] 0))
        {
          if(128005 call _cond_test(127981 call &&(127983 call ==(127986 call . this[127652] c"bounds") both[107114])(127993 call >=(127996 call . myFollowThis[127797] c"highBound")(128003 call(128000 call . this[127652] c"sizeAs") uint(64)[86]))))
          {
            (127978 call boundsCheckHalt module=[222] HaltWrappers[518] "size mismatch in zippered iteration")
            (402213 'referenced modules list' HaltWrappers[518])
          }
        }
      }
      unknown r[128025](128027 call range[240](?)(429187 call . this[127652] c"idxType")(strides = newStrides[127913]))
      (128032 'end of statement')
      if(128106 call _cond_test(128102 call != flwlen[127922] 0))
      {
        unknown low[128035](128040 call(128037 call . this[127652] c"orderToIndex")(128042 call . myFollowThis[127797] c"first"))
        (128046 'end of statement')
        unknown high[128048](128053 call(128050 call . this[127652] c"orderToIndex")(128055 call . myFollowThis[127797] c"last"))
        (128059 'end of statement')
        if(128078 call _cond_test(128066 call isNegativeStride newStrides[127913](128068 call *(128071 call . this[127652] c"stride")(128075 call . myFollowThis[127797] c"stride"))))
        {
          (128060 call <=> low[128035] high[128048])
        }
        (128089 call(128086 call . r[128025] c"chpl_setFields") low[128035] high[128048](128092 call *(128095 call . this[127652] c"stride")(128099 call . myFollowThis[127797] c"stride")))
      }
      if(128118 call _cond_test debugChapelRange[107087])
      {
        (128111 call chpl_debug_writeln "Expanded range = " r[128025])
      }
      {
        unknown _indexOfInterest[128129] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[128130] "expr temp" "temp"
        (128139 'move' _iterator[128130](128137 call _getIterator r[128025]))
        Defer
        {
          {
            (128154 call _freeIterator _iterator[128130])
          }
        }
        { scopeless type
          (128144 'move' _indexOfInterest[128129](128141 call iteratorIndex _iterator[128130]))
        }
        ForLoop[128131]
        {
          unknown i[128123] "index var" "insert auto destroy"
          (128149 'move' i[128123] _indexOfInterest[128129])
          (128126 yield i[128123])
          label _continueLabel[128134]
          _indexOfInterest[128129]
          _iterator[128130]
        }
        label _breakLabel[128135]
      }
    }
    {
      if(128181 call _cond_test(128173 call && 1(128180 call(128177 call . this[127652] c"hasLastForIter"))))
      {
        (128168 call zipLengthHalt module=[222] HaltWrappers[518] "zippered iteration where a bounded range follows an unbounded iterator")
        (402232 'referenced modules list' HaltWrappers[518])
      }
      const first[128187] "const"(128192 call(128189 call . this[127652] c"orderToIndex")(128194 call . myFollowThis[127797] c"first"))
      (128198 'end of statement')
      const stride[128200] "const"(128201 call *(128204 call . this[127652] c"stride")(128208 call . myFollowThis[127797] c"stride"))
      (128212 'end of statement')
      if(128377 call _cond_test(128374 call isPositiveStride newStrides[127913] stride[128200]))
      {
        const r[128215] "const"(128216 call chpl_by(128219 call chpl_build_low_bounded_range first[128187])(128231 IfExpr (128225 call(128222 call . newStrides[127913] c"isOne")) then
        { scopeless
          1
        } else
        { scopeless
          (128227 call : stride[128200] uint(64)[86])
        } ))
        (128235 'end of statement')
        if(128242 call _cond_test debugChapelRange[107087])
        {
          (128237 call chpl_debug_writeln "Expanded range = " r[128215])
        }
        {
          unknown _indexOfInterest[128253] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[128254] "expr temp" "temp"
          (128263 'move' _iterator[128254](128261 call _getIterator r[128215]))
          Defer
          {
            {
              (128278 call _freeIterator _iterator[128254])
            }
          }
          { scopeless type
            (128268 'move' _indexOfInterest[128253](128265 call iteratorIndex _iterator[128254]))
          }
          ForLoop[128255]
          {
            unknown i[128247] "index var" "insert auto destroy"
            (128273 'move' i[128247] _indexOfInterest[128253])
            (128250 yield i[128247])
            label _continueLabel[128258]
            _indexOfInterest[128253]
            _iterator[128254]
          }
          label _breakLabel[128259]
        }
      }
      {
        unknown r[128287](128289 call range[240](?)(429211 call . this[127652] c"idxType") high[107118](128308 IfExpr (128299 call(128296 call . newStrides[127913] c"isNegOne")) then
        { scopeless
          negOne[107129]
        } else
        { scopeless
          negative[107133]
        } ))
        (128312 'end of statement')
        (128317 call(128314 call . r[128287] c"chpl_setFields")(128318 call : 0(429216 call . this[127652] c"idxType")) first[128187] stride[128200])
        if(128330 call _cond_test debugChapelRange[107087])
        {
          (128325 call chpl_debug_writeln "Expanded range = " r[128287])
        }
        {
          unknown _indexOfInterest[128341] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[128342] "expr temp" "temp"
          (128351 'move' _iterator[128342](128349 call _getIterator r[128287]))
          Defer
          {
            {
              (128366 call _freeIterator _iterator[128342])
            }
          }
          { scopeless type
            (128356 'move' _indexOfInterest[128341](128353 call iteratorIndex _iterator[128342]))
          }
          ForLoop[128343]
          {
            unknown i[128335] "index var" "insert auto destroy"
            (128361 'move' i[128335] _indexOfInterest[128341])
            (128338 yield i[128335])
            label _continueLabel[128346]
            _indexOfInterest[128341]
            _iterator[128342]
          }
          label _breakLabel[128347]
        }
      }
    }
  }
  where {
    (127663 call == tag[127656] follower[52140])
  }
  function :[128412](arg x[128417] :
  (128415 call range[240](?) ?[227]), arg t[128421] :
  string[244]) : _unknown[42] "operator"
  {
    unknown ret[128426] string[244]
    (128429 'end of statement')
    if(128446 call _cond_test(128445 call(128442 call . x[128417] c"hasLowBound")))
    {
      (128430 call += ret[128426](128433 call :(128436 call . x[128417] c"lowBound") string[244]))
    }
    (128451 call += ret[128426] "..")
    if(128510 call _cond_test(128509 call(128506 call . x[128417] c"hasHighBound")))
    {
      if(128501 call _cond_test(128483 call &&(128486 call chpl__singleValIdxType(128488 call . x[128417] c"idxType"))(128491 call !=(128494 call . x[128417] c"_high")(128498 call . x[128417] c"_low"))))
      {
        (128457 call += ret[128426](128460 call + "<"(128465 call :(128468 call . x[128417] c"lowBound") string[244])))
      }
      {
        (128473 call += ret[128426](128476 call :(128479 call . x[128417] c"highBound") string[244]))
      }
    }
    if(128581 call _cond_test(128574 call !=(128577 call . x[128417] c"stride") 1))
    {
      (128515 call += ret[128426](128518 call + " by "(128521 call :(128524 call . x[128417] c"stride") string[244])))
      if(128569 call _cond_test(128542 call &&(128544 call &&(128546 call !=(128549 call . x[128417] c"stride")(128552 call - 1))(128559 call(128556 call . x[128417] c"isAligned")))(128560 call !(128568 call(128565 call . x[128417] c"chpl_isNaturallyAligned")))))
      {
        (128528 call += ret[128426](128531 call + " align "(128534 call :(128537 call . x[128417] c"alignment") string[244])))
      }
    }
    (128585 return ret[128426])
  }
  function range[240](?).chpl__unTranslate[128589](arg _mt[128597]:_MT[201], arg this[128592]:range[240](?) :
  range[240](?), arg i[128595]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (128600 return(128601 call - this[128592] i[128595]))
  }
  function chpl__mod[128607](arg dividend[128610] :
  integral[159](?), arg modulus[128614] :
  integral[159](?)) : _unknown[42]
  {
    unknown t[128629] "type variable"(128631 'typeof' modulus[128614])
    unknown m[128634] modulus[128614]
    (128637 'end of statement')
    if(128662 call _cond_test(128645 call &&(128647 call &&(128650 call isIntType t[128629])(128652 call < m[128634] 0))(128656 call != m[128634](128660 call min t[128629]))))
    {
      (128638 call = m[128634](128641 call - m[128634]))
    }
    unknown tmp[128668](128669 call % dividend[128610](128672 call : m[128634](128676 'typeof' dividend[128610])))
    (128678 'end of statement')
    if(128700 call _cond_test(128698 call isInt dividend[128610]))
    {
      if(128692 call _cond_test(128688 call < tmp[128668] 0))
      {
        (128679 call += tmp[128668](128682 call : m[128634](128686 'typeof' dividend[128610])))
      }
    }
    (128705 return tmp[128668])
  }
  where {
    (128617 call >=(128620 call numBits(128622 'typeof' dividend[128610]))(128624 call numBits(128626 'typeof' modulus[128614])))
  }
  function chpl__mod[128710](arg dividend[128713] :
  integral[159](?), arg modulus[128717] :
  integral[159](?)) : _unknown[42]
  {
    unknown t[128737] "type variable"(128739 'typeof' modulus[128717])
    unknown m[128742] modulus[128717]
    (128745 'end of statement')
    if(128770 call _cond_test(128753 call &&(128755 call &&(128758 call isIntType t[128737])(128760 call < m[128742] 0))(128764 call != m[128742](128768 call min t[128737]))))
    {
      (128746 call = m[128742](128749 call - m[128742]))
    }
    unknown tmp[128776](128777 call %(128779 call : dividend[128713] t[128737]) m[128742])
    (128785 'end of statement')
    if(128803 call _cond_test(128801 call isInt dividend[128713]))
    {
      if(128795 call _cond_test(128791 call < tmp[128776] 0))
      {
        (128786 call += tmp[128776] m[128742])
      }
    }
    (128808 return(128809 call : tmp[128776](128813 'typeof' dividend[128713])))
  }
  where {
    (128720 call &&(128722 call <(128725 call numBits(128727 'typeof' dividend[128713]))(128729 call numBits(128731 'typeof' modulus[128717])))(128733 call isInt modulus[128717]))
  }
  function chpl__diffMod[128817](arg minuend[128820] :
  integral[159](?), arg subtrahend[128824] :
  integral[159](?), arg modulus[128828] :
  integral[159](?)) : _unknown[42]
  {
    const m[128841] "const"(128843 call abs modulus[128828])
    (128846 'end of statement')
    unknown minMod[128848](128850 call chpl__mod minuend[128820] m[128841])
    (128854 'end of statement')
    unknown subMod[128856](128858 call chpl__mod subtrahend[128824] m[128841])
    (128862 'end of statement')
    (128863 return(128883 IfExpr (128864 call < minMod[128848] subMod[128856]) then
    { scopeless
      (128868 call -(128870 call : m[128841](128874 'typeof' minuend[128820]))(128875 call - subMod[128856] minMod[128848]))
    } else
    { scopeless
      (128879 call - minMod[128848] subMod[128856])
    } ))
  }
  where {
    (128833 call ==(128836 'typeof' minuend[128820])(128838 'typeof' subtrahend[128824]))
  }
  { scopeless type
    (128832 'typeof' minuend[128820])
  }
  function chpl__diffMod[128890](arg minuend[128893] :
  integral[159](?), arg subtrahend[128897] :
  integral[159](?), arg modulus[128901] :
  integral[159](?)) : _unknown[42] "no return value for void"
  {
    (128906 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[128912](arg a[128916] :
  unknown t[128914], arg b[128920] :
  t[128914], arg resultType[128923]:_any[141](?)) : _unknown[42]
  {
    if(128937 call _cond_test(128932 call !(128935 call isIntegralType t[128914])))
    {
      (128927 call compilerError "Values must be of integral type.")
    }
    if(128968 call _cond_test(128947 call &&(128949 call &&(128951 call > a[128916] 0)(128955 call > b[128920] 0))(128959 call > b[128920](128962 call -(128965 call max t[128914]) a[128916]))))
    {
      (128942 return(128944 call max resultType[128923]))
    }
    if(128999 call _cond_test(128978 call &&(128980 call &&(128982 call < a[128916] 0)(128986 call < b[128920] 0))(128990 call < b[128920](128993 call -(128996 call min t[128914]) a[128916]))))
    {
      (128973 return(128975 call min resultType[128923]))
    }
    if(129077 call _cond_test(129075 call isUintType resultType[128923]))
    {
      if(129069 call _cond_test(129011 call ||(129013 call &&(129015 call &&(129017 call < a[128916] 0)(129021 call > b[128920] 0))(129025 call ||(129027 call == a[128916](129031 call min t[128914]))(129033 call >(129036 call abs a[128916])(129039 call abs b[128920]))))(129041 call &&(129043 call &&(129045 call > a[128916] 0)(129049 call < b[128920] 0))(129053 call ||(129055 call == b[128920](129059 call min t[128914]))(129061 call >(129064 call abs b[128920])(129067 call abs a[128916]))))))
      {
        (129005 return(129006 call : 0 resultType[128923]))
      }
    }
    (129081 return(129082 call :(129084 call + a[128916] b[128920]) resultType[128923]))
  }
  function chpl__addRangeStrides[129091](arg start[129093]:_any[141](?), arg stride[129095]:_any[141](?), arg count[129097]:_any[141](?)) : _unknown[42]
  {
    function convert[129102](arg a[129104]:_any[141](?), arg b[129106]:_any[141](?)) param : _unknown[42]
    {
      (129109 return(129110 call ||(129112 call &&(129115 call isIntType(129117 'typeof' a[129104]))(129119 call isUintType(129121 'typeof' b[129106])))(129122 call &&(129125 call isUintType(129127 'typeof' a[129104]))(129129 call isIntType(129131 'typeof' b[129106])))))
    }
    function mul[129134](arg a[129136]:_any[141](?), arg b[129138]:_any[141](?)) : _unknown[42]
    {
      (129141 return(129164 IfExpr (129143 call convert a[129136] b[129138]) then
      { scopeless
        (129146 call *(129148 call : a[129136](129152 call int(64)[10] 64))(129154 call : b[129138](129158 call int(64)[10] 64)))
      } else
      { scopeless
        (129160 call * a[129136] b[129138])
      } ))
    }
    function add[129169](arg a[129171]:_any[141](?), arg b[129173]:_any[141](?)) : _unknown[42]
    {
      (129176 return(129199 IfExpr (129178 call convert a[129171] b[129173]) then
      { scopeless
        (129181 call +(129183 call : a[129171](129187 call int(64)[10] 64))(129189 call : b[129173](129193 call int(64)[10] 64)))
      } else
      { scopeless
        (129195 call + a[129171] b[129173])
      } ))
    }
    (129204 return(129205 call :(129208 call add start[129093](129211 call mul stride[129095] count[129097]))(129215 'typeof' start[129093])))
  }
  { scopeless type
    (129100 'typeof' start[129093])
  }
  function chpl__extendedEuclidHelper[129219](arg u[129221]:_any[141](?), arg v[129223]:_any[141](?)) : _unknown[42]
  {
    unknown zero[129227] 0(129229 'typeof' u[129221])
    (129232 'end of statement')
    unknown one[129234] 1(129236 'typeof' u[129221])
    (129239 'end of statement')
    unknown U[129241](129246 call _build_tuple one[129234] zero[129227] u[129221])
    (129249 'end of statement')
    unknown V[129251](129256 call _build_tuple zero[129227] one[129234] v[129223])
    (129259 'end of statement')
    {
      unknown tmp[129303] "temp"
      (129331 'move' tmp[129303](129324 call _cond_test(129326 call !=(129328 call V[129251] 2) 0)))
      WhileDo[129308]
      {
        {
          unknown oldU[129268] U[129241]
          (129271 'end of statement')
          unknown q[129273](129274 call /(129277 call U[129241] 2)(129280 call V[129251] 2))
          (129283 'end of statement')
          (129284 call = U[129241] V[129251])
          (129288 call = V[129251](129291 call - oldU[129268](129294 call * V[129251](129301 call _build_tuple q[129273] q[129273] q[129273]))))
        }
        label _continueLabel[129306]
        (129319 'move' tmp[129303](129312 call _cond_test(129314 call !=(129316 call V[129251] 2) 0)))
        tmp[129303]
      }
      label _breakLabel[129307]
    }
    (129334 return(129342 call _build_tuple(129337 call U[129241] 2)(129340 call U[129241] 0)))
  }
  function chpl__extendedEuclid[129346](arg u[129351] :
  (129349 call int(64)[10] 32), arg v[129357] :
  (129355 call int(64)[10] 32)) : _unknown[42] "inline"
  {
    (129361 return(129363 call chpl__extendedEuclidHelper u[129351] v[129357]))
  }
  function chpl__extendedEuclid[129368](arg u[129373] :
  (129371 call int(64)[10] 64), arg v[129379] :
  (129377 call int(64)[10] 64)) : _unknown[42] "inline"
  {
    (129383 return(129385 call chpl__extendedEuclidHelper u[129373] v[129379]))
  }
  function chpl__rangeIdxTypeError[129390](arg idxType[129392]:_any[141](?)) : _unknown[42] "private" "no return value for void"
  {
    (129396 call compilerError "ranges don't support '"(129400 call : idxType[129392] string[244]) "' as their idxType")
  }
  function chpl__rangeStrideType[129409](arg idxType[129411]:_any[141](?)) type : _unknown[42] "private"
  {
    if(129436 call _cond_test(129434 call isIntegralType idxType[129411]))
    {
      (129415 return(129417 call chpl__signedType idxType[129411]))
    }
    {
      if(129429 call _cond_test(129427 call isFiniteIdxType idxType[129411]))
      {
        (129420 return int(64)[10])
      }
      {
        (129424 call chpl__rangeIdxTypeError idxType[129411])
      }
    }
  }
  function chpl__rangeUnsignedType[129443](arg idxType[129445]:_any[141](?)) type : _unknown[42] "private"
  {
    if(129470 call _cond_test(129468 call isIntegralType idxType[129445]))
    {
      (129449 return(129451 call chpl__unsignedType idxType[129445]))
    }
    {
      if(129463 call _cond_test(129461 call isFiniteIdxType idxType[129445]))
      {
        (129454 return uint(64)[86])
      }
      {
        (129458 call chpl__rangeIdxTypeError idxType[129445])
      }
    }
  }
  function chpl__idxTypeToIntIdxType[129477](arg idxType[129479]:_any[141](?)) type : _unknown[42]
  {
    if(129491 call _cond_test(129489 call isIntegralType idxType[129479]))
    {
      (129483 return idxType[129479])
    }
    {
      (129486 return int(64)[10])
    }
  }
  function range[240](?).chpl_intToIdx[129497](arg _mt[129505]:_MT[201], arg this[129500]:range[240](?) :
  range[240](?), arg i[129503]:_any[141](?)) : _unknown[42] "inline" "method"
  {
    (129508 return(129510 call chpl__intToIdx(129512 call . this[129500] c"idxType") i[129503]))
  }
  function chpl__intToIdx[129518](arg idxType[129521] :
  integral[159](?), arg i[129525] :
  integral[159](?)) : _unknown[42] "inline"
  {
    if(129543 call _cond_test(129538 call ==(129541 'typeof' i[129525]) idxType[129521]))
    {
      (129529 return i[129525])
    }
    {
      (129532 return(129533 call : i[129525] idxType[129521]))
    }
  }
  function chpl__intToIdx[129551](arg idxType[129554] :
  integral[159](?), param arg i[129558] :
  integral[159](?)) param : _unknown[42] "inline"
  {
    if(129576 call _cond_test(129571 call ==(129574 'typeof' i[129558]) idxType[129554]))
    {
      (129562 return i[129558])
    }
    {
      (129565 return(129566 call : i[129558] idxType[129554]))
    }
  }
  function chpl__intToIdx[129584](arg idxType[129587] :
  enum[147](?), arg i[129591] :
  integral[159](?)) : _unknown[42] "inline"
  {
    (129595 return(129597 call chpl__orderToEnum i[129591] idxType[129587]))
  }
  function chpl__intToIdx[129602](arg idxType[129605] :
  enum[147](?), param arg i[129609] :
  integral[159](?)) param : _unknown[42] "inline"
  {
    (129613 return(129615 call chpl__orderToEnum i[129609] idxType[129605]))
  }
  function chpl__intToIdx[129620](arg idxType[129622]:_any[141](?), arg i[129625] :
  integral[159](?)) : _unknown[42] "inline"
  {
    (129632 return(129633 call : i[129625] bool[19]))
  }
  where {
    (129629 call isBoolType idxType[129622])
  }
  function chpl__intToIdx[129640](arg idxType[129642]:_any[141](?), param arg i[129645] :
  integral[159](?)) param : _unknown[42] "inline"
  {
    (129652 return(129653 call : i[129645] bool[19]))
  }
  where {
    (129649 call isBoolType idxType[129642])
  }
  function chpl__intToIdx[129660](arg idxType[129662]:_any[141](?), arg i[129665] :
  nothing[7]) : _unknown[42] "inline"
  {
    (129669 return none[48])
  }
  function chpl__idxToInt[129673](arg i[129676] :
  integral[159](?)) : _unknown[42] "inline"
  {
    (129680 return i[129676])
  }
  function chpl__idxToInt[129684](param arg i[129687] :
  integral[159](?)) param : _unknown[42] "inline"
  {
    (129691 return i[129687])
  }
  function chpl__idxToInt[129695](arg i[129698] :
  enum[147](?)) : _unknown[42] "inline"
  {
    (129702 return(129704 call chpl__enumToOrder i[129698]))
  }
  function chpl__idxToInt[129708](param arg i[129711] :
  enum[147](?)) param : _unknown[42] "inline"
  {
    (129715 return(129717 call chpl__enumToOrder i[129711]))
  }
  function chpl__idxToInt[129721](arg i[129724] :
  bool[19]) : _unknown[42] "inline"
  {
    (129728 return(129729 call : i[129724] int(64)[10]))
  }
  function chpl__idxToInt[129735](param arg i[129738] :
  bool[19]) param : _unknown[42] "inline"
  {
    (129742 return(129743 call : i[129738] int(64)[10]))
  }
  function chpl__singleValIdxType[129749](arg t[129751]:_any[141](?)) param : _unknown[42]
  {
    (129754 return(129755 call &&(129758 call isEnumType t[129751])(129760 call ==(129763 call . t[129751] c"size") 1)))
  }
  function chpl__defaultLowBound[129769](arg t[129771]:_any[141](?), param arg bounds[129774] :
  boundKind[107122]) param : _unknown[42] "private"
  {
    if(129825 call _cond_test(129823 call chpl__singleValIdxType t[129771]))
    {
      (129779 return(129780 call : 0(129784 call chpl__idxTypeToIntIdxType t[129771])))
    }
    {
      if(129818 call _cond_test(129802 call ||(129804 call == bounds[129774] high[107118])(129811 call == bounds[129774] neither[107120])))
      {
        (129787 return(129788 call : 0(129792 call chpl__idxTypeToIntIdxType t[129771])))
      }
      {
        (129795 return(129796 call : 1(129800 call chpl__idxTypeToIntIdxType t[129771])))
      }
    }
  }
  function chpl__defaultHighBound[129832](arg t[129834]:_any[141](?), param arg bounds[129837] :
  boundKind[107122]) param : _unknown[42] "private"
  {
    if(129908 call _cond_test(129906 call chpl__singleValIdxType t[129834]))
    {
      (129842 return(129843 call -(129845 call : 1(129849 call chpl__idxTypeToIntIdxType t[129834]))))
    }
    {
      if(129901 call _cond_test(129885 call ||(129887 call == bounds[129837] low[107116])(129894 call == bounds[129837] neither[107120])))
      {
        if(129873 call _cond_test(129871 call isFiniteIdxType t[129834]))
        {
          (129853 return(129854 call :(129857 call finiteIdxTypeHigh t[129834])(129860 call chpl__idxTypeToIntIdxType t[129834])))
        }
        {
          (129863 return(129864 call : 0(129868 call chpl__idxTypeToIntIdxType t[129834])))
        }
      }
      {
        (129878 return(129879 call : 0(129883 call chpl__idxTypeToIntIdxType t[129834])))
      }
    }
  }
  (396118 'used modules list'(107071 'use' ChapelBase[77907])(107073 'use' HaltWrappers[518])(107077 'use' AutoMath[4943])(107079 'use' DSIUtil[99447])(107080 'use' Reflection[1804])(107084 'use' ChapelDebugPrint[107066] 'only' chpl_debug_writeln))
}