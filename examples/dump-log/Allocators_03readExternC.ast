AST dump for Allocators after pass readExternC.
Module use list: 

{
  (387060 'use' ChapelStandard)
  (307139 'use' CTypes)
  (307142 'use' Reflection)
  (307146 'import' ChapelLocks)
  (307148 'use' ChplConfig)
  function alignup[307150](arg ptr[307155] :
  (307153 call c_ptr void[4]), param arg alignment[307158]:_any[141](?)) : _unknown[42] "inline" "private"
  {
    { scopeless
      unknown mask[307181] "param"(307182 call - alignment 1)
      (307187 'end of statement')
    }
    { scopeless
      const iptr[307189] "const"(307190 call : ptr c_intptr)
      (307195 'end of statement')
    }
    { scopeless
      const alignedPtr[307197] "const"(307198 call &(307200 call + iptr mask)(307204 call ~ mask))
      (307208 'end of statement')
    }
    (307209 return(307210 call : alignedPtr(307214 call c_ptr void[4])))
  }
  where {
    (307163 call &&(307165 call > alignment 0)(307169 call ==(307171 call & alignment(307174 call - alignment 1)) 0))
  }
  { scopeless type
    (307161 call c_ptr void[4])
  }
  type Self[307257]
  {
    function _unknown[42].allocate[307222](arg _mt[307232]:_MT[201], ref arg this[307225] :
    Self, arg n[307229] :
    int[10]) : _unknown[42] "method" "no fn body"
    {
    }
    { scopeless type
      (307235 call c_ptr void[4])
    }
    function _unknown[42].deallocate[307240](arg _mt[307252]:_MT[201], ref arg this[307243] :
    Self, arg p[307249] :
    (307247 call c_ptr void[4])) : _unknown[42] "method" "no fn body"
    {
    }
  }
  function newTypeCheckHelper[307262](arg T[307264]:_any[141](?)) param : _unknown[42] "private"
  {
    if(307285 call _cond_test(307280 call !(307283 call isClassType T)))
    {
      { scopeless
        (307268 call compilerError(307269 call +(307271 call : T string[244]) " is not a class") 2)
      }
    }
    if(307308 call _cond_test(307303 call !(307306 call isUnmanagedClassType T)))
    {
      { scopeless
        (307291 call compilerError(307292 call +(307294 call : T string[244]) " is not unmanaged") 2)
      }
    }
  }
  function checkInterfaceHelper[307315](arg alloc[307317]:_any[141](?)) param : _unknown[42] "private"
  {
    if(307340 call _cond_test(307334 call ==(307336 'implements interface' alloc allocator) 2))
    {
      (307322 call compilerError(307323 call +(307325 call :(307328 'typeof' alloc) string[244]) " does not implement 'allocator'") 2)
    }
  }
  function newWithAllocator[307346](arg alloc[307349] :
  allocator, arg T[307352]:_any[141](?), arg args[307355]:_any[141](?) ...) : _unknown[42] "docs only" "inline"
  {
    (307361 call compilerError "docs-only newWithAllocator should not be compiled")
  }
  { scopeless type
    T
  }
  function newWithAllocator[307368](ref arg alloc[307371] :
  record, arg T[307374]:_any[141](?)) : _unknown[42] "inline"
  {
    (307379 call checkInterfaceHelper alloc)
    (307382 call newTypeCheckHelper T)
    (307384 return(307385 'new with allocator' alloc T))
  }
  { scopeless type
    T
  }
  function newWithAllocator[307391](const  ref arg alloc[307394] :
  class, arg T[307397]:_any[141](?)) : _unknown[42] "inline"
  {
    (307402 call checkInterfaceHelper alloc)
    (307405 call newTypeCheckHelper T)
    (307407 return(307408 'new with allocator' alloc T))
  }
  { scopeless type
    T
  }
  function newWithAllocator[307414](ref arg alloc[307417] :
  record, arg T[307420]:_any[141](?), arg args[307423]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307429 call checkInterfaceHelper alloc)
    (307432 call newTypeCheckHelper T)
    (307434 return(307435 'new with allocator' alloc T(307439 'expand_tuple' args)))
  }
  { scopeless type
    T
  }
  function newWithAllocator[307443](const  ref arg alloc[307446] :
  class, arg T[307449]:_any[141](?), arg args[307452]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307458 call checkInterfaceHelper alloc)
    (307461 call newTypeCheckHelper T)
    (307463 return(307464 'new with allocator' alloc T(307468 'expand_tuple' args)))
  }
  { scopeless type
    T
  }
  function deleteWithAllocator[307472](arg alloc[307475] :
  allocator, arg objects[307479]:_any[141](?) ...) : _unknown[42] "docs only" "inline"
  {
    (307484 call compilerError "docs-only deleteWithAllocator should not be compiled")
  }
  function deleteWithAllocator[307490](ref arg alloc[307493] :
  record, arg objects[307498]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307503 call checkInterfaceHelper alloc)
    {
      unknown i[307505] "index var" 0
      unknown tmp[307555] "maybe param" "temp"
      (307572 'move' tmp[307555](307570 call chpl_compute_low_param_loop_bound 0(307565 call chpl_high_bound_count_for_param_loop 0(307562 call chpl_compute_count_param_loop k))))
      unknown tmp[307556] "maybe param" "temp"
      (307584 'move' tmp[307556](307582 call chpl_compute_high_param_loop_bound 0(307577 call chpl_high_bound_count_for_param_loop 0(307580 call chpl_compute_count_param_loop k))))
      unknown tmp[307557] "maybe param" "temp"
      (307587 'move' tmp[307557] 1)
      ParamForLoop[307589]
      { i[307505] tmp[307555] tmp[307556] tmp[307557]
        {
          (307515 call newTypeCheckHelper(307519 'typeof'(307517 call objects i)))
          if(307551 call _cond_test(307550 call compiledForSingleLocale))
          {
            (307522 call chpl__deleteWithAllocator alloc(307525 call objects i))
          }
          {
            {
              const tmp[307541] "const" "temp"
              (307542 'move' tmp[307541](307539 'deref'(307538 '_wide_get_locale'(307529 call objects i))))
              { scopeless
                (307532 call chpl__deleteWithAllocator alloc(307535 call objects i))
              }
              (307545 'elided on block' 0 tmp[307541])
            }
          }
        }
      }
      label _unused_continueLabel[307559]
      label _breakLabel[307558]
    }
  }
  function deleteWithAllocator[307600](const  ref arg alloc[307603] :
  class, arg objects[307608]:_any[141](?) ...) : _unknown[42] "inline"
  {
    (307613 call checkInterfaceHelper alloc)
    {
      unknown i[307615] "index var" 0
      unknown tmp[307665] "maybe param" "temp"
      (307682 'move' tmp[307665](307680 call chpl_compute_low_param_loop_bound 0(307675 call chpl_high_bound_count_for_param_loop 0(307672 call chpl_compute_count_param_loop k))))
      unknown tmp[307666] "maybe param" "temp"
      (307694 'move' tmp[307666](307692 call chpl_compute_high_param_loop_bound 0(307687 call chpl_high_bound_count_for_param_loop 0(307690 call chpl_compute_count_param_loop k))))
      unknown tmp[307667] "maybe param" "temp"
      (307697 'move' tmp[307667] 1)
      ParamForLoop[307699]
      { i[307615] tmp[307665] tmp[307666] tmp[307667]
        {
          (307625 call newTypeCheckHelper(307629 'typeof'(307627 call objects i)))
          if(307661 call _cond_test(307660 call compiledForSingleLocale))
          {
            (307632 call chpl__deleteWithAllocator alloc(307635 call objects i))
          }
          {
            {
              const tmp[307651] "const" "temp"
              (307652 'move' tmp[307651](307649 'deref'(307648 '_wide_get_locale'(307639 call objects i))))
              { scopeless
                (307642 call chpl__deleteWithAllocator alloc(307645 call objects i))
              }
              (307655 'elided on block' 0 tmp[307651])
            }
          }
        }
      }
      label _unused_continueLabel[307669]
      label _breakLabel[307668]
    }
  }
  function chpl__deleteWithAllocator[307710](const  ref arg alloc[307713] :
  class, const arg obj[307716]:_any[141](?)) : _unknown[42] "inline"
  {
    { scopeless
      unknown p[307720](307722 call c_ptrTo obj)
      (307725 'end of statement')
    }
    if(307738 call _cond_test(307734 call != obj nil[32]))
    {
      { scopeless
        (307732 call(307729 call .(307726 call postfix! obj) c"deinit"))
      }
    }
    (307749 call(307746 call . alloc c"deallocate") p)
  }
  function chpl__deleteWithAllocator[307753](ref arg alloc[307756] :
  record, const arg obj[307759]:_any[141](?)) : _unknown[42] "inline"
  {
    { scopeless
      unknown p[307763](307765 call c_ptrTo obj)
      (307768 'end of statement')
    }
    if(307781 call _cond_test(307777 call != obj nil[32]))
    {
      { scopeless
        (307775 call(307772 call .(307769 call postfix! obj) c"deinit"))
      }
    }
    (307790 call(307787 call . alloc c"deallocate") p)
  }
  type _LockWrapper[307838](?) unknown lockType[307796] "type variable"(307798 call . ChapelLocks c"chpl_LocalSpinlock") unknown lockVar[307803](307804 'new'(307806 call lockType)) function _LockWrapper[307838](?).lock[307809](arg _mt[307813]:_MT[201], arg this[307811]:_LockWrapper[307838](?)) : _unknown[42] "inline" "method" "primary method"
  {
    (307820 call(307817 call . lockVar c"lock"))
  } function _LockWrapper[307838](?).unlock[307823](arg _mt[307827]:_MT[201], arg this[307825]:_LockWrapper[307838](?)) : _unknown[42] "inline" "method" "primary method"
  {
    (307834 call(307831 call . lockVar c"unlock"))
  }
  type mallocWrapper[307898] function mallocWrapper[307898].allocate[307842](arg _mt[307850]:_MT[201], arg this[307844]:mallocWrapper[307898], arg n[307847] :
  int[10]) : _unknown[42] "method" "primary method"
  {
    (307856 return(307863 call(307860 call . CTypes c"allocate")(307865 call int[10] 8)(307871 call(307868 call . n c"safeCast") c_size_t)))
  }
  { scopeless type
    (307853 call c_ptr void[4])
  } function mallocWrapper[307898].deallocate[307876](arg _mt[307886]:_MT[201], arg this[307878]:mallocWrapper[307898], arg p[307883] :
  (307881 call c_ptr void[4])) : _unknown[42] "method" "primary method"
  {
    (307893 call(307890 call . CTypes c"deallocate") p)
  } allocator
  type bumpPtrMemPool[308287](?) unknown parSafe[307903] "param" 0 bool unknown alignment[307909] "param" 16 int[10] unknown size[307915](307917 call int[10] 64) unknown basePtr[307922](307924 call c_ptr(307926 call int[10] 8)) unknown ptr[307931](307933 call c_ptr(307935 call int[10] 8)) unknown lock_[307940](307946 IfExpr  parSafe then
  { scopeless
    (307942 'new'(307944 call _LockWrapper))
  } else
  { scopeless
    none
  } ) function bumpPtrMemPool[308287](?).init[307951](arg _mt[307973]:_MT[201], arg this[307953]:bumpPtrMemPool[308287](?), arg size[307958] :
  (307956 call int[10] 64), param arg parSafe[307963] :
  bool =
  0, param arg alignment[307969] :
  int[10] =
  16) : _unknown[42] "method" "primary method"
  {
    (307976 call =(307979 call . this c"parSafe") parSafe)
    (307983 call =(307986 call . this c"alignment") alignment)
    if(308003 call _cond_test(307996 call <(307999 call . this c"alignment") 0))
    {
      { scopeless
        (307991 call compilerError "alignment must be non-negative")
      }
    }
    if(308030 call _cond_test(308014 call !=(308016 call &(308019 call . this c"alignment")(308022 call -(308025 call . this c"alignment") 1)) 0))
    {
      { scopeless
        (308009 call compilerError "alignment must be a power of 2")
      }
    }
    (308035 call =(308038 call . this c"size") size)
    if(308061 call _cond_test boundsChecking)
    {
      if(308056 call _cond_test(308049 call <=(308052 call . this c"size") 0))
      {
        (308045 call halt "size must be positive")
      }
    }
    (308065 call = basePtr(308072 call(308069 call . CTypes c"allocate")(308074 call int[10] 8)(308083 call(308080 call .(308077 call . this c"size") c"safeCast") c_size_t)))
    (308085 call = ptr basePtr)
    (308093 call(308090 call . this c"chpl__initThisType"))
  } function bumpPtrMemPool[308287](?).deinit[308096](arg _mt[308100]:_MT[201], arg this[308098]:bumpPtrMemPool[308287](?)) : _unknown[42] "destructor" "method" "primary method"
  {
    if(308111 call _cond_test basePtr)
    {
      { scopeless
        (308107 call(308104 call . CTypes c"deallocate") basePtr)
      }
    }
  } function bumpPtrMemPool[308287](?)._lock[308118](arg _mt[308122]:_MT[201], arg this[308120]:bumpPtrMemPool[308287](?)) : _unknown[42] "method" "primary method"
  {
    if(308132 call _cond_test parSafe)
    {
      { scopeless
        (308129 call(308126 call . lock_ c"lock"))
      }
    }
  } function bumpPtrMemPool[308287](?)._unlock[308139](arg _mt[308143]:_MT[201], arg this[308141]:bumpPtrMemPool[308287](?)) : _unknown[42] "inline" "method" "primary method"
  {
    if(308153 call _cond_test parSafe)
    {
      { scopeless
        (308150 call(308147 call . lock_ c"unlock"))
      }
    }
  } function bumpPtrMemPool[308287](?).allocate[308160](arg _mt[308168]:_MT[201], arg this[308162]:bumpPtrMemPool[308287](?), arg n[308165] :
  int[10]) : _unknown[42] "method" "primary method"
  {
    (308175 call _lock)
    if(308192 call _cond_test boundsChecking)
    {
      if(308187 call _cond_test(308183 call <= n 0))
      {
        (308179 call halt "n must be positive")
      }
    }
    if(308218 call _cond_test(308214 call > alignment 0))
    {
      { scopeless
        (308196 call = ptr(308199 call :(308202 call alignup ptr(308205 call . this c"alignment"))(308209 call c_ptr(308211 call int[10] 8))))
      }
    }
    if(308251 call _cond_test boundsChecking)
    {
      if(308246 call _cond_test(308230 call >(308232 call :(308234 call + ptr n) c_intptr)(308239 call :(308241 call + basePtr size) c_intptr)))
      {
        (308226 call halt "out of memory")
      }
    }
    { scopeless
      unknown p[308256] ptr
      (308259 'end of statement')
    }
    (308260 call += ptr n)
    (308265 call _unlock)
    (308266 return p)
  }
  { scopeless type
    (308171 call c_ptr void[4])
  } function bumpPtrMemPool[308287](?).deallocate[308271](arg _mt[308281]:_MT[201], arg this[308273]:bumpPtrMemPool[308287](?), arg p[308278] :
  (308276 call c_ptr void[4])) : _unknown[42] "method" "primary method"
  {
  } allocator
}