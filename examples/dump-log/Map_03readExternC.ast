AST dump for Map after pass readExternC.
Module use list: 

{
  (387086 'use' ChapelStandard)
  (348708 'import' ChapelLocks)
  (348710 'use' ChapelHashtable)
  (348713 'use' HaltWrappers)
  { scopeless
    (348720 'use' IO)
    (348722 'use'(348717 call . IO c"FormattedIO"))
  }
  unknown _lockType[348724] "type variable"(348726 call . ChapelLocks c"chpl_LocalSpinlock")
  type _LockWrapper[348767] unknown lockVar[348732](348733 'new'(348735 call _lockType)) function _LockWrapper[348767].lock[348738](arg _mt[348742]:_MT[201], arg this[348740]:_LockWrapper[348767]) : _unknown[42] "inline" "method" "primary method"
  {
    (348749 call(348746 call . lockVar c"lock"))
  } function _LockWrapper[348767].unlock[348752](arg _mt[348756]:_MT[201], arg this[348754]:_LockWrapper[348767]) : _unknown[42] "inline" "method" "primary method"
  {
    (348763 call(348760 call . lockVar c"unlock"))
  }
  function _checkKeyAndValType[348769](arg K[348771]:_any[141](?), arg V[348773]:_any[141](?)) : _unknown[42] "private"
  {
    if(348823 call _cond_test(348821 call isGenericType K))
    {
      (348778 call compilerWarning "creating a map with key type "(348782 call : K string[244]) 2)
      if(348810 call _cond_test(348797 call &&(348800 call isClassType K)(348802 call !(348805 call isGenericType(348806 call : K borrowed)))))
      {
        (348789 call compilerWarning "which is a class type with generic " "management" 2)
      }
      (348815 call compilerError "map key type cannot currently be generic" 2)
    }
    if(348870 call _cond_test(348868 call isGenericType V))
    {
      (348829 call compilerWarning "creating a map with value type "(348833 call : V string[244]) 2)
      if(348857 call _cond_test(348844 call &&(348847 call isClassType V)(348849 call !(348852 call isGenericType(348853 call : V borrowed)))))
      {
        (348840 call compilerWarning "which is a class type with generic " "management" 2)
      }
      (348862 call compilerError "map value type cannot currently be generic" 2)
    }
  }
  { scopeless
    unknown warnForMapParsafeMismatch[348877] "config" "param" 1
    (348880 'end of statement')
  }
  type map[352283](?) unknown keyType[348884] "type variable" unknown valType[348887] "type variable" unknown parSafe[348890] "param" "@unstable" 0 const resizeThreshold[348895] "const" defaultHashTableResizeThreshold unknown table[348900](348902 call chpl__hashtable keyType valType) unknown _lock[348908](348914 IfExpr  parSafe then
  { scopeless
    (348910 'new'(348912 call _LockWrapper))
  } else
  { scopeless
    none
  } ) function map[352283](?)._enter[348919](arg _mt[348923]:_MT[201], arg this[348921]:map[352283](?)) : _unknown[42] "inline" "method" "primary method"
  {
    if(348933 call _cond_test parSafe)
    {
      { scopeless
        (348930 call(348927 call . _lock c"lock"))
      }
    }
  } function map[352283](?)._leave[348940](arg _mt[348944]:_MT[201], arg this[348942]:map[352283](?)) : _unknown[42] "inline" "method" "primary method"
  {
    if(348954 call _cond_test parSafe)
    {
      { scopeless
        (348951 call(348948 call . _lock c"unlock"))
      }
    }
  } function map[352283](?).init[348961](arg _mt[348977]:_MT[201], arg this[348963]:map[352283](?), arg keyType[348965]:_any[141](?), arg valType[348967]:_any[141](?), arg resizeThreshold[348970] =
  defaultHashTableResizeThreshold, arg initialCapacity[348974] =
  16) : _unknown[42] "method" "primary method"
  {
    (348981 call _checkKeyAndValType keyType valType)
    (348984 call =(348987 call . this c"keyType") keyType)
    (348991 call =(348994 call . this c"valType") valType)
    (348998 call =(349001 call . this c"parSafe") 0)
    if(349039 call _cond_test(349029 call ||(349031 call <= resizeThreshold 0)(349035 call >= resizeThreshold 1)))
    {
      (349007 call warning "'resizeThreshold' must be between 0 and 1." " 'resizeThreshold' will be set to 0.5")
      (349014 call =(349017 call . this c"resizeThreshold") 0.5)
    }
    {
      (349022 call =(349025 call . this c"resizeThreshold") resizeThreshold)
    }
    (349043 call = table(349046 'new'(349048 call chpl__hashtable keyType valType(349052 call . this c"resizeThreshold") initialCapacity)))
  } function map[352283](?).init[349058](arg _mt[349076]:_MT[201], arg this[349060]:map[352283](?), arg keyType[349062]:_any[141](?), arg valType[349064]:_any[141](?), param arg parSafe[349066]:_any[141](?), arg resizeThreshold[349069] =
  defaultHashTableResizeThreshold, arg initialCapacity[349073] =
  16) : _unknown[42] "method" "primary method" "@unstable"
  {
    (349080 call _checkKeyAndValType keyType valType)
    (349083 call =(349086 call . this c"keyType") keyType)
    (349090 call =(349093 call . this c"valType") valType)
    (349097 call =(349100 call . this c"parSafe") parSafe)
    if(349134 call _cond_test(349124 call ||(349126 call <= resizeThreshold 0)(349130 call >= resizeThreshold 1)))
    {
      (349106 call warning "'resizeThreshold' must be between 0 and 1." " 'resizeThreshold' will be set to 0.5")
      (349109 call =(349112 call . this c"resizeThreshold") 0.5)
    }
    {
      (349117 call =(349120 call . this c"resizeThreshold") resizeThreshold)
    }
    (349138 call = table(349141 'new'(349143 call chpl__hashtable keyType valType(349147 call . this c"resizeThreshold") initialCapacity)))
  } function map[352283](?).init=[349153](arg _mt[349168]:_MT[201], arg this[349155]:map[352283](?), ref arg other[349165] :
  (349158 call map unknown kt[349159] unknown vt[349161] unknown ps[349163])) : _unknown[42] "method" "primary method"
  {
    (349177 call =(349180 call . this c"keyType")(349197 IfExpr (349183 call !=(349187 call .(349186 'typeof' this) c"keyType") ?[227]) then
    { scopeless
      (349193 call .(349192 'typeof' this) c"keyType")
    } else
    { scopeless
      kt
    } ))
    (349200 call =(349203 call . this c"valType")(349220 IfExpr (349206 call !=(349210 call .(349209 'typeof' this) c"valType") ?[227]) then
    { scopeless
      (349216 call .(349215 'typeof' this) c"valType")
    } else
    { scopeless
      vt
    } ))
    (349223 call =(349226 call . this c"parSafe")(349243 IfExpr (349229 call !=(349233 call .(349232 'typeof' this) c"parSafe") ?[227]) then
    { scopeless
      (349239 call .(349238 'typeof' this) c"parSafe")
    } else
    { scopeless
      ps
    } ))
    if(349276 call _cond_test(349263 call &&(349265 call !=(349268 call . this c"parSafe")(349272 call . other c"parSafe")) warnForMapParsafeMismatch))
    {
      (349248 call compilerWarning(349249 call +(349251 call +(349253 call + "initializing between two maps with different " "parSafe settings\n") "Note: this warning can be ") "silenced with '-swarnForMapParsafeMismatch=false'"))
    }
    (349280 call =(349283 call . this c"resizeThreshold")(349287 call . other c"resizeThreshold"))
    (349290 call =(349293 call . this c"table")(349296 'new'(349298 call chpl__hashtable keyType valType resizeThreshold)))
    (349306 call(349303 call . this c"chpl__initThisType"))
    if(349530 call _cond_test(349526 call != keyType kt))
    {
      (349309 call compilerError "cannot initialize "(349311 call :(349314 'typeof' this) string[244]) " from "(349317 call :(349320 'typeof' other) string[244]) " due to key type mismatch")
    }
    {
      { scopeless
        if(349521 call _cond_test(349517 call != valType vt))
        {
          (349327 call compilerError "cannot initialize "(349329 call :(349332 'typeof' this) string[244]) " from "(349335 call :(349338 'typeof' other) string[244]) " due to value type mismatch")
        }
        {
          { scopeless
            if(349512 call _cond_test(349507 call !(349510 call isCopyableType keyType)))
            {
              (349345 call compilerError "cannot initialize "(349347 call :(349350 'typeof' this) string[244]) " from "(349353 call :(349356 'typeof' other) string[244]) " because key type "(349361 call : keyType string[244]) " is not copyable")
            }
            {
              { scopeless
                if(349503 call _cond_test(349498 call !(349501 call isCopyableType valType)))
                {
                  (349370 call compilerError "cannot initialize "(349372 call :(349375 'typeof' this) string[244]) " from "(349378 call :(349381 'typeof' other) string[244]) " because value type "(349386 call : valType string[244]) " is not copyable")
                }
                {
                  {
                    unknown _indexOfInterest[349466] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[349467] "expr temp" "temp"
                    (349476 'move' _iterator[349467](349474 call _getIterator(349400 call(349397 call . other c"keys"))))
                    Defer
                    {
                      {
                        (349491 call _freeIterator _iterator[349467])
                      }
                    }
                    { scopeless type
                      (349481 'move' _indexOfInterest[349466](349478 call iteratorIndex _iterator[349467]))
                    }
                    ForLoop[349468]
                    {
                      unknown key[349392] "index var" "insert auto destroy"
                      (349486 'move' key[349392] _indexOfInterest[349466])
                      {
                        { scopeless
                          const tmp[349413] "const" "temp"(349411 call(349408 call . table c"findAvailableSlot") key)
                          (349417 call _check_tuple_var_decl tmp[349413] 2)
                          const slot[349405] "const"(349414 call tmp[349413] 1)
                          (349422 'end of statement')
                        }
                        { scopeless
                          const tmp[349437] "const" "temp"(349435 call(349432 call .(349429 call . other c"table") c"findFullSlot") key)
                          (349441 call _check_tuple_var_decl tmp[349437] 2)
                          const slot2[349426] "const"(349438 call tmp[349437] 1)
                          (349446 'end of statement')
                        }
                        (349451 call(349448 call . table c"fillSlot") slot key(349463 call .(349461 call(349458 call .(349455 call . other c"table") c"table") slot2) c"val"))
                      }
                      label _continueLabel[349471]
                      _indexOfInterest[349466]
                      _iterator[349467]
                    }
                    label _breakLabel[349472]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
    (349174 call <(349171 'lifetime_of' this)(349173 'lifetime_of' other))
  } function map[352283](?).clear[349538](arg _mt[349542]:_MT[201], ref arg this[349540]:map[352283](?)) : _unknown[42] "method" "primary method"
  {
    (349546 call _enter)
    Defer
    {
      { scopeless
        (349548 call _leave)
      }
    }
    {
      unknown _indexOfInterest[349589] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[349590] "expr temp" "temp"
      (349599 'move' _iterator[349590](349597 call _getIterator(349558 call(349555 call . table c"allSlots"))))
      Defer
      {
        {
          (349614 call _freeIterator _iterator[349590])
        }
      }
      { scopeless type
        (349604 'move' _indexOfInterest[349589](349601 call iteratorIndex _iterator[349590]))
      }
      ForLoop[349591]
      {
        unknown slot[349552] "index var" "insert auto destroy"
        (349609 'move' slot[349552] _indexOfInterest[349589])
        {
          if(349585 call _cond_test(349583 call(349580 call . table c"isSlotFull") slot))
          {
            { scopeless
              unknown key[349562] keyType
              (349565 'end of statement')
            }
            { scopeless
              unknown val[349567] valType
              (349570 'end of statement')
            }
            (349575 call(349572 call . table c"clearSlot") slot key val)
          }
        }
        label _continueLabel[349594]
        _indexOfInterest[349589]
        _iterator[349590]
      }
      label _breakLabel[349595]
    }
    (349625 call(349622 call . table c"maybeShrinkAfterRemove"))
  } function map[352283](?).size[349628](arg _mt[349632]:_MT[201], const arg this[349630]:map[352283](?)) : _unknown[42] "inline" "method" "primary method" "no parens"
  {
    (349636 call _enter)
    Defer
    {
      { scopeless
        (349638 call _leave)
      }
    }
    (349642 return _size)
  } function map[352283](?)._size[349646](arg _mt[349650]:_MT[201], const arg this[349648]:map[352283](?)) : _unknown[42] "inline" "method" "primary method" "no parens"
  {
    (349653 return(349655 call . table c"tableNumFullSlots"))
  } function map[352283](?).isEmpty[349660](arg _mt[349664]:_MT[201], const arg this[349662]:map[352283](?)) : _unknown[42] "inline" "method" "primary method"
  {
    (349668 return(349669 call == size 0))
  }
  { scopeless type
    bool
  } function map[352283](?).contains[349676](arg _mt[349684]:_MT[201], const arg this[349678]:map[352283](?), const arg k[349681] :
  keyType) : _unknown[42] "method" "primary method"
  {
    (349689 call _enter)
    Defer
    {
      { scopeless
        (349691 call _leave)
      }
    }
    { scopeless
      unknown tmp[349706] "temp"(349704 call(349701 call . table c"findFullSlot") k)
      (349710 call _check_tuple_var_decl tmp[349706] 2)
      unknown result[349696](349707 call tmp[349706] 0)
      (349715 'end of statement')
    }
    (349716 return result)
  }
  { scopeless type
    bool
  } function map[352283](?).extend[349721](arg _mt[349733]:_MT[201], ref arg this[349723]:map[352283](?), ref arg m[349730] :
  (349726 call map keyType valType parSafe)) : _unknown[42] "method" "primary method"
  {
    (349737 call _enter)
    Defer
    {
      { scopeless
        (349739 call _leave)
      }
    }
    if(349761 call _cond_test(349749 call ||(349751 call !(349754 call isCopyableType keyType))(349756 call !(349759 call isCopyableType valType))))
    {
      { scopeless
        (349744 call compilerError "extending map with non-copyable type")
      }
    }
    {
      unknown _indexOfInterest[349838] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[349839] "expr temp" "temp"
      (349848 'move' _iterator[349839](349846 call _getIterator(349772 call(349769 call . m c"keys"))))
      Defer
      {
        {
          (349863 call _freeIterator _iterator[349839])
        }
      }
      { scopeless type
        (349853 'move' _indexOfInterest[349838](349850 call iteratorIndex _iterator[349839]))
      }
      ForLoop[349840]
      {
        unknown key[349766] "index var" "insert auto destroy"
        (349858 'move' key[349766] _indexOfInterest[349838])
        {
          { scopeless
            unknown tmp[349785] "temp"(349783 call(349780 call . table c"findAvailableSlot") key)
            (349789 call _check_tuple_var_decl tmp[349785] 2)
            unknown slot[349777](349786 call tmp[349785] 1)
            (349794 'end of statement')
          }
          { scopeless
            unknown tmp[349809] "temp"(349807 call(349804 call .(349801 call . m c"table") c"findAvailableSlot") key)
            (349813 call _check_tuple_var_decl tmp[349809] 2)
            unknown slot2[349798](349810 call tmp[349809] 1)
            (349818 'end of statement')
          }
          (349823 call(349820 call . table c"fillSlot") slot key(349835 call .(349833 call(349830 call .(349827 call . m c"table") c"table") slot2) c"val"))
        }
        label _continueLabel[349843]
        _indexOfInterest[349838]
        _iterator[349839]
      }
      label _breakLabel[349844]
    }
  } function map[352283](?).update[349872](arg _mt[349882]:_MT[201], arg this[349874]:map[352283](?), const  ref arg k[349877] :
  keyType, arg updater[349880]:_any[141](?)) : _unknown[42] throws "method" "primary method"
  {
    (349886 call _enter)
    Defer
    {
      { scopeless
        (349888 call _leave)
      }
    }
    { scopeless
      unknown tmp[349903] "temp"(349901 call(349898 call . table c"findFullSlot") k)
      (349910 call _check_tuple_var_decl tmp[349903] 2)
      unknown isFull[349893](349904 call tmp[349903] 0)
      unknown slot[349895](349907 call tmp[349903] 1)
      (349915 'end of statement')
    }
    if(349925 call _cond_test(349922 call ! isFull))
    {
      { scopeless
        (349916 'throw'(349917 'new'(349919 call KeyNotFoundError k)))
      }
    }
    { scopeless
      const key[349931] "const" "ref var"(349938 call .(349936 call(349933 call . table c"table") slot) c"key")
      (349942 'end of statement')
    }
    { scopeless
      unknown val[349944] "ref var"(349951 call .(349949 call(349946 call . table c"table") slot) c"val")
      (349955 'end of statement')
    }
    (349958 'import' Reflection)
    if(350006 call _cond_test(349995 call !(350001 call(349998 call . Reflection c"canResolveMethod") updater "this" key val)))
    {
      { scopeless
        (349960 call compilerError(349961 call +(349963 call +(349965 call +(349967 call +(349969 call +(349971 call + "`map.update()` failed to resolve method "(349976 call :(349979 'typeof' updater) string[244])) ".this() for arguments (")(349982 call :(349985 'typeof' key) string[244])) ", ")(349988 call :(349991 'typeof' val) string[244])) ")"))
      }
    }
    (350011 return(350013 call updater key val))
  } function map[352283](?)._warnForParSafeIndexing[350018](arg _mt[350022]:_MT[201], arg this[350020]:map[352283](?)) : _unknown[42] "inline" "method" "primary method"
  {
    if(350036 call _cond_test parSafe)
    {
      { scopeless
        (350026 call compilerError "cannot index into a map initialized with " "`parSafe=true`" 2)
      }
    }
  } function map[352283](?).this[350043](arg _mt[350051]:_MT[201], ref arg this[350045]:map[352283](?), arg k[350048] :
  keyType) ref : _unknown[42] "method" "primary method"
  {
    (350058 call _warnForParSafeIndexing)
    (350060 call _enter)
    Defer
    {
      { scopeless
        (350062 call _leave)
      }
    }
    { scopeless
      unknown tmp[350077] "temp"(350075 call(350072 call . table c"findAvailableSlot") k)
      (350081 call _check_tuple_var_decl tmp[350077] 2)
      unknown slot[350069](350078 call tmp[350077] 1)
      (350086 'end of statement')
    }
    if(350109 call _cond_test(350101 call !(350107 call(350104 call . table c"isSlotFull") slot)))
    {
      { scopeless
        unknown val[350089] valType
        (350092 'end of statement')
      }
      (350097 call(350094 call . table c"fillSlot") slot k val)
    }
    (350113 return(350120 call .(350118 call(350115 call . table c"table") slot) c"val"))
  }
  where {
    (350054 call isDefaultInitializable valType)
  } function map[352283](?).this[350126](arg _mt[350134]:_MT[201], ref arg this[350128]:map[352283](?), arg k[350131] :
  keyType) ref : _unknown[42] throws "method" "primary method"
  {
    (350138 call _warnForParSafeIndexing)
    (350140 call _enter)
    Defer
    {
      { scopeless
        (350142 call _leave)
      }
    }
    { scopeless
      unknown tmp[350157] "temp"(350155 call(350152 call . table c"findAvailableSlot") k)
      (350161 call _check_tuple_var_decl tmp[350157] 2)
      unknown slot[350149](350158 call tmp[350157] 1)
      (350166 'end of statement')
    }
    if(350181 call _cond_test(350173 call !(350179 call(350176 call . table c"isSlotFull") slot)))
    {
      (350168 'throw'(350169 'new'(350171 call KeyNotFoundError k)))
    }
    { scopeless
      unknown result[350186] "ref var"(350193 call .(350191 call(350188 call . table c"table") slot) c"val")
      (350197 'end of statement')
    }
    (350198 return result)
  } function map[352283](?).this[350202](arg _mt[350210]:_MT[201], const arg this[350204]:map[352283](?), arg k[350207] :
  keyType) const ref : _unknown[42] throws "method" "primary method"
  {
    (350214 call _warnForParSafeIndexing)
    (350216 call _enter)
    Defer
    {
      { scopeless
        (350218 call _leave)
      }
    }
    { scopeless
      unknown tmp[350233] "temp"(350231 call(350228 call . table c"findFullSlot") k)
      (350240 call _check_tuple_var_decl tmp[350233] 2)
      unknown found[350223](350234 call tmp[350233] 0)
      unknown slot[350225](350237 call tmp[350233] 1)
      (350245 'end of statement')
    }
    if(350255 call _cond_test(350252 call ! found))
    {
      { scopeless
        (350246 'throw'(350247 'new'(350249 call KeyNotFoundError k)))
      }
    }
    { scopeless
      const result[350261] "const" "ref var"(350268 call .(350266 call(350263 call . table c"table") slot) c"val")
      (350272 'end of statement')
    }
    (350273 return result)
  } function map[352283](?).getBorrowed[350277](arg _mt[350285]:_MT[201], arg this[350279]:map[352283](?), arg k[350282] :
  keyType) : _unknown[42] "deprecated" "method" "primary method"
  {
    (350292 call _enter)
    Defer
    {
      { scopeless
        (350294 call _leave)
      }
    }
    { scopeless
      unknown tmp[350309] "temp"(350307 call(350304 call . table c"findFullSlot") k)
      (350316 call _check_tuple_var_decl tmp[350309] 2)
      unknown found[350299](350310 call tmp[350309] 0)
      unknown slot[350301](350313 call tmp[350309] 1)
      (350321 'end of statement')
    }
    if(350337 call _cond_test(350334 call ! found))
    {
      { scopeless
        (350323 call boundsCheckHalt(350332 'try!-expr'(350330 call(350327 call . "map index %\? out of bounds" c"format") k)))
      }
    }
    Try!
    {
      {
        { scopeless
          unknown result[350344](350357 call(350354 call .(350351 call .(350349 call(350346 call . table c"table") slot) c"val") c"borrow"))
          (350359 'end of statement')
        }
        if(350371 call _cond_test(350369 call isNonNilableClass valType))
        {
          (350361 return(350362 call postfix! result))
        }
        {
          (350366 return result)
        }
      }
    }
  }
  where {
    (350288 call isClass valType)
  } function map[352283](?).getReference[350381](arg _mt[350389]:_MT[201], arg this[350383]:map[352283](?), arg k[350386] :
  keyType) ref : _unknown[42] "deprecated" "method" "primary method"
  {
    if(350402 call _cond_test parSafe)
    {
      { scopeless
        (350393 call compilerError "cannot call `getReference()` on maps initialized " "with `parSafe=true`")
      }
    }
    (350408 call _enter)
    Defer
    {
      { scopeless
        (350410 call _leave)
      }
    }
    { scopeless
      unknown tmp[350425] "temp"(350423 call(350420 call . table c"findFullSlot") k)
      (350432 call _check_tuple_var_decl tmp[350425] 2)
      unknown found[350415](350426 call tmp[350425] 0)
      unknown slot[350417](350429 call tmp[350425] 1)
      (350437 'end of statement')
    }
    if(350451 call _cond_test(350448 call ! found))
    {
      { scopeless
        (350439 call boundsCheckHalt(350446 'try!-expr'(350444 call(350441 call . "map index %\? out of bounds" c"format") k)))
      }
    }
    { scopeless
      unknown result[350457] "ref var"(350464 call .(350462 call(350459 call . table c"table") slot) c"val")
      (350468 'end of statement')
    }
    (350469 return result)
  } function map[352283](?).getValue[350473](arg _mt[350481]:_MT[201], arg this[350475]:map[352283](?), arg k[350478] :
  keyType) : _unknown[42] throws "deprecated" "method" "primary method"
  {
    if(350506 call _cond_test(350501 call !(350504 call isCopyableType valType)))
    {
      { scopeless
        (350485 call compilerError(350486 call +(350488 call + "cannot call `getValue()` for non-copyable " "map value type: ")(350496 call : valType string[244])))
      }
    }
    (350512 call _enter)
    Defer
    {
      { scopeless
        (350514 call _leave)
      }
    }
    { scopeless
      unknown tmp[350529] "temp"(350527 call(350524 call . table c"findFullSlot") k)
      (350536 call _check_tuple_var_decl tmp[350529] 2)
      unknown found[350519](350530 call tmp[350529] 0)
      unknown slot[350521](350533 call tmp[350529] 1)
      (350541 'end of statement')
    }
    if(350551 call _cond_test(350548 call ! found))
    {
      { scopeless
        (350542 'throw'(350543 'new'(350545 call KeyNotFoundError k)))
      }
    }
    Try!
    {
      {
        { scopeless
          const result[350558] "const"(350559 call :(350567 call .(350565 call(350562 call . table c"table") slot) c"val") valType)
          (350572 'end of statement')
        }
        (350573 return result)
      }
    }
  } function map[352283](?).get[350580](arg _mt[350592]:_MT[201], arg this[350582]:map[352283](?), arg k[350585] :
  keyType, const arg sentinel[350589] :
  valType) : _unknown[42] "method" "primary method"
  {
    if(350615 call _cond_test(350610 call !(350613 call isCopyableType valType)))
    {
      { scopeless
        (350596 call compilerError(350597 call +(350599 call + "cannot call `get()` for non-copyable " "map value type: ")(350605 call : valType string[244])))
      }
    }
    (350621 call _enter)
    Defer
    {
      { scopeless
        (350623 call _leave)
      }
    }
    { scopeless
      unknown tmp[350638] "temp"(350636 call(350633 call . table c"findFullSlot") k)
      (350645 call _check_tuple_var_decl tmp[350638] 2)
      unknown found[350628](350639 call tmp[350638] 0)
      unknown slot[350630](350642 call tmp[350638] 1)
      (350650 'end of statement')
    }
    if(350657 call _cond_test(350654 call ! found))
    {
      { scopeless
        (350651 return sentinel)
      }
    }
    Try!
    {
      {
        { scopeless
          const result[350664] "const"(350665 call :(350673 call .(350671 call(350668 call . table c"table") slot) c"val") valType)
          (350678 'end of statement')
        }
        (350679 return result)
      }
    }
  } function map[352283](?).getValue[350686](arg _mt[350698]:_MT[201], arg this[350688]:map[352283](?), arg k[350691] :
  keyType, const arg sentinel[350695] :
  valType) : _unknown[42] "deprecated" "method" "primary method"
  {
    if(350719 call _cond_test(350714 call !(350717 call isCopyableType valType)))
    {
      { scopeless
        (350702 call compilerError(350703 call +(350705 call + "cannot call `getValue()` for non-copyable " "map value type: ")(350709 call : valType string[244])))
      }
    }
    (350725 call _enter)
    Defer
    {
      { scopeless
        (350727 call _leave)
      }
    }
    { scopeless
      unknown tmp[350742] "temp"(350740 call(350737 call . table c"findFullSlot") k)
      (350749 call _check_tuple_var_decl tmp[350742] 2)
      unknown found[350732](350743 call tmp[350742] 0)
      unknown slot[350734](350746 call tmp[350742] 1)
      (350754 'end of statement')
    }
    if(350761 call _cond_test(350758 call ! found))
    {
      { scopeless
        (350755 return sentinel)
      }
    }
    Try!
    {
      {
        { scopeless
          const result[350768] "const"(350769 call :(350777 call .(350775 call(350772 call . table c"table") slot) c"val") valType)
          (350782 'end of statement')
        }
        (350783 return result)
      }
    }
  } function map[352283](?).getAndRemove[350790](arg _mt[350798]:_MT[201], ref arg this[350792]:map[352283](?), arg k[350795] :
  keyType) : _unknown[42] "method" "primary method"
  {
    (350802 call _enter)
    Defer
    {
      { scopeless
        (350804 call _leave)
      }
    }
    { scopeless
      unknown tmp[350819] "temp"(350817 call(350814 call . table c"findFullSlot") k)
      (350826 call _check_tuple_var_decl tmp[350819] 2)
      unknown found[350809](350820 call tmp[350819] 0)
      unknown slot[350811](350823 call tmp[350819] 1)
      (350831 'end of statement')
    }
    if(350845 call _cond_test(350842 call ! found))
    {
      { scopeless
        (350833 call boundsCheckHalt(350840 'try!-expr'(350838 call(350835 call . "map index %\? out of bounds" c"format") k)))
      }
    }
    Try!
    {
      {
        { scopeless
          { scopeless
            unknown result[350857] valType
          }
          { scopeless
            unknown key[350853] keyType
          }
          (350860 'end of statement')
        }
        (350865 call(350862 call . table c"clearSlot") slot key result)
        (350873 call(350870 call . table c"maybeShrinkAfterRemove"))
        (350874 return(350875 call : result valType))
      }
    }
  } function map[352283](?).these[350884](arg _mt[350888]:_MT[201], arg this[350886]:map[352283](?)) const ref : _unknown[42] "deprecated" "iterator fn" "method" "primary method"
  {
    {
      unknown _indexOfInterest[350901] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[350902] "expr temp" "temp"
      (350911 'move' _iterator[350902](350909 call _getIterator(350897 call(350894 call . this c"keys"))))
      Defer
      {
        {
          (350926 call _freeIterator _iterator[350902])
        }
      }
      { scopeless type
        (350916 'move' _indexOfInterest[350901](350913 call iteratorIndex _iterator[350902]))
      }
      ForLoop[350903]
      {
        unknown key[350891] "index var" "insert auto destroy"
        (350921 'move' key[350891] _indexOfInterest[350901])
        {
          (350899 yield key)
        }
        label _continueLabel[350906]
        _indexOfInterest[350901]
        _iterator[350902]
      }
      label _breakLabel[350907]
    }
  } function map[352283](?).keys[350935](arg _mt[350939]:_MT[201], arg this[350937]:map[352283](?)) const ref : _unknown[42] "iterator fn" "method" "primary method"
  {
    {
      unknown _indexOfInterest[350974] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[350975] "expr temp" "temp"
      (350984 'move' _iterator[350975](350982 call _getIterator(350948 call(350945 call . table c"allSlots"))))
      Defer
      {
        {
          (350999 call _freeIterator _iterator[350975])
        }
      }
      { scopeless type
        (350989 'move' _indexOfInterest[350974](350986 call iteratorIndex _iterator[350975]))
      }
      ForLoop[350976] order-independent
      {
        unknown slot[350942] "index var" "insert auto destroy"
        (350994 'move' slot[350942] _indexOfInterest[350974])
        {
          if(350967 call _cond_test(350965 call(350962 call . table c"isSlotFull") slot))
          {
            { scopeless
              (350950 yield(350957 call .(350955 call(350952 call . table c"table") slot) c"key"))
            }
          }
        }
        label _continueLabel[350979]
        _indexOfInterest[350974]
        _iterator[350975]
      }
      label _breakLabel[350980]
    }
  } function map[352283](?).items[351008](arg _mt[351012]:_MT[201], arg this[351010]:map[352283](?)) : _unknown[42] "deprecated" "iterator fn" "method" "primary method"
  {
    if(351035 call _cond_test(351030 call !(351033 call isCopyableType keyType)))
    {
      { scopeless
        (351016 call compilerError(351017 call +(351019 call + "in map.items(): map key type "(351024 call : keyType string[244])) " is not copyable"))
      }
    }
    if(351060 call _cond_test(351055 call !(351058 call isCopyableType valType)))
    {
      { scopeless
        (351041 call compilerError(351042 call +(351044 call + "in map.items(): map value type "(351049 call : valType string[244])) " is not copyable"))
      }
    }
    {
      unknown _indexOfInterest[351108] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[351109] "expr temp" "temp"
      (351118 'move' _iterator[351109](351116 call _getIterator(351071 call(351068 call . table c"allSlots"))))
      Defer
      {
        {
          (351133 call _freeIterator _iterator[351109])
        }
      }
      { scopeless type
        (351123 'move' _indexOfInterest[351108](351120 call iteratorIndex _iterator[351109]))
      }
      ForLoop[351110] order-independent
      {
        unknown slot[351065] "index var" "insert auto destroy"
        (351128 'move' slot[351065] _indexOfInterest[351108])
        {
          if(351102 call _cond_test(351100 call(351097 call . table c"isSlotFull") slot))
          {
            { scopeless
              unknown tabEntry[351075] "ref var"(351080 call(351077 call . table c"table") slot)
              (351083 'end of statement')
            }
            (351084 yield(351094 call _build_tuple(351087 call . tabEntry c"key")(351091 call . tabEntry c"val")))
          }
        }
        label _continueLabel[351113]
        _indexOfInterest[351108]
        _iterator[351109]
      }
      label _breakLabel[351114]
    }
  } function map[352283](?).values[351142](arg _mt[351146]:_MT[201], arg this[351144]:map[352283](?)) ref : _unknown[42] "iterator fn" "method" "primary method"
  {
    {
      unknown _indexOfInterest[351181] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[351182] "expr temp" "temp"
      (351191 'move' _iterator[351182](351189 call _getIterator(351155 call(351152 call . table c"allSlots"))))
      Defer
      {
        {
          (351206 call _freeIterator _iterator[351182])
        }
      }
      { scopeless type
        (351196 'move' _indexOfInterest[351181](351193 call iteratorIndex _iterator[351182]))
      }
      ForLoop[351183] order-independent
      {
        unknown slot[351149] "index var" "insert auto destroy"
        (351201 'move' slot[351149] _indexOfInterest[351181])
        {
          if(351174 call _cond_test(351172 call(351169 call . table c"isSlotFull") slot))
          {
            { scopeless
              (351157 yield(351164 call .(351162 call(351159 call . table c"table") slot) c"val"))
            }
          }
        }
        label _continueLabel[351186]
        _indexOfInterest[351181]
        _iterator[351182]
      }
      label _breakLabel[351187]
    }
  } function map[352283](?)._readHelper[351215](arg _mt[351225]:_MT[201], ref arg this[351217]:map[352283](?), arg r[351220] :
  fileReader, ref arg deserializer[351223]:_any[141](?)) : _unknown[42] throws "method" "primary method"
  {
    if(351263 call _cond_test(351234 call &&(351236 call ==(351239 'typeof' deserializer) defaultDeserializer)(351241 call ||(351243 call ||(351245 call ||(351247 call == keyType string[244])(351251 call == valType string[244]))(351255 call == keyType bytes[232]))(351259 call == valType bytes[232]))))
    {
      { scopeless
        (351229 call compilerError "Default IO format for 'map' does not support reading when the key or value type is  'string' or 'bytes'.")
      }
    }
    (351272 call(351269 call . this c"clear"))
    (351274 call _enter)
    Defer
    {
      { scopeless
        (351276 call _leave)
      }
    }
    { scopeless
      unknown des[351281](351286 call(351283 call . deserializer c"startMap") r)
      (351289 'end of statement')
    }
    { scopeless
      unknown done[351291] 0
      (351294 'end of statement')
    }
    {
      unknown tmp[351315] "temp"
      (351341 'move' tmp[351315](351335 call _cond_test(351340 call(351337 call . des c"hasMore"))))
      WhileDo[351320]
      {
        {
          (351302 call add(351307 call(351304 call . des c"readKey") keyType)(351313 call(351310 call . des c"readValue") valType))
        }
        label _continueLabel[351318]
        (351330 'move' tmp[351315](351324 call _cond_test(351329 call(351326 call . des c"hasMore"))))
        tmp[351315]
      }
      label _breakLabel[351319]
    }
    (351348 call(351345 call . des c"endMap"))
  } function map[352283](?).deserialize[351351](arg _mt[351361]:_MT[201], ref arg this[351353]:map[352283](?), arg reader[351356] :
  fileReader, ref arg deserializer[351359]:_any[141](?)) : _unknown[42] throws "method" "primary method"
  {
    (351365 call _readHelper reader deserializer)
  } function map[352283](?).init[351370](arg _mt[351384]:_MT[201], arg this[351372]:map[352283](?), arg keyType[351374]:_any[141](?), arg valType[351376]:_any[141](?), arg reader[351379] :
  fileReader, ref arg deserializer[351382]:_any[141](?)) : _unknown[42] throws "method" "primary method"
  {
    (351391 call(351388 call . this c"init") keyType valType parSafe)
    (351396 call _readHelper reader deserializer)
  } function map[352283](?).init[351401](arg _mt[351417]:_MT[201], arg this[351403]:map[352283](?), arg keyType[351405]:_any[141](?), arg valType[351407]:_any[141](?), param arg parSafe[351409]:_any[141](?), arg reader[351412] :
  fileReader, ref arg deserializer[351415]:_any[141](?)) : _unknown[42] throws "method" "primary method" "@unstable"
  {
    (351424 call(351421 call . this c"init") keyType valType parSafe)
    (351429 call _readHelper reader deserializer)
  } function map[352283](?).serialize[351434](arg _mt[351446]:_MT[201], arg this[351436]:map[352283](?), arg writer[351441] :
  (351439 call fileWriter ?[227]), ref arg serializer[351444]:_any[141](?)) : _unknown[42] throws "method" "primary method"
  {
    (351450 call _enter)
    Defer
    {
      { scopeless
        (351452 call _leave)
      }
    }
    { scopeless
      unknown ser[351457](351462 call(351459 call . serializer c"startMap") writer _size)
      (351466 'end of statement')
    }
    {
      unknown _indexOfInterest[351514] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[351515] "expr temp" "temp"
      (351524 'move' _iterator[351515](351522 call _getIterator(351473 call(351470 call . table c"allSlots"))))
      Defer
      {
        {
          (351539 call _freeIterator _iterator[351515])
        }
      }
      { scopeless type
        (351529 'move' _indexOfInterest[351514](351526 call iteratorIndex _iterator[351515]))
      }
      ForLoop[351516]
      {
        unknown slot[351467] "index var" "insert auto destroy"
        (351534 'move' slot[351467] _indexOfInterest[351514])
        {
          if(351510 call _cond_test(351508 call(351505 call . table c"isSlotFull") slot))
          {
            { scopeless
              unknown tabEntry[351477] "ref var"(351482 call(351479 call . table c"table") slot)
              (351485 'end of statement')
            }
            (351490 call(351487 call . ser c"writeKey")(351492 call . tabEntry c"key"))
            (351499 call(351496 call . ser c"writeValue")(351501 call . tabEntry c"val"))
          }
        }
        label _continueLabel[351519]
        _indexOfInterest[351514]
        _iterator[351515]
      }
      label _breakLabel[351520]
    }
    (351550 call(351547 call . ser c"endMap"))
  } function map[352283](?).add[351553](arg _mt[351565]:_MT[201], ref arg this[351555]:map[352283](?), in arg k[351558] :
  keyType, in arg v[351562] :
  valType) : _unknown[42] "method" "primary method"
  {
    (351576 call _enter)
    Defer
    {
      { scopeless
        (351578 call _leave)
      }
    }
    { scopeless
      unknown tmp[351593] "temp"(351591 call(351588 call . table c"findAvailableSlot") k)
      (351600 call _check_tuple_var_decl tmp[351593] 2)
      unknown found[351583](351594 call tmp[351593] 0)
      unknown slot[351585](351597 call tmp[351593] 1)
      (351605 'end of statement')
    }
    if(351610 call _cond_test found)
    {
      (351607 return 0)
    }
    (351618 call(351615 call . table c"fillSlot") slot k v)
    (351622 return 1)
  }
  {
    (351572 call <(351569 'lifetime_of' this)(351571 'lifetime_of' v))
  }
  { scopeless type
    bool
  } function map[352283](?).set[351628](arg _mt[351640]:_MT[201], ref arg this[351630]:map[352283](?), arg k[351633] :
  keyType, in arg v[351637] :
  valType) : _unknown[42] "deprecated" "method" "primary method"
  {
    (351644 return(351649 call(351646 call . this c"replace") k v))
  }
  { scopeless type
    bool
  } function map[352283](?).replace[351655](arg _mt[351667]:_MT[201], ref arg this[351657]:map[352283](?), arg k[351660] :
  keyType, in arg v[351664] :
  valType) : _unknown[42] "method" "primary method"
  {
    (351672 call _enter)
    Defer
    {
      { scopeless
        (351674 call _leave)
      }
    }
    { scopeless
      unknown tmp[351689] "temp"(351687 call(351684 call . table c"findAvailableSlot") k)
      (351696 call _check_tuple_var_decl tmp[351689] 2)
      unknown found[351679](351690 call tmp[351689] 0)
      unknown slot[351681](351693 call tmp[351689] 1)
      (351701 'end of statement')
    }
    if(351708 call _cond_test(351705 call ! found))
    {
      (351703 return 0)
    }
    (351716 call(351713 call . table c"fillSlot") slot k v)
    (351720 return 1)
  }
  { scopeless type
    bool
  } function map[352283](?).addOrReplace[351725](arg _mt[351737]:_MT[201], ref arg this[351727]:map[352283](?), in arg k[351730] :
  keyType, in arg v[351734] :
  valType) : _unknown[42] "method" "primary method"
  {
    (351741 call _enter)
    Defer
    {
      { scopeless
        (351743 call _leave)
      }
    }
    { scopeless
      unknown tmp[351758] "temp"(351756 call(351753 call . table c"findAvailableSlot") k)
      (351765 call _check_tuple_var_decl tmp[351758] 2)
      unknown found[351748](351759 call tmp[351758] 0)
      unknown slot[351750](351762 call tmp[351758] 1)
      (351770 'end of statement')
    }
    (351775 call(351772 call . table c"fillSlot") slot k v)
  } function map[352283](?).addOrSet[351781](arg _mt[351793]:_MT[201], ref arg this[351783]:map[352283](?), in arg k[351786] :
  keyType, in arg v[351790] :
  valType) : _unknown[42] "deprecated" "method" "primary method"
  {
    (351797 call addOrReplace k v)
  } function map[352283](?).remove[351802](arg _mt[351810]:_MT[201], ref arg this[351804]:map[352283](?), arg k[351807] :
  keyType) : _unknown[42] "method" "primary method"
  {
    (351815 call _enter)
    Defer
    {
      { scopeless
        (351817 call _leave)
      }
    }
    { scopeless
      unknown tmp[351832] "temp"(351830 call(351827 call . table c"findFullSlot") k)
      (351839 call _check_tuple_var_decl tmp[351832] 2)
      unknown found[351822](351833 call tmp[351832] 0)
      unknown slot[351824](351836 call tmp[351832] 1)
      (351844 'end of statement')
    }
    if(351851 call _cond_test(351848 call ! found))
    {
      (351846 return 0)
    }
    { scopeless
      { scopeless
        unknown outKey[351861] keyType
      }
      { scopeless
        unknown outVal[351857] valType
      }
      (351864 'end of statement')
    }
    (351869 call(351866 call . table c"clearSlot") slot outKey outVal)
    (351877 call(351874 call . table c"maybeShrinkAfterRemove"))
    (351878 return 1)
  }
  { scopeless type
    bool
  } function map[352283](?).toArray[351883](arg _mt[351887]:_MT[201], arg this[351885]:map[352283](?)) : _unknown[42] "method" "primary method"
  {
    (351899 call _enter)
    Defer
    {
      { scopeless
        (351901 call _leave)
      }
    }
    if(351923 call _cond_test(351911 call ||(351913 call !(351916 call isCopyableType keyType))(351918 call !(351921 call isCopyableType valType))))
    {
      { scopeless
        (351906 call compilerError "toArray requires copyable key and value types")
      }
    }
    { scopeless
      unknown A[351929](351943 call chpl__buildArrayRuntimeType(351936 call chpl__ensureDomainExpr(351930 call #(351933 call chpl_build_low_bounded_range 0) _size))(351941 call _build_tuple keyType valType))
      (351946 'end of statement')
    }
    {
      unknown _indexOfInterest[351972] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[351973] "expr temp" "temp"
      (351992 'move' _iterator[351973](351962 call _build_tuple(351982 call _getIterator A)(351986 call _getIterator(351985 call keys))(351990 call _getIterator(351989 call values))))
      Defer
      {
        {
          (352026 call _freeIterator _iterator[351973])
        }
      }
      { scopeless type
        (351997 'move' _indexOfInterest[351972](351994 call iteratorIndex _iterator[351973]))
      }
      ForLoop[351974]
      {
        (352002 call _check_tuple_var_decl _indexOfInterest[351972] 3)
        unknown a[351948] "index var" "insert auto destroy"
        (352009 'move' a[351948](352006 call _indexOfInterest[351972] 0))
        unknown k[351950] "index var" "insert auto destroy"
        (352015 'move' k[351950](352012 call _indexOfInterest[351972] 1))
        unknown v[351952] "index var" "insert auto destroy"
        (352021 'move' v[351952](352018 call _indexOfInterest[351972] 2))
        {
          (351964 call = a(351970 call _build_tuple k v))
        }
        label _continueLabel[351977]
        _indexOfInterest[351972]
        _iterator[351973]
      }
      label _breakLabel[351978]
    }
    (352033 return A)
  }
  { scopeless type
    (351895 call chpl__buildArrayRuntimeType nil[32](351893 call _build_tuple keyType valType))
  } function map[352283](?).keysToArray[352038](arg _mt[352042]:_MT[201], arg this[352040]:map[352283](?)) : _unknown[42] "method" "primary method"
  {
    (352050 call _enter)
    Defer
    {
      { scopeless
        (352052 call _leave)
      }
    }
    if(352067 call _cond_test(352062 call !(352065 call isCopyableType keyType)))
    {
      { scopeless
        (352057 call compilerError "keysToArray requires a copyable key type")
      }
    }
    { scopeless
      unknown A[352073](352083 call chpl__buildArrayRuntimeType(352080 call chpl__ensureDomainExpr(352074 call #(352077 call chpl_build_low_bounded_range 0) _size)) keyType)
      (352086 'end of statement')
    }
    {
      unknown _indexOfInterest[352104] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[352105] "expr temp" "temp"
      (352120 'move' _iterator[352105](352098 call _build_tuple(352114 call _getIterator A)(352118 call _getIterator(352117 call keys))))
      Defer
      {
        {
          (352148 call _freeIterator _iterator[352105])
        }
      }
      { scopeless type
        (352125 'move' _indexOfInterest[352104](352122 call iteratorIndex _iterator[352105]))
      }
      ForLoop[352106]
      {
        (352130 call _check_tuple_var_decl _indexOfInterest[352104] 2)
        unknown a[352088] "index var" "insert auto destroy"
        (352137 'move' a[352088](352134 call _indexOfInterest[352104] 0))
        unknown k[352090] "index var" "insert auto destroy"
        (352143 'move' k[352090](352140 call _indexOfInterest[352104] 1))
        {
          (352100 call = a k)
        }
        label _continueLabel[352109]
        _indexOfInterest[352104]
        _iterator[352105]
      }
      label _breakLabel[352110]
    }
    (352155 return A)
  }
  { scopeless type
    (352046 call chpl__buildArrayRuntimeType nil[32] keyType)
  } function map[352283](?).valuesToArray[352160](arg _mt[352164]:_MT[201], arg this[352162]:map[352283](?)) : _unknown[42] "method" "primary method"
  {
    (352172 call _enter)
    Defer
    {
      { scopeless
        (352174 call _leave)
      }
    }
    if(352189 call _cond_test(352184 call !(352187 call isCopyableType valType)))
    {
      { scopeless
        (352179 call compilerError "valuesToArray requires a copyable value type")
      }
    }
    { scopeless
      unknown A[352195](352205 call chpl__buildArrayRuntimeType(352202 call chpl__ensureDomainExpr(352196 call #(352199 call chpl_build_low_bounded_range 0) _size)) valType)
      (352208 'end of statement')
    }
    {
      unknown _indexOfInterest[352226] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[352227] "expr temp" "temp"
      (352242 'move' _iterator[352227](352220 call _build_tuple(352236 call _getIterator A)(352240 call _getIterator(352239 call values))))
      Defer
      {
        {
          (352270 call _freeIterator _iterator[352227])
        }
      }
      { scopeless type
        (352247 'move' _indexOfInterest[352226](352244 call iteratorIndex _iterator[352227]))
      }
      ForLoop[352228]
      {
        (352252 call _check_tuple_var_decl _indexOfInterest[352226] 2)
        unknown a[352210] "index var" "insert auto destroy"
        (352259 'move' a[352210](352256 call _indexOfInterest[352226] 0))
        unknown v[352212] "index var" "insert auto destroy"
        (352265 'move' v[352212](352262 call _indexOfInterest[352226] 1))
        {
          (352222 call = a v)
        }
        label _continueLabel[352231]
        _indexOfInterest[352226]
        _iterator[352227]
      }
      label _breakLabel[352232]
    }
    (352277 return A)
  }
  { scopeless type
    (352168 call chpl__buildArrayRuntimeType nil[32] valType)
  } serializable
  function _unknown[42].=[352285](arg _mt[352309]:_MT[201], arg this[352288] :
  map, ref arg lhs[352298] :
  (352292 call map unknown kt[352293] unknown vt[352295] ?[227]), const  ref arg rhs[352306] :
  (352302 call map kt vt ?[227])) : _unknown[42] "assignop" "method" "operator"
  {
    if(352330 call _cond_test(352318 call ||(352320 call !(352323 call isCopyableType kt))(352325 call !(352328 call isCopyableType vt))))
    {
      { scopeless
        (352313 call compilerError "assigning map with non-copyable type")
      }
    }
    (352339 call(352336 call . lhs c"clear"))
    Try!
    {
      {
        {
          unknown _indexOfInterest[352358] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[352359] "expr temp" "temp"
          (352368 'move' _iterator[352359](352366 call _getIterator(352347 call(352344 call . rhs c"keys"))))
          Defer
          {
            {
              (352383 call _freeIterator _iterator[352359])
            }
          }
          { scopeless type
            (352373 'move' _indexOfInterest[352358](352370 call iteratorIndex _iterator[352359]))
          }
          ForLoop[352360]
          {
            unknown key[352341] "index var" "insert auto destroy"
            (352378 'move' key[352341] _indexOfInterest[352358])
            {
              (352353 call(352350 call . lhs c"add") key(352356 call rhs key))
            }
            label _continueLabel[352363]
            _indexOfInterest[352358]
            _iterator[352359]
          }
          label _breakLabel[352364]
        }
      }
    }
  }
  function _unknown[42].:[352395](arg _mt[352423]:_MT[201], arg this[352398] :
  map, arg x[352409] :
  (352402 call map unknown k1[352403] unknown v1[352405] unknown p1[352407]), arg t[352420] :
  (352413 call map unknown k2[352414] unknown v2[352416] unknown p2[352418])) : _unknown[42] "method" "operator"
  {
    if(352443 call _cond_test(352439 call != k1 k2))
    {
      { scopeless
        (352427 call compilerError "Cannot cast to map with different " "key type: "(352434 call : k2 string[244]))
      }
    }
    if(352463 call _cond_test(352459 call != v1 v2))
    {
      { scopeless
        (352449 call compilerError "Cannot cast to map with different " "value type: "(352454 call : v2 string[244]))
      }
    }
    { scopeless
      unknown result[352469] x t
      (352473 'end of statement')
    }
    (352474 return result)
  }
  function _unknown[42].==[352478](arg _mt[352496]:_MT[201], arg this[352481] :
  map, const  ref arg a[352487] :
  (352485 call map ?[227]), const  ref arg b[352493] :
  (352491 call map ?[227])) : _unknown[42] "method" "operator"
  {
    if(352528 call _cond_test(352518 call !=(352521 call . a c"keyType")(352525 call . b c"keyType")))
    {
      { scopeless
        (352501 call compilerError "cannot compare maps with different key types: "(352505 call :(352508 call . a c"keyType") string[244]) " and "(352514 call . b c"keyType"))
      }
    }
    if(352561 call _cond_test(352551 call !=(352554 call . a c"valType")(352558 call . b c"valType")))
    {
      { scopeless
        (352534 call compilerError "cannot compare maps with different value types: "(352538 call :(352541 call . a c"valType") string[244]) " and "(352547 call . b c"valType"))
      }
    }
    if(352579 call _cond_test(352569 call !=(352572 call . a c"_size")(352576 call . b c"_size")))
    {
      { scopeless
        (352566 return 0)
      }
    }
    Try!
    {
      {
        {
          unknown _indexOfInterest[352619] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[352620] "expr temp" "temp"
          (352629 'move' _iterator[352620](352627 call _getIterator(352591 call(352588 call . a c"keys"))))
          Defer
          {
            {
              (352644 call _freeIterator _iterator[352620])
            }
          }
          { scopeless type
            (352634 'move' _indexOfInterest[352619](352631 call iteratorIndex _iterator[352620]))
          }
          ForLoop[352621]
          {
            unknown key[352585] "index var" "insert auto destroy"
            (352639 'move' key[352585] _indexOfInterest[352619])
            {
              if(352614 call _cond_test(352596 call ||(352598 call !(352604 call(352601 call . b c"contains") key))(352606 call !=(352609 call a key)(352612 call b key))))
              {
                { scopeless
                  (352593 return 0)
                }
              }
            }
            label _continueLabel[352624]
            _indexOfInterest[352619]
            _iterator[352620]
          }
          label _breakLabel[352625]
        }
        {
          unknown _indexOfInterest[352685] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[352686] "expr temp" "temp"
          (352695 'move' _iterator[352686](352693 call _getIterator(352657 call(352654 call . b c"keys"))))
          Defer
          {
            {
              (352710 call _freeIterator _iterator[352686])
            }
          }
          { scopeless type
            (352700 'move' _indexOfInterest[352685](352697 call iteratorIndex _iterator[352686]))
          }
          ForLoop[352687]
          {
            unknown key[352651] "index var" "insert auto destroy"
            (352705 'move' key[352651] _indexOfInterest[352685])
            {
              if(352680 call _cond_test(352662 call ||(352664 call !(352670 call(352667 call . a c"contains") key))(352672 call !=(352675 call a key)(352678 call b key))))
              {
                { scopeless
                  (352659 return 0)
                }
              }
            }
            label _continueLabel[352690]
            _indexOfInterest[352685]
            _iterator[352686]
          }
          label _breakLabel[352691]
        }
      }
    }
    (352720 return 1)
  }
  { scopeless type
    bool
  }
  function _unknown[42].!=[352725](arg _mt[352743]:_MT[201], arg this[352728] :
  map, const  ref arg a[352734] :
  (352732 call map ?[227]), const  ref arg b[352740] :
  (352738 call map ?[227])) : _unknown[42] "method" "operator"
  {
    if(352773 call _cond_test(352763 call !=(352766 call . a c"keyType")(352770 call . b c"keyType")))
    {
      { scopeless
        (352748 call compilerError "cannot compare maps with different key types: "(352750 call :(352753 call . a c"keyType") string[244]) " and "(352759 call . b c"keyType"))
      }
    }
    if(352804 call _cond_test(352794 call !=(352797 call . a c"valType")(352801 call . b c"valType")))
    {
      { scopeless
        (352779 call compilerError "cannot compare maps with different value types: "(352781 call :(352784 call . a c"valType") string[244]) " and "(352790 call . b c"valType"))
      }
    }
    (352809 return(352810 call !(352812 call == a b)))
  }
  { scopeless type
    bool
  }
  type KeyNotFoundError[352856] function KeyNotFoundError[352856].init[352821](arg _mt[352825]:_MT[201], arg this[352823]:KeyNotFoundError[352856]) : _unknown[42] "method" "primary method"
  {
  } function KeyNotFoundError[352856].init[352830](arg _mt[352836]:_MT[201], arg this[352832]:KeyNotFoundError[352856], arg k[352834]:_any[141](?)) : _unknown[42] "method" "primary method"
  {
    (352843 call(352840 call . super c"init")(352852 'try!-expr'(352850 call(352847 call . "key '%\?' not found" c"format") k)))
  } Error
}